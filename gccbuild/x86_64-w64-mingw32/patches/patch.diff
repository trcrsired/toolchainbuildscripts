[PATCH 1/2] Import GNU Readline 8.2
Tom Tromey tom@tromey.com
Sat Nov 16 20:49:51 GMT 2024
Previous message (by thread): [PATCH 0/2] Upgrade to Readline 8.2
Next message (by thread): [PATCH 1/2] Import GNU Readline 8.2
Messages sorted by: [ date ] [ thread ] [ subject ] [ author ]
This imports readline 8.2 patch 13.

This time around I thought I would try to document the process.

First I have a checkout of the upstream readline repository.  I make a
local branch there, based on the previous upstream import.  In this
case that was readline 8.1; see gdb commit b4f26d541aa.

Then, I apply all readline changes from the gdb repository since the
previous readline import.  In this case that is up to commit
3dee0baea2e in the gdb repo.

After this, I "git merge" from the relevant upstream commit.  In the
past I feel like I used a tag, but readline is managed very strangely
and I didn't see a tag.  So I just used the patch 13 commit, aka
commit 037d85f1 upstream.

Then I fixed all the merge conflicts.  Re-running autoconf requires a
symlink from '../../config' into the gdb tree, due to the local
m4_include addition.  It's possible other hacks like this are
required, I don't remember how I set things up in the past.

After this, I did a build + test of gdb.  I also did a mingw
cross-hosted build, because that's caused build failures in past
imports.

Bug: https://sourceware.org/bugzilla/show_bug.cgi?id=32265
---
 readline/readline/CHANGELOG                  |   47 +-
 readline/readline/CHANGES                    |  124 ++-
 readline/readline/INSTALL                    |   46 +-
 readline/readline/MANIFEST                   |   10 +-
 readline/readline/Makefile.in                |    8 +-
 readline/readline/NEWS                       |   61 +-
 readline/readline/README                     |    4 +-
 readline/readline/aclocal.m4                 |  891 +++++++++---------
 readline/readline/bind.c                     |  204 ++++-
 readline/readline/callback.c                 |   16 +-
 readline/readline/chardefs.h                 |   31 +-
 readline/readline/colors.c                   |   23 +-
 readline/readline/compat.c                   |   22 +-
 readline/readline/complete.c                 |  128 +--
 readline/readline/config.h.in                |   27 +-
 readline/readline/configure                  |  779 ++++++++--------
 readline/readline/configure.ac               |   57 +-
 readline/readline/display.c                  |  145 +--
 readline/readline/doc/Makefile.in            |   11 +-
 readline/readline/doc/history.3              |    2 +-
 readline/readline/doc/history.texi           |    2 +-
 readline/readline/doc/hstech.texi            |    2 +-
 readline/readline/doc/hsuser.texi            |   22 +-
 readline/readline/doc/readline.3             |   99 +-
 readline/readline/doc/rlman.texi             |    2 +-
 readline/readline/doc/rltech.texi            |   85 +-
 readline/readline/doc/rluser.texi            |  110 ++-
 readline/readline/doc/rluserman.texi         |    2 +-
 readline/readline/doc/texi2dvi               |    0
 readline/readline/doc/texi2html              |    0
 readline/readline/doc/version.texi           |   13 +-
 readline/readline/examples/Makefile.in       |   11 +-
 readline/readline/examples/excallback.c      |    4 +
 readline/readline/examples/fileman.c         |    2 +-
 readline/readline/examples/rl-callbacktest.c |    4 +-
 readline/readline/examples/rl-test-timeout   |    6 +
 readline/readline/examples/rl-timeout.c      |  245 +++++
 readline/readline/examples/rl.c              |    8 +
 readline/readline/examples/rlbasic.c         |    8 +
 readline/readline/examples/rlcat.c           |    8 +
 readline/readline/examples/rlevent.c         |    8 +
 readline/readline/examples/rlptytest.c       |   11 +-
 readline/readline/examples/rltest.c          |    8 +
 readline/readline/funmap.c                   |    6 +-
 readline/readline/histexpand.c               |   45 +-
 readline/readline/histfile.c                 |   14 +-
 readline/readline/histlib.h                  |   11 +-
 readline/readline/history.c                  |   13 +-
 readline/readline/history.h                  |   79 +-
 readline/readline/history.pc.in              |   11 +
 readline/readline/histsearch.c               |    6 +-
 readline/readline/input.c                    |  355 +++++++-
 readline/readline/isearch.c                  |   31 +-
 readline/readline/keymaps.h                  |   18 +-
 readline/readline/kill.c                     |   46 +-
 readline/readline/m4/codeset.m4              |   24 +
 readline/readline/macro.c                    |    2 +
 readline/readline/mbutil.c                   |   36 +-
 readline/readline/misc.c                     |   68 +-
 readline/readline/nls.c                      |  100 ++-
 readline/readline/parens.c                   |    8 +-
 readline/readline/patchlevel                 |    2 +-
 readline/readline/posixdir.h                 |    2 +-
 readline/readline/posixtime.h                |   84 ++
 readline/readline/readline.c                 |  121 ++-
 readline/readline/readline.h                 |  597 +++++++------
 readline/readline/rldefs.h                   |    8 +-
 readline/readline/rlmbutil.h                 |   38 +-
 readline/readline/rlprivate.h                |  325 ++++---
 readline/readline/rlshell.h                  |   12 +-
 readline/readline/rltty.c                    |   41 +-
 readline/readline/rltypedefs.h               |   56 +-
 readline/readline/search.c                   |   90 +-
 readline/readline/shell.c                    |    4 +-
 readline/readline/signals.c                  |   71 +-
 readline/readline/support/config.guess       | 1238 ++++++++++++++------------
 readline/readline/support/config.rpath       |    0
 readline/readline/support/config.sub         |   82 +-
 readline/readline/support/install.sh         |    0
 readline/readline/support/mkdirs             |    0
 readline/readline/support/mkdist             |   13 +-
 readline/readline/support/mkinstalldirs      |    0
 readline/readline/support/shlib-install      |    0
 readline/readline/support/shobj-conf         |   12 +-
 readline/readline/terminal.c                 |  110 ++-
 readline/readline/text.c                     |  108 ++-
 readline/readline/tilde.h                    |   22 +-
 readline/readline/undo.c                     |    6 +-
 readline/readline/util.c                     |    7 +-
 readline/readline/vi_mode.c                  |  123 +--
 readline/readline/xmalloc.h                  |    8 +-
 91 files changed, 4623 insertions(+), 2726 deletions(-)

diff --git a/readline/readline/CHANGELOG b/readline/readline/CHANGELOG
index 5c24e91e0ad1446754266ea7ec8045713dfdd62e..b2fcb534e0935b612983f7b8aba80b4d546c215e 100644
--- a/readline/readline/CHANGELOG
+++ b/readline/readline/CHANGELOG
@@ -1,4 +1,4 @@
-\[Readline-specific changelog.  Descriptions of changes to the source are
+[Readline-specific changelog.  Descriptions of changes to the source are
  found in the bash changelog.]
 
 				    6/9
@@ -1403,3 +1403,48 @@ configure.ac
 
 INSTALL
 	- document new --enable-bracketed-paste-default configure option
+
+				   12/4
+				   ----
+[readline-8.1 frozen]
+
+				 8/17/2021
+				 ---------
+configure.ac
+	- use `:+' when testing the value of $GCC, since autoconf seems to
+	  set it to the empty string if gcc isn't the compiler. Reported by
+	  Osipov, Michael (LDA IT PLM) <michael.osipov@siemens.com>
+
+				    9/2
+				    ---
+configure.ac
+	- AC_HELP_STRING -> AS_HELP_STRING
+	- AC_OUTPUT: split into AC_CONFIG_FILES and AC_CONFIG_COMMANDS, call
+	  AC_OUTPUT without any parameters
+
+				    9/3
+				    ---
+configure.ac, config.h.in
+	- AC_TYPE_SIGNAL,BASH_TYPE_SIGHANDLER: remove calls, remove mention of
+          RETSIGTYPE and VOID_SIGHANDLER 
+	- AC_HEADER_TIME: removed
+	- AC_USE_SYSTEM_EXTENSIONS: use instead of AC_AIX and AC_MINIX
+	- AC_HEADER_STDC: removed
+	- BASH_FUNC_CTYPE_NONASCII: removed
+
+				   11/25
+				   -----
+history.pc.in
+	- pkgconfig file for history library. From Siteshwar Vashisht
+	  <svashisht@redhat.com>
+
+configure.ac,MANIFEST,Makefile.in
+	- support for creating history.pc
+
+				 3/29/2022
+				 ---------
+configure.ac
+	- new option: --with-shared-termcap-library: use to force the shared
+	  readline library to be linked against a shared termcap/curses library
+	  that configure finds. If the argument begins with `-l', use that
+	  library instead; updated INSTALL accordingly
diff --git a/readline/readline/CHANGES b/readline/readline/CHANGES
index 747fa41962f2ee6604a6354b691ea5a136a7487d..eb54caa7db2bd14ff7c492db45fc88e2d63b2804 100644
--- a/readline/readline/CHANGES
+++ b/readline/readline/CHANGES
@@ -1,3 +1,117 @@
+This document details the changes between this version, readline-8.2, and
+the previous version, readline-8.1.
+
+1. Changes to Readline
+
+a. Fixed a problem with cleaning up active marks when using callback mode.
+
+b. Fixed a problem with arithmetic comparison operators checking the version.
+
+c. Fixed a problem that could cause readline not to build on systems without
+   POSIX signal functions.
+
+d. Fixed a bug that could cause readline to crash if the application removed
+   the callback line handler before readline read all typeahead.
+
+e. Added additional checks for read errors in the middle of readline commands.
+
+f. Fixed a redisplay problem that occurred when switching from the digit-
+   argument prompt `(arg: N)' back to the regular prompt and the regular
+   prompt contained invisible characters.
+
+g. Fixed a problem with restoring the prompt when aborting an incremental
+   search.
+
+h. Fix a problem with characters > 128 not being displayed correctly in certain
+   single-byte encodings.
+
+i. Fixed a problem with unix-filename-rubout that caused it to delete too much
+   when applied to a pathname consisting only of one or more slashes.
+
+j. Fixed a display problem that caused the prompt to be wrapped incorrectly if
+   the screen changed dimensions during a call to readline() and the prompt
+   became longer than the screen width.
+
+k. Fixed a problem that caused the \r output by turning off bracketed paste
+   to overwrite the line if terminal echo was disabled.
+
+l. Fixed a bug that could cause colored-completion-prefix to not display if
+   completion-prefix-display-length was set.
+
+m. Fixed a problem with line wrapping prompts when a group of invisible
+   characters runs to the right edge of the screen and the prompt extends
+   longer then the screen width.
+
+n. Fixed a couple problems that could cause rl_end to be set incorrectly by
+   transpose-words.
+
+o. Prevent some display problems when running a command as the result of a
+   trap or one bound using `bind -x' and the command generates output.
+
+p. Fixed an issue with multi-line prompt strings that have one or more
+   invisible characters at the end of a physical line.
+
+q. Fixed an issue that caused a history line's undo list to be cleared when
+   it should not have been.
+
+r. When replacing a history entry, make sure the existing entry has a non-NULL
+   timestamp before copying it; it may have been added by the application, not
+   the history library.
+
+2. New Features in Readline
+
+a. There is now an HS_HISTORY_VERSION containing the version number of the
+   history library for applications to use.
+
+b. History expansion better understands multiple history expansions that may
+   contain strings that would ordinarily inhibit history expansion (e.g.,
+   `abc!$!$').
+
+c. There is a new framework for readline timeouts, including new public
+   functions to set timeouts and query how much time is remaining before a
+   timeout hits, and a hook function that can trigger when readline times
+   out. There is a new state value to indicate a timeout.
+
+d. Automatically bind termcap key sequences for page-up and page-down to
+   history-search-backward and history-search-forward, respectively.
+
+e. There is a new `fetch-history' bindable command that retrieves the history
+   entry corresponding to its numeric argument. Negative arguments count back
+   from the end of the history.
+
+f. `vi-undo' is now a bindable command.
+
+g. There is a new option: `enable-active-region'. This separates control of
+   the active region and bracketed-paste. It has the same default value as
+   bracketed-paste, and enabling bracketed paste enables the active region.
+   Users can now turn off the active region while leaving bracketed paste
+   enabled.
+
+h. rl_completer_word_break_characters is now `const char *' like
+   rl_basic_word_break_characters.
+
+i. Readline looks in $LS_COLORS for a custom filename extension
+   (*.readline-colored-completion-prefix) and uses that as the default color
+   for the common prefix displayed when `colored-completion-prefix' is set.
+
+j. Two new bindable string variables: active-region-start-color and
+   active-region-end-color. The first sets the color used to display the
+   active region; the second turns it off. If set, these are used in place
+   of terminal standout mode.
+
+k. New readline state (RL_STATE_EOF) and application-visible variable
+   (rl_eof_found) to allow applications to detect when readline reads EOF
+   before calling the deprep-terminal hook.
+
+l. There is a new configuration option: --with-shared-termcap-library, which
+   forces linking the shared readline library with the shared termcap (or
+   curses/ncurses/termlib) library so applications don't have to do it.
+
+m. Readline now checks for changes to locale settings (LC_ALL/LC_CTYPE/LANG)
+   each time it is called, and modifies the appropriate locale-specific display
+   and key binding variables when the locale changes.
+
+-------------------------------------------------------------------------------
 This document details the changes between this version, readline-8.1, and
 the previous version, readline-8.0.
 
@@ -376,7 +490,7 @@ jj. Fixed a bug that caused mode strings to be displayed incorrectly if the
 
 2.  New Features in Readline
 
-a.  The history truncation code now uses the same error recovery mechansim as
+a.  The history truncation code now uses the same error recovery mechanism as
     the history writing code, and restores the old version of the history file
     on error.  The error recovery mechanism handles symlinked history files.
 
@@ -707,7 +821,7 @@ d.  New bindable function: skip-csi-sequence.  Can be used as a default to
     to bind all keys.
 
 e.  New application-settable function: rl_filename_rewrite_hook.  Can be used
-    to rewite or modify filenames read from the file system before they are
+    to rewrite or modify filenames read from the file system before they are
     compared to the word to be completed.
 
 f.  New bindable variable: skip-completed-text, active when completing in the
@@ -769,7 +883,7 @@ l.  Fixed a bug in the code that buffers characters received very quickly in
     succession which caused characters to be dropped.
 
 m.  Fixed a bug that caused readline to reference uninitialized data structures
-    if it received a SIGWINCH before completing initialzation.
+    if it received a SIGWINCH before completing initialization.
 
 n.  Fixed a bug that caused the vi-mode `last command' to be set incorrectly
     and therefore unrepeatable.
@@ -1107,7 +1221,7 @@ w.  The history search functions now perform better bounds checking on the
     history list.
 
 x.  Change to history expansion functions to treat `^' as equivalent to word 
-    one, as the documention states.
+    one, as the documentation states.
 
 y.  Some changes to the display code to improve display and redisplay of
     multibyte characters.
@@ -1368,7 +1482,7 @@ f.  The incremental search code remembers the last search string and uses
 
 h.  New bindable variable `history-preserve-point'.  If set, the history
     code attempts to place the user at the same location on each history
-    line retrived with previous-history or next-history.
+    line retrieved with previous-history or next-history.
 
 -------------------------------------------------------------------------------
 This document details the changes between this version, readline-4.2,
diff --git a/readline/readline/INSTALL b/readline/readline/INSTALL
index 4f0d7b0c0d5d9d2dabac9f80c8400c5923372232..293ef7061b5cb68d8e1f3f1b0c7728a277b4bcb0 100644
--- a/readline/readline/INSTALL
+++ b/readline/readline/INSTALL
@@ -1,7 +1,7 @@
 Basic Installation
 ==================
 
-These are installation instructions for Readline-8.1.
+These are installation instructions for Readline-8.2.
 
 The simplest way to compile readline is:
 
@@ -55,7 +55,7 @@ The file `configure.in' is used to create `configure' by a
 program called `autoconf'.  You only need `configure.in' if you
 want to change it or regenerate `configure' using a newer version
 of `autoconf'.  The readline `configure.in' requires autoconf
-version 2.50 or newer. 
+version 2.69 or newer. 
 
 Compilers and Options
 =====================
@@ -164,18 +164,40 @@ operates.
 Optional Features
 =================
 
-The readline `configure' recognizes a single `--with-PACKAGE' option:
+The readline `configure' recognizes two `--with-PACKAGE' options:
 
 `--with-curses'
     This tells readline that it can find the termcap library functions
     (tgetent, et al.) in the curses library, rather than a separate
     termcap library.  Readline uses the termcap functions, but does not
-    link with the termcap or curses library itself, allowing applications
-    which link with readline the to choose an appropriate library.
-    This option tells readline to link the example programs with the
-    curses library rather than libtermcap.
+    usually link with the termcap or curses library itself, allowing
+    applications which link with readline the to choose an appropriate
+    library. This option tells readline to link the example programs with
+    the curses library rather than libtermcap.
+
+`--with-shared-termcap-library'
+    This tells the readline build process to link the shared version of
+    libreadline against a shared version of the curses or termcap library
+    (see the description of SHLIB_LIBS below under `Shared Libraries').
+    This relieves the application of having to link with curses or termcap
+    itself, but does not allow the application to choose which library to
+    use. This is only effective on systems that build shared libraries (see
+    below; the default for shared libraries is `yes').
+
+`configure' also recognizes several `--enable-FEATURE' options:
 
-`configure' also recognizes two `--enable-FEATURE' options:
+`--enable-bracketed-paste-default'
+    Enable bracketed paste by default, so the initial value of the
+    `enable-bracketed-paste' Readline variable is `on'. The default
+    is `yes'.
+
+`--enable-install-examples'
+    Install the readline example programs as part of `make install'.
+
+`--enable-multibyte'
+    Build with support for multibyte characters enabled on systems with the
+    necessary framework (locale definitions, C library functions, etc.). The
+    default is `yes'.
 
 `--enable-shared'
     Build the shared libraries by default on supported platforms.  The
@@ -184,11 +206,6 @@ The readline `configure' recognizes a single `--with-PACKAGE' option:
 `--enable-static'
     Build the static libraries by default.  The default is `yes'.
 
-`--enable-bracketed-paste-default'
-    Enable bracketed paste by default, so the initial value of the
-    `enable-bracketed-paste' Readline variable is `on'. The default
-    is `yes'.
- 
 Shared Libraries
 ================
 
@@ -199,7 +216,8 @@ shared versions of the readline and history libraries to be built
 on supported platforms.
 
 If `configure' is given the `--enable-shared' option, it will attempt
-to build the shared libraries by default on supported platforms.
+to build the shared libraries by default on supported platforms. This
+option is enabled by default.
 
 Configure calls the script support/shobj-conf to test whether or
 not shared library creation is supported and to generate the values
diff --git a/readline/readline/MANIFEST b/readline/readline/MANIFEST
index ad49d6686b06400813a0b26f3bb16a1c75e858a8..db689b3779ab79d588b56c0c140896f1b4ea655d 100644
--- a/readline/readline/MANIFEST
+++ b/readline/readline/MANIFEST
@@ -7,6 +7,7 @@ examples/autoconf	d
 examples/rlfe	d
 support		d
 shlib		d
+m4		d
 COPYING		f
 README		f
 MANIFEST	f
@@ -17,10 +18,12 @@ NEWS		f
 USAGE		f
 aclocal.m4	f
 config.h.in	f
-configure	f
+configure	f	755
 configure.ac	f
+m4/codeset.m4	f
 Makefile.in	f
 readline.pc.in	f
+history.pc.in	f
 ansi_stdlib.h	f
 chardefs.h	f
 colors.h	f
@@ -32,6 +35,7 @@ posixdir.h	f
 posixjmp.h	f
 posixselect.h	f
 posixstat.h	f
+posixtime.h	f
 readline.h	f
 rlconf.h	f
 rldefs.h	f
@@ -121,6 +125,8 @@ examples/rlevent.c	f
 examples/rlkeymaps.c	f
 examples/rltest.c	f
 examples/rl-callbacktest.c	f
+examples/rl-timeout.c	f
+examples/rl-test-timeout	f
 examples/rl.c		f
 examples/rlptytest.c	f
 examples/rlversion.c	f
@@ -135,7 +141,7 @@ examples/rlfe/ChangeLog		f
 examples/rlfe/Makefile.in	f
 examples/rlfe/README		f
 examples/rlfe/config.h.in	f
-examples/rlfe/configure		f
+examples/rlfe/configure		f	755
 examples/rlfe/configure.in	f
 examples/rlfe/extern.h		f
 examples/rlfe/os.h		f
diff --git a/readline/readline/Makefile.in b/readline/readline/Makefile.in
index c01da8d07a681e859f517005f99baaf2a17533e4..03934b3abc38a775d7e28ba4beeee408280e8154 100644
--- a/readline/readline/Makefile.in
+++ b/readline/readline/Makefile.in
@@ -149,7 +149,7 @@ DOCUMENTATION = $(DOCSOURCE) $(DOCOBJECT) $(DOCSUPPORT)
 
 CREATED_MAKEFILES = Makefile doc/Makefile examples/Makefile shlib/Makefile
 CREATED_CONFIGURE = config.status config.h config.cache config.log \
-		    stamp-config stamp-h readline.pc
+		    stamp-config stamp-h readline.pc history.pc
 CREATED_TAGS = TAGS tags
 
 INSTALLED_HEADERS = readline.h chardefs.h keymaps.h history.h tilde.h \
@@ -253,10 +253,11 @@ maybe-uninstall-headers: uninstall-headers
 
 install-pc: installdirs
 	-$(INSTALL_DATA) $(BUILD_DIR)/readline.pc $(DESTDIR)$(pkgconfigdir)/readline.pc
+	-$(INSTALL_DATA) $(BUILD_DIR)/history.pc $(DESTDIR)$(pkgconfigdir)/history.pc
 
 uninstall-pc:
 	-test -n "$(pkgconfigdir)" && cd $(DESTDIR)$(pkgconfigdir) && \
-		${RM} readline.pc
+		${RM} readline.pc history.pc
 
 maybe-uninstall-pc: uninstall-pc
 
@@ -334,6 +335,9 @@ distclean maintainer-clean: clean
 readline.pc:	config.status $(srcdir)/readline.pc.in
 	$(SHELL) config.status
 
+history.pc:	config.status $(srcdir)/history.pc.in
+	$(SHELL) config.status
+
 info dvi html pdf ps:
 	-( cd doc && $(MAKE) $(MFLAGS) $@ )
 
diff --git a/readline/readline/NEWS b/readline/readline/NEWS
index 56ab93aa1b98f5bfc988cbf798e14def60ae4586..1d88606a86efbb1528c0fd373063288dc1c467b4 100644
--- a/readline/readline/NEWS
+++ b/readline/readline/NEWS
@@ -1,3 +1,60 @@
+This is a terse description of the new features added to readline-8.2 since
+the release of readline-8.1.
+
+New Features in Readline
+
+a. There is now an HS_HISTORY_VERSION containing the version number of the
+   history library for applications to use.
+
+b. History expansion better understands multiple history expansions that may
+   contain strings that would ordinarily inhibit history expansion (e.g.,
+   `abc!$!$').
+
+c. There is a new framework for readline timeouts, including new public
+   functions to set timeouts and query how much time is remaining before a
+   timeout hits, and a hook function that can trigger when readline times
+   out. There is a new state value to indicate a timeout.
+
+d. Automatically bind termcap key sequences for page-up and page-down to
+   history-search-backward and history-search-forward, respectively.
+
+e. There is a new `fetch-history' bindable command that retrieves the history
+   entry corresponding to its numeric argument. Negative arguments count back
+   from the end of the history.
+
+f. `vi-undo' is now a bindable command.
+
+g. There is a new option: `enable-active-region'. This separates control of
+   the active region and bracketed-paste. It has the same default value as
+   bracketed-paste, and enabling bracketed paste enables the active region.
+   Users can now turn off the active region while leaving bracketed paste
+   enabled.
+
+h. rl_completer_word_break_characters is now `const char *' like
+   rl_basic_word_break_characters.
+
+i. Readline looks in $LS_COLORS for a custom filename extension
+   (*.readline-colored-completion-prefix) and uses that as the default color
+   for the common prefix displayed when `colored-completion-prefix' is set.
+
+j. Two new bindable string variables: active-region-start-color and
+   active-region-end-color. The first sets the color used to display the
+   active region; the second turns it off. If set, these are used in place
+   of terminal standout mode.
+
+k. New readline state (RL_STATE_EOF) and application-visible variable
+   (rl_eof_found) to allow applications to detect when readline reads EOF
+   before calling the deprep-terminal hook.
+
+l. There is a new configuration option: --with-shared-termcap-library, which
+   forces linking the shared readline library with the shared termcap (or
+   curses/ncurses/termlib) library so applications don't have to do it.
+
+m. Readline now checks for changes to locale settings (LC_ALL/LC_CTYPE/LANG)
+   each time it is called, and modifies the appropriate locale-specific display
+   and key binding variables when the locale changes.
+
+-------------------------------------------------------------------------------
 This is a terse description of the new features added to readline-8.1 since
 the release of readline-8.0.
 
@@ -89,7 +146,7 @@ the release of readline-6.3.
 
 New Features in Readline
 
-a.  The history truncation code now uses the same error recovery mechansim as
+a.  The history truncation code now uses the same error recovery mechanism as
     the history writing code, and restores the old version of the history file
     on error.  The error recovery mechanism handles symlinked history files.
 
@@ -260,7 +317,7 @@ d.  New bindable function: skip-csi-sequence.  Can be used as a default to
     to bind all keys.
 
 e.  New application-settable function: rl_filename_rewrite_hook.  Can be used
-    to rewite or modify filenames read from the file system before they are
+    to rewrite or modify filenames read from the file system before they are
     compared to the word to be completed.
 
 f.  New bindable variable: skip-completed-text, active when completing in the
diff --git a/readline/readline/README b/readline/readline/README
index de985752374ece41c458366e46bf9f9cada954e6..83cdb23a1150b015b3428b12fdae2169658d99b2 100644
--- a/readline/readline/README
+++ b/readline/readline/README
@@ -1,7 +1,7 @@
 Introduction
 ============
 
-This is the Gnu Readline library, version 8.1.
+This is the Gnu Readline library, version 8.2.
 
 The Readline library provides a set of functions for use by applications
 that allow users to edit command lines as they are typed in.  Both
@@ -10,7 +10,7 @@ additional functions to maintain a list of previously-entered command
 lines, to recall and perhaps reedit those lines, and perform csh-like
 history expansion on previous commands.
 
-The history facilites are also placed into a separate library, the
+The history facilities are also placed into a separate library, the
 History library, as part of the build process.  The History library
 may be used without Readline in applications which desire its
 capabilities.
diff --git a/readline/readline/aclocal.m4 b/readline/readline/aclocal.m4
index 6899e8202ae191a98c74db831d3baac4793b2b48..cc97bd4b8461528958dbd009c7c563aa97945527 100644
--- a/readline/readline/aclocal.m4
+++ b/readline/readline/aclocal.m4
@@ -3,55 +3,8 @@ dnl Bash specific tests
 dnl
 dnl Some derived from PDKSH 5.1.3 autoconf tests
 dnl
-
-AC_DEFUN(BASH_C_LONG_LONG,
-[AC_CACHE_CHECK(for long long, ac_cv_c_long_long,
-[if test "$GCC" = yes; then
-  ac_cv_c_long_long=yes
-else
-AC_TRY_RUN([
-#include <stdlib.h>
-int
-main()
-{
-long long foo = 0;
-exit(sizeof(long long) < sizeof(long));
-}
-], ac_cv_c_long_long=yes, ac_cv_c_long_long=no)
-fi])
-if test $ac_cv_c_long_long = yes; then
-  AC_DEFINE(HAVE_LONG_LONG, 1, [Define if the `long long' type works.])
-fi
-])
-
+dnl Copyright (C) 1987-2021 Free Software Foundation, Inc.
 dnl
-dnl This is very similar to AC_C_LONG_DOUBLE, with the fix for IRIX
-dnl (< changed to <=) added.
-dnl
-AC_DEFUN(BASH_C_LONG_DOUBLE,
-[AC_CACHE_CHECK(for long double, ac_cv_c_long_double,
-[if test "$GCC" = yes; then
-  ac_cv_c_long_double=yes
-else
-AC_TRY_RUN([
-#include <stdlib.h>
-int
-main()
-{
-  /* The Stardent Vistra knows sizeof(long double), but does not
-     support it. */
-  long double foo = 0.0;
-  /* On Ultrix 4.3 cc, long double is 4 and double is 8.  */
-  /* On IRIX 5.3, the compiler converts long double to double with a warning,
-     but compiles this successfully. */
-  exit(sizeof(long double) <= sizeof(double));
-}
-], ac_cv_c_long_double=yes, ac_cv_c_long_double=no)
-fi])
-if test $ac_cv_c_long_double = yes; then
-  AC_DEFINE(HAVE_LONG_DOUBLE, 1, [Define if the `long double' type works.])
-fi
-])
 
 dnl
 dnl Check for <inttypes.h>.  This is separated out so that it can be
@@ -72,13 +25,14 @@ dnl
 dnl BASH_CHECK_TYPE(TYPE, HEADERS, DEFAULT[, VALUE-IF-FOUND])
 AC_DEFUN(BASH_CHECK_TYPE,
 [
-AC_REQUIRE([AC_HEADER_STDC])dnl
 AC_REQUIRE([BASH_HEADER_INTTYPES])
 AC_MSG_CHECKING(for $1)
 AC_CACHE_VAL(bash_cv_type_$1,
 [AC_EGREP_CPP($1, [#include <sys/types.h>
-#if STDC_HEADERS
+#if HAVE_STDLIB_H
 #include <stdlib.h>
+#endif
+#if HAVE_STDDEF_H
 #include <stddef.h>
 #endif
 #if HAVE_INTTYPES_H
@@ -106,32 +60,14 @@ dnl AC_CHECK_DECL
 dnl
 AC_DEFUN(BASH_CHECK_DECL,
 [
-AC_REQUIRE([AC_HEADER_STDC])
 AC_REQUIRE([BASH_HEADER_INTTYPES])
-AC_CACHE_CHECK([for declaration of $1], bash_cv_decl_$1,
-[AC_TRY_LINK(
-[
-#if STDC_HEADERS
-#  include <stdlib.h>
-#endif
-#if HAVE_INTTYPES_H
-#  include <inttypes.h>
-#endif
-],
-[return !$1;],
-bash_cv_decl_$1=yes, bash_cv_decl_$1=no)])
-bash_tr_func=HAVE_DECL_`echo $1 | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
-if test $bash_cv_decl_$1 = yes; then
-  AC_DEFINE_UNQUOTED($bash_tr_func, 1)
-else
-  AC_DEFINE_UNQUOTED($bash_tr_func, 0)
-fi
+AC_CHECK_DECLS([$1])
 ])
 
 AC_DEFUN(BASH_DECL_PRINTF,
 [AC_MSG_CHECKING(for declaration of printf in <stdio.h>)
 AC_CACHE_VAL(bash_cv_printf_declared,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdio.h>
 #ifdef __STDC__
 typedef int (*_bashfunc)(const char *, ...);
@@ -146,7 +82,7 @@ _bashfunc pf;
 pf = (_bashfunc) printf;
 exit(pf == 0);
 }
-], bash_cv_printf_declared=yes, bash_cv_printf_declared=no,
+]])], [bash_cv_printf_declared=yes], [bash_cv_printf_declared=no],
    [AC_MSG_WARN(cannot check printf declaration if cross compiling -- defaulting to yes)
     bash_cv_printf_declared=yes]
 )])
@@ -173,13 +109,13 @@ dnl
 AC_DEFUN(BASH_DECL_UNDER_SYS_SIGLIST,
 [AC_MSG_CHECKING([for _sys_siglist in signal.h or unistd.h])
 AC_CACHE_VAL(bash_cv_decl_under_sys_siglist,
-[AC_TRY_COMPILE([
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #include <sys/types.h>
 #include <signal.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
-#endif], [ char *msg = _sys_siglist[2]; ],
-  bash_cv_decl_under_sys_siglist=yes, bash_cv_decl_under_sys_siglist=no,
+#endif]], [[ char *msg = _sys_siglist[2]; ]])],
+  [bash_cv_decl_under_sys_siglist=yes], [bash_cv_decl_under_sys_siglist=no],
   [AC_MSG_WARN(cannot check for _sys_siglist[] if cross compiling -- defaulting to no)])])dnl
 AC_MSG_RESULT($bash_cv_decl_under_sys_siglist)
 if test $bash_cv_decl_under_sys_siglist = yes; then
@@ -191,7 +127,7 @@ AC_DEFUN(BASH_UNDER_SYS_SIGLIST,
 [AC_REQUIRE([BASH_DECL_UNDER_SYS_SIGLIST])
 AC_MSG_CHECKING([for _sys_siglist in system C library])
 AC_CACHE_VAL(bash_cv_under_sys_siglist,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <sys/types.h>
 #include <signal.h>
 #ifdef HAVE_UNISTD_H
@@ -206,21 +142,34 @@ main()
 {
 char *msg = (char *)_sys_siglist[2];
 exit(msg == 0);
-}],
-	bash_cv_under_sys_siglist=yes, bash_cv_under_sys_siglist=no,
+}
+]])],
+	[bash_cv_under_sys_siglist=yes], [bash_cv_under_sys_siglist=no],
 	[AC_MSG_WARN(cannot check for _sys_siglist[] if cross compiling -- defaulting to no)
-	 bash_cv_under_sys_siglist=no])])
+	 bash_cv_under_sys_siglist=no]
+)])
 AC_MSG_RESULT($bash_cv_under_sys_siglist)
 if test $bash_cv_under_sys_siglist = yes; then
 AC_DEFINE(HAVE_UNDER_SYS_SIGLIST)
 fi
 ])
 
+dnl this defines HAVE_DECL_SYS_SIGLIST
+AC_DEFUN([BASH_DECL_SYS_SIGLIST],
+[AC_CHECK_DECLS([sys_siglist],,,
+[#include <signal.h>
+/* NetBSD declares sys_siglist in unistd.h.  */
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+])
+])
+
 AC_DEFUN(BASH_SYS_SIGLIST,
-[AC_REQUIRE([AC_DECL_SYS_SIGLIST])
+[AC_REQUIRE([BASH_DECL_SYS_SIGLIST])
 AC_MSG_CHECKING([for sys_siglist in system C library])
 AC_CACHE_VAL(bash_cv_sys_siglist,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <sys/types.h>
 #include <signal.h>
 #ifdef HAVE_UNISTD_H
@@ -235,10 +184,11 @@ main()
 {
 char *msg = sys_siglist[2];
 exit(msg == 0);
-}],
-	bash_cv_sys_siglist=yes, bash_cv_sys_siglist=no,
+}
+]])], [bash_cv_sys_siglist=yes], [bash_cv_sys_siglist=no],
 	[AC_MSG_WARN(cannot check for sys_siglist if cross compiling -- defaulting to no)
-	 bash_cv_sys_siglist=no])])
+	 bash_cv_sys_siglist=no]
+)])
 AC_MSG_RESULT($bash_cv_sys_siglist)
 if test $bash_cv_sys_siglist = yes; then
 AC_DEFINE(HAVE_SYS_SIGLIST)
@@ -263,11 +213,15 @@ dnl Check for sys_errlist[] and sys_nerr, check for declaration
 AC_DEFUN(BASH_SYS_ERRLIST,
 [AC_MSG_CHECKING([for sys_errlist and sys_nerr])
 AC_CACHE_VAL(bash_cv_sys_errlist,
-[AC_TRY_LINK([#include <errno.h>],
-[extern char *sys_errlist[];
- extern int sys_nerr;
- char *msg = sys_errlist[sys_nerr - 1];],
-    bash_cv_sys_errlist=yes, bash_cv_sys_errlist=no)])dnl
+[AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <errno.h>
+]],[[
+extern char *sys_errlist[];
+extern int sys_nerr;
+char *msg = sys_errlist[sys_nerr - 1];
+]] )],
+[bash_cv_sys_errlist=yes], [bash_cv_sys_errlist=no]
+)])
 AC_MSG_RESULT($bash_cv_sys_errlist)
 if test $bash_cv_sys_errlist = yes; then
 AC_DEFINE(HAVE_SYS_ERRLIST)
@@ -280,7 +234,7 @@ dnl
 AC_DEFUN(BASH_FUNC_DUP2_CLOEXEC_CHECK,
 [AC_MSG_CHECKING(if dup2 fails to clear the close-on-exec flag)
 AC_CACHE_VAL(bash_cv_dup2_broken,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <sys/types.h>
 #include <fcntl.h>
 #include <stdlib.h>
@@ -298,10 +252,10 @@ main()
   /* fl will be 1 if dup2 did not reset the close-on-exec flag. */
   exit(fl != 1);
 }
-], bash_cv_dup2_broken=yes, bash_cv_dup2_broken=no,
+]])], [bash_cv_dup2_broken=yes], [bash_cv_dup2_broken=no],
     [AC_MSG_WARN(cannot check dup2 if cross compiling -- defaulting to no)
-     bash_cv_dup2_broken=no])
-])
+     bash_cv_dup2_broken=no]
+)])
 AC_MSG_RESULT($bash_cv_dup2_broken)
 if test $bash_cv_dup2_broken = yes; then
 AC_DEFINE(DUP2_BROKEN)
@@ -311,11 +265,12 @@ fi
 AC_DEFUN(BASH_FUNC_STRSIGNAL,
 [AC_MSG_CHECKING([for the existence of strsignal])
 AC_CACHE_VAL(bash_cv_have_strsignal,
-[AC_TRY_LINK([#include <sys/types.h>
+[AC_LINK_IFELSE(
+	[AC_LANG_PROGRAM([[#include <sys/types.h>
 #include <signal.h>
-#include <string.h>],
-[char *s = (char *)strsignal(2);],
- bash_cv_have_strsignal=yes, bash_cv_have_strsignal=no)])
+#include <string.h>]],
+[[char *s = (char *)strsignal(2);]])],
+ [bash_cv_have_strsignal=yes], [bash_cv_have_strsignal=no])])
 AC_MSG_RESULT($bash_cv_have_strsignal)
 if test $bash_cv_have_strsignal = yes; then
 AC_DEFINE(HAVE_STRSIGNAL)
@@ -327,7 +282,7 @@ AC_DEFUN(BASH_FUNC_OPENDIR_CHECK,
 [AC_REQUIRE([AC_HEADER_DIRENT])dnl
 AC_MSG_CHECKING(if opendir() opens non-directories)
 AC_CACHE_VAL(bash_cv_opendir_not_robust,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdio.h>
 #include <sys/types.h>
 #include <fcntl.h>
@@ -370,7 +325,8 @@ dir = opendir("bash-aclocal/not_a_directory");
 unlink("bash-aclocal/not_a_directory");
 rmdir("bash-aclocal");
 exit (dir == 0);
-}], bash_cv_opendir_not_robust=yes,bash_cv_opendir_not_robust=no,
+}
+]])], [bash_cv_opendir_not_robust=yes], [bash_cv_opendir_not_robust=no],
     [AC_MSG_WARN(cannot check opendir if cross compiling -- defaulting to no)
      bash_cv_opendir_not_robust=no]
 )])
@@ -380,26 +336,6 @@ AC_DEFINE(OPENDIR_NOT_ROBUST)
 fi
 ])
 
-dnl
-AC_DEFUN(BASH_TYPE_SIGHANDLER,
-[AC_MSG_CHECKING([whether signal handlers are of type void])
-AC_CACHE_VAL(bash_cv_void_sighandler,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <signal.h>
-#ifdef signal
-#undef signal
-#endif
-#ifdef __cplusplus
-extern "C"
-#endif
-void (*signal ()) ();],
-[int i;], bash_cv_void_sighandler=yes, bash_cv_void_sighandler=no)])dnl
-AC_MSG_RESULT($bash_cv_void_sighandler)
-if test $bash_cv_void_sighandler = yes; then
-AC_DEFINE(VOID_SIGHANDLER)
-fi
-])
-
 dnl
 dnl A signed 16-bit integer quantity
 dnl
@@ -487,82 +423,98 @@ else
 fi
 ])
 
-AC_DEFUN(BASH_TYPE_LONG_LONG,
-[
-AC_CACHE_CHECK([for long long], bash_cv_type_long_long,
-[AC_TRY_LINK([
-long long ll = 1; int i = 63;],
-[
-long long llm = (long long) -1;
-return ll << i | ll >> i | llm / ll | llm % ll;
-], bash_cv_type_long_long='long long', bash_cv_type_long_long='long')])
-if test "$bash_cv_type_long_long" = 'long long'; then
-  AC_DEFINE(HAVE_LONG_LONG, 1)
-fi
+AC_DEFUN(BASH_SIZEOF_RLIMIT,
+[AC_MSG_CHECKING(for size of struct rlimit fields)
+AC_CACHE_VAL(bash_cv_sizeof_rlim_cur,
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <stdlib.h>
+#include <sys/resource.h>
+main()
+{
+struct rlimit r;
+exit(sizeof (r.rlim_cur));
+}
+]])], [bash_cv_sizeof_rlim_cur=$?], [bash_cv_sizeof_rlim_cur=$?],
+	[AC_MSG_WARN(cannot check size of rlimit fields if cross compiling -- defaulting to long)
+	 bash_cv_sizeof_rlim_cur=$ac_cv_sizeof_long]
+)])
+AC_MSG_RESULT($bash_cv_sizeof_rlim_cur)
 ])
 
-AC_DEFUN(BASH_TYPE_UNSIGNED_LONG_LONG,
-[
-AC_CACHE_CHECK([for unsigned long long], bash_cv_type_unsigned_long_long,
-[AC_TRY_LINK([
-unsigned long long ull = 1; int i = 63;],
-[
-unsigned long long ullmax = (unsigned long long) -1;
-return ull << i | ull >> i | ullmax / ull | ullmax % ull;
-], bash_cv_type_unsigned_long_long='unsigned long long',
-   bash_cv_type_unsigned_long_long='unsigned long')])
-if test "$bash_cv_type_unsigned_long_long" = 'unsigned long long'; then
-  AC_DEFINE(HAVE_UNSIGNED_LONG_LONG, 1)
-fi
+AC_DEFUN(BASH_SIZEOF_QUAD_T,
+[AC_MSG_CHECKING(for size of quad_t)
+AC_CACHE_VAL(bash_cv_sizeof_quad_t,
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <sys/types.h>
+#include <stdlib.h>
+#if HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
+main()
+{
+#if HAVE_QUAD_T
+quad_t x;
+exit(sizeof (x));
+#else
+exit (0);
+#endif
+}
+]])], [bash_cv_sizeof_quad_t=$?], [bash_cv_sizeof_quad_t=$?],
+	[AC_MSG_WARN(cannot check size of quad_t if cross compiling -- defaulting to 0)
+	 bash_cv_sizeof_quad_t=0]
+)])
+AC_MSG_RESULT($bash_cv_sizeof_quad_t)
 ])
 
 dnl
-dnl Type of struct rlimit fields: some systems (OSF/1, NetBSD, RISC/os 5.0)
-dnl have a rlim_t, others (4.4BSD based systems) use quad_t, others use
-dnl long and still others use int (HP-UX 9.01, SunOS 4.1.3).  To simplify
-dnl matters, this just checks for rlim_t, quad_t, or long.
+dnl Type of struct rlimit fields: updated to check POSIX rlim_t and
+dnl if it doesn't exist determine the best guess based on sizeof(r.rlim_cur)
 dnl
 AC_DEFUN(BASH_TYPE_RLIMIT,
-[AC_MSG_CHECKING(for size and type of struct rlimit fields)
+[AC_MSG_CHECKING(for type of struct rlimit fields)
 AC_CACHE_VAL(bash_cv_type_rlimit,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/resource.h>],
-[rlim_t xxx;], bash_cv_type_rlimit=rlim_t,[
-AC_TRY_RUN([
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #include <sys/types.h>
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <stdlib.h>
-int
-main()
-{
-#ifdef HAVE_QUAD_T
-  struct rlimit rl;
-  if (sizeof(rl.rlim_cur) == sizeof(quad_t))
-    exit(0);
-#endif
-  exit(1);
-}], bash_cv_type_rlimit=quad_t, bash_cv_type_rlimit=long,
-        [AC_MSG_WARN(cannot check quad_t if cross compiling -- defaulting to long)
-         bash_cv_type_rlimit=long])])
-])
-AC_MSG_RESULT($bash_cv_type_rlimit)
-if test $bash_cv_type_rlimit = quad_t; then
-AC_DEFINE(RLIMTYPE, quad_t)
-elif test $bash_cv_type_rlimit = rlim_t; then
-AC_DEFINE(RLIMTYPE, rlim_t)
+#include <sys/resource.h>]],
+[[rlim_t xxx;]]
+)],
+	[bash_cv_type_rlimit=rlim_t], [
+BASH_SIZEOF_RLIMIT
+BASH_SIZEOF_QUAD_T
+if test $bash_cv_sizeof_rlim_cur = $ac_cv_sizeof_long; then
+  bash_cv_type_rlimit='unsigned long'
+elif test $bash_cv_sizeof_rlim_cur = $ac_cv_sizeof_long_long; then
+  bash_cv_type_rlimit='unsigned long long'
+elif test $bash_cv_sizeof_rlim_cur = $ac_cv_sizeof_int; then
+  bash_cv_type_rlimit='unsigned int'
+elif test $bash_cv_sizeof_rlim_cur = $bash_cv_sizeof_quad_t; then
+  bash_cv_type_rlimit='quad_t'
+else
+  bash_cv_type_rlimit='unsigned long'
 fi
+]
+)])
+AC_MSG_RESULT($bash_cv_type_rlimit)
+AC_DEFINE_UNQUOTED([RLIMTYPE], [$bash_cv_type_rlimit])
 ])
 
 AC_DEFUN(BASH_TYPE_SIG_ATOMIC_T,
 [AC_CACHE_CHECK([for sig_atomic_t in signal.h], ac_cv_have_sig_atomic_t,
-[AC_TRY_LINK([
-#include <signal.h>
-],[ sig_atomic_t x; ],
-ac_cv_have_sig_atomic_t=yes, ac_cv_have_sig_atomic_t=no)])
+[AC_LINK_IFELSE(
+	[AC_LANG_PROGRAM(
+		[[ #include <signal.h> ]],
+		[[ sig_atomic_t x; ]])],
+	[ac_cv_have_sig_atomic_t=yes],[ac_cv_have_sig_atomic_t=no])])
 if test "$ac_cv_have_sig_atomic_t" = "no"
 then
-    AC_CHECK_TYPE(sig_atomic_t,int)
+    BASH_CHECK_TYPE(sig_atomic_t, [#include <signal.h>], int)
 fi
 ])
 
@@ -570,11 +522,13 @@ AC_DEFUN(BASH_FUNC_LSTAT,
 [dnl Cannot use AC_CHECK_FUNCS(lstat) because Linux defines lstat() as an
 dnl inline function in <sys/stat.h>.
 AC_CACHE_CHECK([for lstat], bash_cv_func_lstat,
-[AC_TRY_LINK([
-#include <sys/types.h>
-#include <sys/stat.h>
-],[ lstat(".",(struct stat *)0); ],
-bash_cv_func_lstat=yes, bash_cv_func_lstat=no)])
+[AC_LINK_IFELSE(
+	[AC_LANG_PROGRAM([[
+		#include <sys/types.h>
+		#include <sys/stat.h>
+		]],
+		[[ lstat(".",(struct stat *)0); ]])],
+	[bash_cv_func_lstat=yes],[bash_cv_func_lstat=no])])
 if test $bash_cv_func_lstat = yes; then
   AC_DEFINE(HAVE_LSTAT)
 fi
@@ -583,12 +537,12 @@ fi
 AC_DEFUN(BASH_FUNC_INET_ATON,
 [
 AC_CACHE_CHECK([for inet_aton], bash_cv_func_inet_aton,
-[AC_TRY_LINK([
+[AC_LINK_IFELSE([AC_LANG_PROGRAM([[
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
-struct in_addr ap;], [ inet_aton("127.0.0.1", &ap); ],
-bash_cv_func_inet_aton=yes, bash_cv_func_inet_aton=no)])
+struct in_addr ap;]], [[ inet_aton("127.0.0.1", &ap); ]])],
+[bash_cv_func_inet_aton=yes], [bash_cv_func_inet_aton=no])])
 if test $bash_cv_func_inet_aton = yes; then
   AC_DEFINE(HAVE_INET_ATON)
 else
@@ -599,7 +553,7 @@ fi
 AC_DEFUN(BASH_FUNC_GETENV,
 [AC_MSG_CHECKING(to see if getenv can be redefined)
 AC_CACHE_VAL(bash_cv_getenv_redef,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #ifdef HAVE_UNISTD_H
 #  include <unistd.h>
 #endif
@@ -632,7 +586,7 @@ exit(1);
 s = getenv("ABCDE");
 exit(s == 0);	/* force optimizer to leave getenv in */
 }
-], bash_cv_getenv_redef=yes, bash_cv_getenv_redef=no,
+]])], [bash_cv_getenv_redef=yes], [bash_cv_getenv_redef=no],
    [AC_MSG_WARN(cannot check getenv redefinition if cross compiling -- defaulting to yes)
     bash_cv_getenv_redef=yes]
 )])
@@ -645,12 +599,13 @@ fi
 # We should check for putenv before calling this
 AC_DEFUN(BASH_FUNC_STD_PUTENV,
 [
-AC_REQUIRE([AC_HEADER_STDC])
 AC_REQUIRE([AC_C_PROTOTYPES])
 AC_CACHE_CHECK([for standard-conformant putenv declaration], bash_cv_std_putenv,
-[AC_TRY_LINK([
-#if STDC_HEADERS
+[AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#if HAVE_STDLIB_H
 #include <stdlib.h>
+#endif
+#if HAVE_STDDEF_H
 #include <stddef.h>
 #endif
 #ifndef __STDC__
@@ -663,9 +618,8 @@ extern int putenv (char *);
 #else
 extern int putenv ();
 #endif
-],
-[return (putenv == 0);],
-bash_cv_std_putenv=yes, bash_cv_std_putenv=no
+]], [[return (putenv == 0);]] )],
+[bash_cv_std_putenv=yes], [bash_cv_std_putenv=no]
 )])
 if test $bash_cv_std_putenv = yes; then
 AC_DEFINE(HAVE_STD_PUTENV)
@@ -675,12 +629,13 @@ fi
 # We should check for unsetenv before calling this
 AC_DEFUN(BASH_FUNC_STD_UNSETENV,
 [
-AC_REQUIRE([AC_HEADER_STDC])
 AC_REQUIRE([AC_C_PROTOTYPES])
 AC_CACHE_CHECK([for standard-conformant unsetenv declaration], bash_cv_std_unsetenv,
-[AC_TRY_LINK([
-#if STDC_HEADERS
+[AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#if HAVE_STDLIB_H
 #include <stdlib.h>
+#endif
+#if HAVE_STDDEF_H
 #include <stddef.h>
 #endif
 #ifndef __STDC__
@@ -693,9 +648,8 @@ extern int unsetenv (const char *);
 #else
 extern int unsetenv ();
 #endif
-],
-[return (unsetenv == 0);],
-bash_cv_std_unsetenv=yes, bash_cv_std_unsetenv=no
+]], [[return (unsetenv == 0);]] )],
+[bash_cv_std_unsetenv=yes], [bash_cv_std_unsetenv=no]
 )])
 if test $bash_cv_std_unsetenv = yes; then
 AC_DEFINE(HAVE_STD_UNSETENV)
@@ -705,7 +659,7 @@ fi
 AC_DEFUN(BASH_FUNC_ULIMIT_MAXFDS,
 [AC_MSG_CHECKING(whether ulimit can substitute for getdtablesize)
 AC_CACHE_VAL(bash_cv_ulimit_maxfds,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdlib.h>
 #ifdef HAVE_ULIMIT_H
 #include <ulimit.h>
@@ -716,7 +670,7 @@ main()
 long maxfds = ulimit(4, 0L);
 exit (maxfds == -1L);
 }
-], bash_cv_ulimit_maxfds=yes, bash_cv_ulimit_maxfds=no,
+]])], [bash_cv_ulimit_maxfds=yes], [bash_cv_ulimit_maxfds=no],
    [AC_MSG_WARN(cannot check ulimit if cross compiling -- defaulting to no)
     bash_cv_ulimit_maxfds=no]
 )])
@@ -729,7 +683,7 @@ fi
 AC_DEFUN(BASH_FUNC_GETCWD,
 [AC_MSG_CHECKING([if getcwd() will dynamically allocate memory with 0 size])
 AC_CACHE_VAL(bash_cv_getcwd_malloc,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdio.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
@@ -743,7 +697,7 @@ main()
 	xpwd = getcwd(0, 0);
 	exit (xpwd == 0);
 }
-], bash_cv_getcwd_malloc=yes, bash_cv_getcwd_malloc=no,
+]])], [bash_cv_getcwd_malloc=yes], [bash_cv_getcwd_malloc=no],
    [AC_MSG_WARN(cannot check whether getcwd allocates memory when cross-compiling -- defaulting to no)
     bash_cv_getcwd_malloc=no]
 )])
@@ -756,7 +710,7 @@ fi
 
 dnl
 dnl This needs BASH_CHECK_SOCKLIB, but since that's not called on every
-dnl system, we can't use AC_PREREQ
+dnl system, we can't use AC_PREREQ. Only called if we need the socket library
 dnl
 AC_DEFUN(BASH_FUNC_GETHOSTBYNAME,
 [if test "X$bash_cv_have_gethostbyname" = "X"; then
@@ -766,11 +720,14 @@ AC_MSG_CHECKING(for gethostbyname in socket library)
 _bash_needmsg=
 fi
 AC_CACHE_VAL(bash_cv_have_gethostbyname,
-[AC_TRY_LINK([#include <netdb.h>],
-[ struct hostent *hp;
-  hp = gethostbyname("localhost");
-], bash_cv_have_gethostbyname=yes, bash_cv_have_gethostbyname=no)]
-)
+[AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <netdb.h>
+]], [[
+struct hostent *hp;
+hp = gethostbyname("localhost");
+]] )],
+[bash_cv_have_gethostbyname=yes], [bash_cv_have_gethostbyname=no]
+)])
 if test "X$_bash_needmsg" = Xyes; then
     AC_MSG_CHECKING(for gethostbyname in socket library)
 fi
@@ -783,7 +740,7 @@ fi
 AC_DEFUN(BASH_FUNC_FNMATCH_EXTMATCH,
 [AC_MSG_CHECKING(if fnmatch does extended pattern matching with FNM_EXTMATCH)
 AC_CACHE_VAL(bash_cv_fnm_extmatch,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <fnmatch.h>
 
 int
@@ -795,10 +752,10 @@ main()
   return (1);
 #endif
 }
-], bash_cv_fnm_extmatch=yes, bash_cv_fnm_extmatch=no,
+]])], [bash_cv_fnm_extmatch=yes], [bash_cv_fnm_extmatch=no],
     [AC_MSG_WARN(cannot check FNM_EXTMATCH if cross compiling -- defaulting to no)
-     bash_cv_fnm_extmatch=no])
-])
+     bash_cv_fnm_extmatch=no]
+)])
 AC_MSG_RESULT($bash_cv_fnm_extmatch)
 if test $bash_cv_fnm_extmatch = yes; then
 AC_DEFINE(HAVE_LIBC_FNM_EXTMATCH)
@@ -809,7 +766,7 @@ AC_DEFUN(BASH_FUNC_POSIX_SETJMP,
 [AC_REQUIRE([BASH_SYS_SIGNAL_VINTAGE])
 AC_MSG_CHECKING(for presence of POSIX-style sigsetjmp/siglongjmp)
 AC_CACHE_VAL(bash_cv_func_sigsetjmp,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -826,21 +783,30 @@ exit (1);
 #else
 
 int code;
-sigset_t set, oset;
+sigset_t set, oset, nset;
 sigjmp_buf xx;
 
 /* get the mask */
 sigemptyset(&set);
 sigemptyset(&oset);
-sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &set);
+
 sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
+/* paranoia -- make sure SIGINT is not blocked */
+sigdelset (&oset, SIGINT);
+sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
 
 /* save it */
 code = sigsetjmp(xx, 1);
 if (code)
-  exit(0);	/* could get sigmask and compare to oset here. */
+{
+  sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &nset);
+  /* could compare nset to oset here, but we just look for SIGINT */
+  if (sigismember (&nset, SIGINT))
+    exit(1);
+  exit(0);
+}
 
-/* change it */
+/* change it so that SIGINT is blocked */
 sigaddset(&set, SIGINT);
 sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
 
@@ -848,9 +814,14 @@ sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
 siglongjmp(xx, 10);
 exit(1);
 #endif
-}], bash_cv_func_sigsetjmp=present, bash_cv_func_sigsetjmp=missing,
-    [AC_MSG_WARN(cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to missing)
-     bash_cv_func_sigsetjmp=missing]
+}
+]])], [bash_cv_func_sigsetjmp=present], [bash_cv_func_sigsetjmp=missing],
+    [AC_MSG_WARN(cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to $bash_cv_posix_signals)
+     if test "$bash_cv_posix_signals" = "yes" ; then
+	bash_cv_func_sigsetjmp=present
+     else
+	bash_cv_func_sigsetjmp=missing
+     fi]
 )])
 AC_MSG_RESULT($bash_cv_func_sigsetjmp)
 if test $bash_cv_func_sigsetjmp = present; then
@@ -859,10 +830,9 @@ fi
 ])
 
 AC_DEFUN(BASH_FUNC_STRCOLL,
-[
-AC_MSG_CHECKING(whether or not strcoll and strcmp differ)
+[AC_MSG_CHECKING(whether or not strcoll and strcmp differ)
 AC_CACHE_VAL(bash_cv_func_strcoll_broken,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdio.h>
 #if defined (HAVE_LOCALE_H)
 #include <locale.h>
@@ -900,7 +870,7 @@ char    *v[];
 	   in the default locale. */
 	exit (r1 > 0 && r2 > 0);
 }
-], bash_cv_func_strcoll_broken=yes, bash_cv_func_strcoll_broken=no,
+]])], [bash_cv_func_strcoll_broken=yes], [bash_cv_func_strcoll_broken=no],
    [AC_MSG_WARN(cannot check strcoll if cross compiling -- defaulting to no)
     bash_cv_func_strcoll_broken=no]
 )])
@@ -913,7 +883,7 @@ fi
 AC_DEFUN(BASH_FUNC_PRINTF_A_FORMAT,
 [AC_MSG_CHECKING([for printf floating point output in hex notation])
 AC_CACHE_VAL(bash_cv_printf_a_format,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
@@ -927,7 +897,7 @@ main()
 	sprintf(abuf, "%A", y);
 	exit(strchr(abuf, 'P') == (char *)0);
 }
-], bash_cv_printf_a_format=yes, bash_cv_printf_a_format=no,
+]])], [bash_cv_printf_a_format=yes], [bash_cv_printf_a_format=no],
    [AC_MSG_WARN(cannot check printf if cross compiling -- defaulting to no)
     bash_cv_printf_a_format=no]
 )])
@@ -964,12 +934,10 @@ AC_DEFUN(BASH_STRUCT_ST_BLOCKS,
 [
 AC_MSG_CHECKING([for struct stat.st_blocks])
 AC_CACHE_VAL(bash_cv_struct_stat_st_blocks,
-[AC_TRY_COMPILE(
-[
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #include <sys/types.h>
 #include <sys/stat.h>
-],
-[
+]], [[
 int
 main()
 {
@@ -977,7 +945,7 @@ static struct stat a;
 if (a.st_blocks) return 0;
 return 0;
 }
-], bash_cv_struct_stat_st_blocks=yes, bash_cv_struct_stat_st_blocks=no)
+]])], [bash_cv_struct_stat_st_blocks=yes], [bash_cv_struct_stat_st_blocks=no])
 ])
 AC_MSG_RESULT($bash_cv_struct_stat_st_blocks)
 if test "$bash_cv_struct_stat_st_blocks" = "yes"; then
@@ -1022,7 +990,8 @@ elif test $bash_cv_termcap_lib = libc; then
 TERMCAP_LIB=
 TERMCAP_DEP=
 else
-TERMCAP_LIB=-lcurses
+# we assume ncurses is installed somewhere the linker can find it
+TERMCAP_LIB=-lncurses
 TERMCAP_DEP=
 fi
 ])
@@ -1077,11 +1046,12 @@ if test $bash_cv_have_socklib = yes; then
 fi
 ])
 
-AC_DEFUN(BASH_STRUCT_DIRENT_D_INO,
-[AC_REQUIRE([AC_HEADER_DIRENT])
-AC_MSG_CHECKING(for struct dirent.d_ino)
-AC_CACHE_VAL(bash_cv_dirent_has_dino,
-[AC_TRY_COMPILE([
+dnl like _AC_STRUCT_DIRENT(MEMBER) but public
+AC_DEFUN(BASH_STRUCT_DIRENT,
+[
+AC_REQUIRE([AC_HEADER_DIRENT])
+AC_CHECK_MEMBERS(struct dirent.$1, bash_cv_dirent_has_$1=yes, bash_cv_dirent_has_$1=no,
+[[
 #include <stdio.h>
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
@@ -1101,11 +1071,15 @@ AC_CACHE_VAL(bash_cv_dirent_has_dino,
 #  include <ndir.h>
 # endif
 #endif /* HAVE_DIRENT_H */
-],[
-struct dirent d; int z; z = d.d_ino;
-], bash_cv_dirent_has_dino=yes, bash_cv_dirent_has_dino=no)])
-AC_MSG_RESULT($bash_cv_dirent_has_dino)
-if test $bash_cv_dirent_has_dino = yes; then
+]])
+])
+
+AC_DEFUN(BASH_STRUCT_DIRENT_D_INO,
+[AC_REQUIRE([AC_HEADER_DIRENT])
+AC_MSG_CHECKING(for struct dirent.d_ino)
+AC_CACHE_VAL(bash_cv_dirent_has_d_ino, [BASH_STRUCT_DIRENT([d_ino])])
+AC_MSG_RESULT($bash_cv_dirent_has_d_ino)
+if test $bash_cv_dirent_has_d_ino = yes; then
 AC_DEFINE(HAVE_STRUCT_DIRENT_D_INO)
 fi
 ])
@@ -1113,30 +1087,7 @@ fi
 AC_DEFUN(BASH_STRUCT_DIRENT_D_FILENO,
 [AC_REQUIRE([AC_HEADER_DIRENT])
 AC_MSG_CHECKING(for struct dirent.d_fileno)
-AC_CACHE_VAL(bash_cv_dirent_has_d_fileno,
-[AC_TRY_COMPILE([
-#include <stdio.h>
-#include <sys/types.h>
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-#if defined(HAVE_DIRENT_H)
-# include <dirent.h>
-#else
-# define dirent direct
-# ifdef HAVE_SYS_NDIR_H
-#  include <sys/ndir.h>
-# endif /* SYSNDIR */
-# ifdef HAVE_SYS_DIR_H
-#  include <sys/dir.h>
-# endif /* SYSDIR */
-# ifdef HAVE_NDIR_H
-#  include <ndir.h>
-# endif
-#endif /* HAVE_DIRENT_H */
-],[
-struct dirent d; int z; z = d.d_fileno;
-], bash_cv_dirent_has_d_fileno=yes, bash_cv_dirent_has_d_fileno=no)])
+AC_CACHE_VAL(bash_cv_dirent_has_d_fileno, [BASH_STRUCT_DIRENT([d_fileno])])
 AC_MSG_RESULT($bash_cv_dirent_has_d_fileno)
 if test $bash_cv_dirent_has_d_fileno = yes; then
 AC_DEFINE(HAVE_STRUCT_DIRENT_D_FILENO)
@@ -1146,30 +1097,7 @@ fi
 AC_DEFUN(BASH_STRUCT_DIRENT_D_NAMLEN,
 [AC_REQUIRE([AC_HEADER_DIRENT])
 AC_MSG_CHECKING(for struct dirent.d_namlen)
-AC_CACHE_VAL(bash_cv_dirent_has_d_namlen,
-[AC_TRY_COMPILE([
-#include <stdio.h>
-#include <sys/types.h>
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-#if defined(HAVE_DIRENT_H)
-# include <dirent.h>
-#else
-# define dirent direct
-# ifdef HAVE_SYS_NDIR_H
-#  include <sys/ndir.h>
-# endif /* SYSNDIR */
-# ifdef HAVE_SYS_DIR_H
-#  include <sys/dir.h>
-# endif /* SYSDIR */
-# ifdef HAVE_NDIR_H
-#  include <ndir.h>
-# endif
-#endif /* HAVE_DIRENT_H */
-],[
-struct dirent d; int z; z = d.d_namlen;
-], bash_cv_dirent_has_d_namlen=yes, bash_cv_dirent_has_d_namlen=no)])
+AC_CACHE_VAL(bash_cv_dirent_has_d_namlen, [BASH_STRUCT_DIRENT([d_namlen])])
 AC_MSG_RESULT($bash_cv_dirent_has_d_namlen)
 if test $bash_cv_dirent_has_d_namlen = yes; then
 AC_DEFINE(HAVE_STRUCT_DIRENT_D_NAMLEN)
@@ -1213,16 +1141,47 @@ if test $bash_cv_struct_timezone = yes; then
 fi
 ])
 
+AC_DEFUN(BASH_CHECK_WINSIZE_IOCTL,
+[AC_CACHE_VAL(bash_cv_struct_winsize_ioctl,
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <sys/types.h>
+#include <sys/ioctl.h>
+]],
+[[
+struct winsize x;
+if (sizeof (x) > 0) return (0);
+]] )], [bash_cv_struct_winsize_ioctl=yes], [bash_cv_struct_winsize_ioctl=no])
+])
+])
+
+AC_DEFUN(BASH_CHECK_WINSIZE_TERMIOS,
+[AC_CACHE_VAL(bash_cv_struct_winsize_termios,
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <sys/types.h>
+#include <sys/termios.h>
+]],
+[[
+struct winsize x;
+if (sizeof (x) > 0) return (0);
+]] )], [bash_cv_struct_winsize_termios=yes], [bash_cv_struct_winsize_termios=no])
+])
+])
+
 AC_DEFUN(BASH_STRUCT_WINSIZE,
 [AC_MSG_CHECKING(for struct winsize in sys/ioctl.h and termios.h)
 AC_CACHE_VAL(bash_cv_struct_winsize_header,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/ioctl.h>], [struct winsize x;],
-  bash_cv_struct_winsize_header=ioctl_h,
-  [AC_TRY_COMPILE([#include <sys/types.h>
-#include <termios.h>], [struct winsize x;],
-  bash_cv_struct_winsize_header=termios_h, bash_cv_struct_winsize_header=other)
-])])
+[
+BASH_CHECK_WINSIZE_IOCTL
+BASH_CHECK_WINSIZE_TERMIOS
+
+if test $bash_cv_struct_winsize_ioctl = yes; then
+  bash_cv_struct_winsize_header=ioctl_h
+elif test $bash_cv_struct_winsize_termios = yes; then
+  bash_cv_struct_winsize_header=termios_h
+else
+  bash_cv_struct_winsize_header=other
+fi
+])
 if test $bash_cv_struct_winsize_header = ioctl_h; then
   AC_MSG_RESULT(sys/ioctl.h)
   AC_DEFINE(STRUCT_WINSIZE_IN_SYS_IOCTL)
@@ -1234,35 +1193,68 @@ else
 fi
 ])
 
-dnl Check type of signal routines (posix, 4.2bsd, 4.1bsd or v7)
-AC_DEFUN(BASH_SYS_SIGNAL_VINTAGE,
-[AC_REQUIRE([AC_TYPE_SIGNAL])
-AC_MSG_CHECKING(for type of signal functions)
-AC_CACHE_VAL(bash_cv_signal_vintage,
-[
-  AC_TRY_LINK([#include <signal.h>],[
+AC_DEFUN(BASH_HAVE_POSIX_SIGNALS,
+[AC_CACHE_VAL(bash_cv_posix_signals,
+[AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <signal.h>
+]], [[
     sigset_t ss;
     struct sigaction sa;
     sigemptyset(&ss); sigsuspend(&ss);
     sigaction(SIGINT, &sa, (struct sigaction *) 0);
     sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
-  ], bash_cv_signal_vintage=posix,
-  [
-    AC_TRY_LINK([#include <signal.h>], [
-	int mask = sigmask(SIGINT);
-	sigsetmask(mask); sigblock(mask); sigpause(mask);
-    ], bash_cv_signal_vintage=4.2bsd,
-    [
-      AC_TRY_LINK([
-	#include <signal.h>
-	RETSIGTYPE foo() { }], [
-		int mask = sigmask(SIGINT);
-		sigset(SIGINT, foo); sigrelse(SIGINT);
-		sighold(SIGINT); sigpause(SIGINT);
-        ], bash_cv_signal_vintage=svr3, bash_cv_signal_vintage=v7
-    )]
-  )]
-)
+]] )],
+[bash_cv_posix_signals=yes], [bash_cv_posix_signals=no]
+)])
+])
+
+AC_DEFUN(BASH_HAVE_BSD_SIGNALS,
+[AC_CACHE_VAL(bash_cv_bsd_signals,
+[AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <signal.h>
+]], [[
+int mask = sigmask(SIGINT);
+sigsetmask(mask); sigblock(mask); sigpause(mask);
+]] )],
+[bash_cv_bsd_signals=yes], [bash_cv_bsd_signals=no]
+)])
+])
+
+AC_DEFUN(BASH_HAVE_SYSV_SIGNALS,
+[AC_CACHE_VAL(bash_cv_sysv_signals,
+[AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <signal.h>
+void foo() { }
+]], [[
+int mask = sigmask(SIGINT);
+sigset(SIGINT, foo); sigrelse(SIGINT);
+sighold(SIGINT); sigpause(SIGINT);
+]] )],
+[bash_cv_sysv_signals=yes], [bash_cv_sysv_signals=no]
+)])
+])
+
+dnl Check type of signal routines (posix, 4.2bsd, 4.1bsd or v7)
+AC_DEFUN(BASH_SYS_SIGNAL_VINTAGE,
+[AC_MSG_CHECKING(for type of signal functions)
+AC_CACHE_VAL(bash_cv_signal_vintage,
+[
+BASH_HAVE_POSIX_SIGNALS
+if test $bash_cv_posix_signals = yes; then
+  bash_cv_signal_vintage=posix
+else
+  BASH_HAVE_BSD_SIGNALS
+  if test $bash_cv_bsd_signals = yes; then
+    bash_cv_signal_vintage=4.2bsd
+  else
+    BASH_HAVE_SYSV_SIGNALS
+    if test $bash_cv_sysv_signals = yes; then
+      bash_cv_signal_vintage=svr3
+    else
+      bash_cv_signal_vintage=v7
+    fi
+  fi
+fi
 ])
 AC_MSG_RESULT($bash_cv_signal_vintage)
 if test "$bash_cv_signal_vintage" = posix; then
@@ -1279,7 +1271,7 @@ AC_DEFUN(BASH_SYS_PGRP_SYNC,
 [AC_REQUIRE([AC_FUNC_GETPGRP])
 AC_MSG_CHECKING(whether pgrps need synchronization)
 AC_CACHE_VAL(bash_cv_pgrp_pipe,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #ifdef HAVE_UNISTD_H
 #  include <unistd.h>
 #endif
@@ -1332,10 +1324,10 @@ main()
 	wait(&status);
 	exit(ok ? 0 : 5);
 }
-], bash_cv_pgrp_pipe=no,bash_cv_pgrp_pipe=yes,
+]])], [bash_cv_pgrp_pipe=no], [bash_cv_pgrp_pipe=yes],
    [AC_MSG_WARN(cannot check pgrp synchronization if cross compiling -- defaulting to no)
-    bash_cv_pgrp_pipe=no])
-])
+    bash_cv_pgrp_pipe=no]
+)])
 AC_MSG_RESULT($bash_cv_pgrp_pipe)
 if test $bash_cv_pgrp_pipe = yes; then
 AC_DEFINE(PGRP_PIPE)
@@ -1343,18 +1335,17 @@ fi
 ])
 
 AC_DEFUN(BASH_SYS_REINSTALL_SIGHANDLERS,
-[AC_REQUIRE([AC_TYPE_SIGNAL])
-AC_REQUIRE([BASH_SYS_SIGNAL_VINTAGE])
+[AC_REQUIRE([BASH_SYS_SIGNAL_VINTAGE])
 AC_MSG_CHECKING([if signal handlers must be reinstalled when invoked])
 AC_CACHE_VAL(bash_cv_must_reinstall_sighandlers,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <signal.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <stdlib.h>
 
-typedef RETSIGTYPE sigfunc();
+typedef void sigfunc();
 
 volatile int nsigint;
 
@@ -1376,7 +1367,7 @@ set_signal_handler(sig, handler)
 #define set_signal_handler(s, h) signal(s, h)
 #endif
 
-RETSIGTYPE
+void
 sigint(s)
 int s;
 {
@@ -1392,7 +1383,7 @@ main()
 	kill((int)getpid(), SIGINT);
 	exit(nsigint != 2);
 }
-], bash_cv_must_reinstall_sighandlers=no, bash_cv_must_reinstall_sighandlers=yes,
+]])], [bash_cv_must_reinstall_sighandlers=no], [bash_cv_must_reinstall_sighandlers=yes],
    [AC_MSG_WARN(cannot check signal handling if cross compiling -- defaulting to no)
     bash_cv_must_reinstall_sighandlers=no]
 )])
@@ -1407,7 +1398,7 @@ AC_DEFUN(BASH_SYS_JOB_CONTROL_MISSING,
 [AC_REQUIRE([BASH_SYS_SIGNAL_VINTAGE])
 AC_MSG_CHECKING(for presence of necessary job control definitions)
 AC_CACHE_VAL(bash_cv_job_control_missing,
-[AC_TRY_COMPILE([
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #include <sys/types.h>
 #ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
@@ -1448,7 +1439,8 @@ AC_CACHE_VAL(bash_cv_job_control_missing,
 #error
 #endif
 
-], , bash_cv_job_control_missing=present, bash_cv_job_control_missing=missing
+]], [[ int x; ]] )],
+[bash_cv_job_control_missing=present], [bash_cv_job_control_missing=missing]
 )])
 AC_MSG_RESULT($bash_cv_job_control_missing)
 if test $bash_cv_job_control_missing = missing; then
@@ -1461,7 +1453,7 @@ dnl this requires a previous check for mkfifo, but that is awkward to specify
 AC_DEFUN(BASH_SYS_NAMED_PIPES,
 [AC_MSG_CHECKING(for presence of named pipes)
 AC_CACHE_VAL(bash_cv_sys_named_pipes,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <sys/types.h>
 #include <sys/stat.h>
 #ifdef HAVE_UNISTD_H
@@ -1501,7 +1493,8 @@ close(fd);
 unlink ("bash-aclocal/sh-np-autoconf");
 rmdir ("bash-aclocal");
 exit(0);
-}], bash_cv_sys_named_pipes=present, bash_cv_sys_named_pipes=missing,
+}
+]])], [bash_cv_sys_named_pipes=present], [bash_cv_sys_named_pipes=missing],
     [AC_MSG_WARN(cannot check for named pipes if cross-compiling -- defaulting to missing)
      bash_cv_sys_named_pipes=missing]
 )])
@@ -1533,9 +1526,11 @@ AC_DEFINE_UNQUOTED(DEFAULT_MAIL_DIRECTORY, "$bash_cv_mail_dir")
 AC_DEFUN(BASH_HAVE_TIOCGWINSZ,
 [AC_MSG_CHECKING(for TIOCGWINSZ in sys/ioctl.h)
 AC_CACHE_VAL(bash_cv_tiocgwinsz_in_ioctl,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/ioctl.h>], [int x = TIOCGWINSZ;],
-  bash_cv_tiocgwinsz_in_ioctl=yes,bash_cv_tiocgwinsz_in_ioctl=no)])
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <sys/types.h>
+#include <sys/ioctl.h>]], [[int x = TIOCGWINSZ;]] )],
+  [bash_cv_tiocgwinsz_in_ioctl=yes], [bash_cv_tiocgwinsz_in_ioctl=no]
+)])
 AC_MSG_RESULT($bash_cv_tiocgwinsz_in_ioctl)
 if test $bash_cv_tiocgwinsz_in_ioctl = yes; then   
 AC_DEFINE(GWINSZ_IN_SYS_IOCTL)
@@ -1545,9 +1540,11 @@ fi
 AC_DEFUN(BASH_HAVE_TIOCSTAT,
 [AC_MSG_CHECKING(for TIOCSTAT in sys/ioctl.h)
 AC_CACHE_VAL(bash_cv_tiocstat_in_ioctl,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/ioctl.h>], [int x = TIOCSTAT;],
-  bash_cv_tiocstat_in_ioctl=yes,bash_cv_tiocstat_in_ioctl=no)])
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <sys/types.h>
+#include <sys/ioctl.h>]], [[int x = TIOCSTAT;]] )],
+  [bash_cv_tiocstat_in_ioctl=yes], [bash_cv_tiocstat_in_ioctl=no]
+)])
 AC_MSG_RESULT($bash_cv_tiocstat_in_ioctl)
 if test $bash_cv_tiocstat_in_ioctl = yes; then   
 AC_DEFINE(TIOCSTAT_IN_SYS_IOCTL)
@@ -1557,9 +1554,11 @@ fi
 AC_DEFUN(BASH_HAVE_FIONREAD,
 [AC_MSG_CHECKING(for FIONREAD in sys/ioctl.h)
 AC_CACHE_VAL(bash_cv_fionread_in_ioctl,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/ioctl.h>], [int x = FIONREAD;],
-  bash_cv_fionread_in_ioctl=yes,bash_cv_fionread_in_ioctl=no)])
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <sys/types.h>
+#include <sys/ioctl.h>]], [[int x = FIONREAD;]] )],
+  [bash_cv_fionread_in_ioctl=yes], [bash_cv_fionread_in_ioctl=no]
+)])
 AC_MSG_RESULT($bash_cv_fionread_in_ioctl)
 if test $bash_cv_fionread_in_ioctl = yes; then   
 AC_DEFINE(FIONREAD_IN_SYS_IOCTL)
@@ -1575,8 +1574,11 @@ dnl
 AC_DEFUN(BASH_CHECK_SPEED_T,
 [AC_MSG_CHECKING(for speed_t in sys/types.h)
 AC_CACHE_VAL(bash_cv_speed_t_in_sys_types,
-[AC_TRY_COMPILE([#include <sys/types.h>], [speed_t x;],
-  bash_cv_speed_t_in_sys_types=yes,bash_cv_speed_t_in_sys_types=no)])
+[AC_COMPILE_IFELSE(
+	[AC_LANG_PROGRAM(
+		[[#include <sys/types.h>]],
+		[[speed_t x;]])],
+	[bash_cv_speed_t_in_sys_types=yes],[bash_cv_speed_t_in_sys_types=no])])
 AC_MSG_RESULT($bash_cv_speed_t_in_sys_types)
 if test $bash_cv_speed_t_in_sys_types = yes; then   
 AC_DEFINE(SPEED_T_IN_SYS_TYPES)
@@ -1646,31 +1648,41 @@ if test $bash_cv_dev_stdin = "present"; then
 fi
 ])
 
+
+AC_DEFUN(BASH_CHECK_RLIMIT,
+[AC_CACHE_VAL(bash_cv_rlimit,
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <sys/types.h>
+#include <sys/resource.h>
+]],
+[[
+  int f;
+  f = RLIMIT_DATA;
+]] )],
+[bash_cv_rlimit=yes], [bash_cv_rlimit=no]
+)])
+])
+
 dnl
 dnl Check if HPUX needs _KERNEL defined for RLIMIT_* definitions
 dnl
 AC_DEFUN(BASH_CHECK_KERNEL_RLIMIT,
 [AC_MSG_CHECKING([whether $host_os needs _KERNEL for RLIMIT defines])
 AC_CACHE_VAL(bash_cv_kernel_rlimit,
-[AC_TRY_COMPILE([
-#include <sys/types.h>
-#include <sys/resource.h>
-],
-[
-  int f;
-  f = RLIMIT_DATA;
-], bash_cv_kernel_rlimit=no,
-[AC_TRY_COMPILE([
+[BASH_CHECK_RLIMIT
+if test $bash_cv_rlimit = no; then
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #include <sys/types.h>
 #define _KERNEL
 #include <sys/resource.h>
 #undef _KERNEL
-],
-[
-	int f;
-        f = RLIMIT_DATA;
-], bash_cv_kernel_rlimit=yes, bash_cv_kernel_rlimit=no)]
-)])
+]],
+[[
+  int f;
+  f = RLIMIT_DATA;
+]] )], [bash_cv_kernel_rlimit=yes], [bash_cv_kernel_rlimit=no] )
+fi
+])
 AC_MSG_RESULT($bash_cv_kernel_rlimit)
 if test $bash_cv_kernel_rlimit = yes; then
 AC_DEFINE(RLIMIT_NEEDS_KERNEL)
@@ -1685,14 +1697,15 @@ dnl sizeof(off_t) is > 4.
 dnl
 AC_DEFUN(BASH_CHECK_OFF_T_64,
 [AC_CACHE_CHECK(for 64-bit off_t, bash_cv_off_t_64,
-AC_TRY_COMPILE([
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/types.h>
-],[
+]],[[
 switch (0) case 0: case (sizeof (off_t) <= 4):;
-], bash_cv_off_t_64=no, bash_cv_off_t_64=yes))
+]] )], [bash_cv_off_t_64=no], [bash_cv_off_t_64=yes]
+))
 if test $bash_cv_off_t_64 = yes; then
         AC_DEFINE(HAVE_OFF_T_64)
 fi])
@@ -1700,7 +1713,7 @@ fi])
 AC_DEFUN(BASH_CHECK_RTSIGS,
 [AC_MSG_CHECKING(for unusable real-time signals due to large values)
 AC_CACHE_VAL(bash_cv_unusable_rtsigs,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <sys/types.h>
 #include <signal.h>
 #include <stdlib.h>
@@ -1720,7 +1733,8 @@ main ()
 #endif
 
   exit(rtmin < n_sigs);
-}], bash_cv_unusable_rtsigs=yes, bash_cv_unusable_rtsigs=no,
+}
+]])], [bash_cv_unusable_rtsigs=yes], [bash_cv_unusable_rtsigs=no],
     [AC_MSG_WARN(cannot check real-time signals if cross compiling -- defaulting to yes)
      bash_cv_unusable_rtsigs=yes]
 )])
@@ -1767,48 +1781,43 @@ fi
 
 AC_CHECK_FUNCS(iswlower iswupper towlower towupper iswctype)
 
-AC_CACHE_CHECK([for nl_langinfo and CODESET], bash_cv_langinfo_codeset,
-[AC_TRY_LINK(
-[#include <langinfo.h>],
-[char* cs = nl_langinfo(CODESET);],
-bash_cv_langinfo_codeset=yes, bash_cv_langinfo_codeset=no)])
-if test $bash_cv_langinfo_codeset = yes; then
-  AC_DEFINE(HAVE_LANGINFO_CODESET)
-fi
+AC_REQUIRE([AM_LANGINFO_CODESET])
 
 dnl check for wchar_t in <wchar.h>
 AC_CACHE_CHECK([for wchar_t in wchar.h], bash_cv_type_wchar_t,
-[AC_TRY_COMPILE(
-[#include <wchar.h>
-],
-[
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
+[#include <wchar.h>]],
+[[
         wchar_t foo;
         foo = 0;
-], bash_cv_type_wchar_t=yes, bash_cv_type_wchar_t=no)])
+]] )], [bash_cv_type_wchar_t=yes], [bash_cv_type_wchar_t=no]
+)])
 if test $bash_cv_type_wchar_t = yes; then
         AC_DEFINE(HAVE_WCHAR_T, 1, [systems should define this type here])
 fi
 
 dnl check for wctype_t in <wctype.h>
 AC_CACHE_CHECK([for wctype_t in wctype.h], bash_cv_type_wctype_t,
-[AC_TRY_COMPILE(
-[#include <wctype.h>],
-[
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
+[#include <wctype.h>]],
+[[
         wctype_t foo;
         foo = 0;
-], bash_cv_type_wctype_t=yes, bash_cv_type_wctype_t=no)])
+]] )], [bash_cv_type_wctype_t=yes], [bash_cv_type_wctype_t=no]
+)])
 if test $bash_cv_type_wctype_t = yes; then
         AC_DEFINE(HAVE_WCTYPE_T, 1, [systems should define this type here])
 fi
 
 dnl check for wint_t in <wctype.h>
 AC_CACHE_CHECK([for wint_t in wctype.h], bash_cv_type_wint_t,
-[AC_TRY_COMPILE(
-[#include <wctype.h>],
-[
+[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
+[#include <wctype.h>]],
+[[
         wint_t foo;
         foo = 0;
-], bash_cv_type_wint_t=yes, bash_cv_type_wint_t=no)])
+]] )], [bash_cv_type_wint_t=yes], [bash_cv_type_wint_t=no]
+)])
 if test $bash_cv_type_wint_t = yes; then
         AC_DEFINE(HAVE_WINT_T, 1, [systems should define this type here])
 fi
@@ -1816,7 +1825,7 @@ fi
 dnl check for broken wcwidth
 AC_CACHE_CHECK([for wcwidth broken with unicode combining characters],
 bash_cv_wcwidth_broken,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <unistd.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -1835,8 +1844,9 @@ char    **v;
         w = wcwidth (0x0301);
         exit (w == 0);  /* exit 0 if wcwidth broken */
 }
-],
-bash_cv_wcwidth_broken=yes, bash_cv_wcwidth_broken=no, bash_cv_wcwidth_broken=no)])
+]])], [bash_cv_wcwidth_broken=yes], [bash_cv_wcwidth_broken=no],
+      [bash_cv_wcwidth_broken=no]
+)])
 if test "$bash_cv_wcwidth_broken" = yes; then
         AC_DEFINE(WCWIDTH_BROKEN, 1, [wcwidth is usually not broken])
 fi
@@ -1886,7 +1896,7 @@ CFLAGS="$CFLAGS -I${ac_cv_rl_includedir}"
 LDFLAGS="$LDFLAGS -L${ac_cv_rl_libdir}"
 
 AC_CACHE_VAL(ac_cv_rl_version,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdio.h>
 #include <readline/readline.h>
 #include <stdlib.h>
@@ -1907,10 +1917,11 @@ main()
 	fclose(fp);
 	exit(0);
 }
-],
-ac_cv_rl_version=`cat conftest.rlv`,
-ac_cv_rl_version='0.0',
-ac_cv_rl_version='8.0')])
+]])],
+[ac_cv_rl_version=`cat conftest.rlv`],
+[ac_cv_rl_version='0.0'],
+[ac_cv_rl_version='8.0']
+)])
 
 CFLAGS="$_save_CFLAGS"
 LDFLAGS="$_save_LDFLAGS"
@@ -1973,57 +1984,11 @@ AC_MSG_RESULT($ac_cv_rl_version)
 fi
 ])
 
-AC_DEFUN(BASH_FUNC_CTYPE_NONASCII,
-[
-AC_MSG_CHECKING(whether the ctype macros accept non-ascii characters)
-AC_CACHE_VAL(bash_cv_func_ctype_nonascii,
-[AC_TRY_RUN([
-#ifdef HAVE_LOCALE_H
-#include <locale.h>
-#endif
-#include <stdio.h>
-#include <ctype.h>
-#include <stdlib.h>
-
-int
-main(c, v)
-int	c;
-char	*v[];
-{
-	char	*deflocale;
-	unsigned char x;
-	int	r1, r2;
-
-#ifdef HAVE_SETLOCALE
-	/* We take a shot here.  If that locale is not known, try the
-	   system default.  We try this one because '\342' (226) is
-	   known to be a printable character in that locale. */
-	deflocale = setlocale(LC_ALL, "en_US.ISO8859-1");
-	if (deflocale == 0)
-		deflocale = setlocale(LC_ALL, "");
-#endif
-
-	x = '\342';
-	r1 = isprint(x);
-	x -= 128;
-	r2 = isprint(x);
-	exit (r1 == 0 || r2 == 0);
-}
-], bash_cv_func_ctype_nonascii=yes, bash_cv_func_ctype_nonascii=no,
-   [AC_MSG_WARN(cannot check ctype macros if cross compiling -- defaulting to no)
-    bash_cv_func_ctype_nonascii=no]
-)])
-AC_MSG_RESULT($bash_cv_func_ctype_nonascii)
-if test $bash_cv_func_ctype_nonascii = yes; then
-AC_DEFINE(CTYPE_NON_ASCII)
-fi
-])
-
 AC_DEFUN(BASH_CHECK_WCONTINUED,
 [
 AC_MSG_CHECKING(whether WCONTINUED flag to waitpid is unavailable or available but broken)
 AC_CACHE_VAL(bash_cv_wcontinued_broken,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <unistd.h>
@@ -2044,7 +2009,7 @@ main()
 	else
 		exit (0);
 }
-], bash_cv_wcontinued_broken=no,bash_cv_wcontinued_broken=yes,
+]])], [bash_cv_wcontinued_broken=no], [bash_cv_wcontinued_broken=yes],
    [AC_MSG_WARN(cannot check WCONTINUED if cross compiling -- defaulting to no)
     bash_cv_wcontinued_broken=no]
 )])
@@ -2060,7 +2025,7 @@ dnl
 
 
 AC_DEFUN([AM_PATH_LISPDIR],
- [AC_ARG_WITH(lispdir, AC_HELP_STRING([--with-lispdir], [override the default lisp directory]),
+ [AC_ARG_WITH(lispdir, AS_HELP_STRING([--with-lispdir], [override the default lisp directory]),
   [ lispdir="$withval" 
     AC_MSG_CHECKING([where .elc files should go])
     AC_MSG_RESULT([$lispdir])],
@@ -2097,7 +2062,7 @@ AC_DEFUN([BASH_FUNC_SNPRINTF],
   AC_CHECK_FUNCS_ONCE([snprintf])
   if test X$ac_cv_func_snprintf = Xyes; then
     AC_CACHE_CHECK([for standard-conformant snprintf], [bash_cv_func_snprintf],
-      [AC_TRY_RUN([
+      [AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdio.h>
 #include <stdlib.h>
 
@@ -2108,7 +2073,7 @@ main()
   n = snprintf (0, 0, "%s", "0123456");
   exit(n != 7);
 }
-], bash_cv_func_snprintf=yes, bash_cv_func_snprintf=no,
+]])], [bash_cv_func_snprintf=yes], [bash_cv_func_snprintf=no],
    [AC_MSG_WARN([cannot check standard snprintf if cross-compiling])
     bash_cv_func_snprintf=yes]
 )])
@@ -2127,7 +2092,7 @@ AC_DEFUN([BASH_FUNC_VSNPRINTF],
   AC_CHECK_FUNCS_ONCE([vsnprintf])
   if test X$ac_cv_func_vsnprintf = Xyes; then
     AC_CACHE_CHECK([for standard-conformant vsnprintf], [bash_cv_func_vsnprintf],
-      [AC_TRY_RUN([
+      [AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #if HAVE_STDARG_H
 #include <stdarg.h>
 #else
@@ -2165,7 +2130,7 @@ main()
   n = foo("%s", "0123456");
   exit(n != 7);
 }
-], bash_cv_func_vsnprintf=yes, bash_cv_func_vsnprintf=no,
+]])], [bash_cv_func_vsnprintf=yes], [bash_cv_func_vsnprintf=no],
    [AC_MSG_WARN([cannot check standard vsnprintf if cross-compiling])
     bash_cv_func_vsnprintf=yes]
 )])
@@ -2182,7 +2147,7 @@ main()
 AC_DEFUN(BASH_STRUCT_WEXITSTATUS_OFFSET,
 [AC_MSG_CHECKING(for offset of exit status in return status from wait)
 AC_CACHE_VAL(bash_cv_wexitstatus_offset,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdlib.h>
 #include <unistd.h>
 
@@ -2216,7 +2181,7 @@ main(c, v)
 
   exit (254);
 }
-], bash_cv_wexitstatus_offset=0, bash_cv_wexitstatus_offset=$?,
+]])], [bash_cv_wexitstatus_offset=0], [bash_cv_wexitstatus_offset=$?],
    [AC_MSG_WARN(cannot check WEXITSTATUS offset if cross compiling -- defaulting to 0)
     bash_cv_wexitstatus_offset=0]
 )])
@@ -2232,13 +2197,15 @@ AC_DEFUN([BASH_FUNC_SBRK],
 [
   AC_MSG_CHECKING([for sbrk])
   AC_CACHE_VAL(ac_cv_func_sbrk,
-  [AC_TRY_LINK([#include <unistd.h>],
-  [ void *x = sbrk (4096); ],
-  ac_cv_func_sbrk=yes, ac_cv_func_sbrk=no)])
+  [AC_LINK_IFELSE(
+	[AC_LANG_PROGRAM(
+		[[#include <unistd.h>]],
+		[[ void *x = sbrk (4096); ]])],
+	[ac_cv_func_sbrk=yes],[ac_cv_func_sbrk=no])])
   AC_MSG_RESULT($ac_cv_func_sbrk)
   if test X$ac_cv_func_sbrk = Xyes; then
     AC_CACHE_CHECK([for working sbrk], [bash_cv_func_sbrk],
-      [AC_TRY_RUN([
+      [AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdlib.h>
 #include <unistd.h>
 
@@ -2250,10 +2217,9 @@ main(int c, char **v)
 	x = sbrk (4096);
 	exit ((x == (void *)-1) ? 1 : 0);
 }
-], bash_cv_func_sbrk=yes, bash_cv_func_snprintf=sbrk,
-   [AC_MSG_WARN([cannot check working sbrk if cross-compiling])
-    bash_cv_func_sbrk=yes]
-)])
+]])],[bash_cv_func_sbrk=yes],[bash_cv_func_sbrk=no],[AC_MSG_WARN([cannot check working sbrk if cross-compiling])
+    bash_cv_func_sbrk=yes
+])])
     if test $bash_cv_func_sbrk = no; then
       ac_cv_func_sbrk=no
     fi
@@ -2267,7 +2233,7 @@ main(int c, char **v)
 AC_DEFUN(BASH_FUNC_FNMATCH_EQUIV_FALLBACK,
 [AC_MSG_CHECKING(whether fnmatch can be used to check bracket equivalence classes)
 AC_CACHE_VAL(bash_cv_fnmatch_equiv_fallback,
-[AC_TRY_RUN([
+[AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdlib.h>
 #include <unistd.h>
 #include <stdio.h>
@@ -2287,8 +2253,7 @@ main (int c, char **v)
     exit (0);
   exit (1);
 }
-
-], bash_cv_fnmatch_equiv_fallback=yes, bash_cv_fnmatch_equiv_fallback=no,
+]])], [bash_cv_fnmatch_equiv_fallback=yes], [bash_cv_fnmatch_equiv_fallback=no],
    [AC_MSG_WARN(cannot check fnmatch if cross compiling -- defaulting to no)
     bash_cv_fnmatch_equiv_fallback=no]
 )])
diff --git a/readline/readline/bind.c b/readline/readline/bind.c
index 87596dcec95ad161743c6adf84e25f15ba7401b3..880db8ccc94389f2dc399c708c237a05505d5844 100644
--- a/readline/readline/bind.c
+++ b/readline/readline/bind.c
@@ -1,6 +1,6 @@
 /* bind.c -- key binding and startup file support for the readline library. */
 
-/* Copyright (C) 1987-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2022 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.
@@ -72,7 +72,7 @@ extern char *strchr (), *strrchr ();
 /* Variables exported by this file. */
 Keymap rl_binding_keymap;
 
-static int _rl_skip_to_delim PARAMS((char *, int, int));
+static int _rl_skip_to_delim (char *, int, int);
 
 #if defined (USE_VARARGS) && defined (PREFER_STDARG)
 static void _rl_init_file_error (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));
@@ -80,23 +80,23 @@ static void _rl_init_file_error (const char *, ...)  __attribute__((__format__ (
 static void _rl_init_file_error ();
 #endif
 
-static rl_command_func_t *_rl_function_of_keyseq_internal PARAMS((const char *, size_t, Keymap, int *));
+static rl_command_func_t *_rl_function_of_keyseq_internal (const char *, size_t, Keymap, int *);
 
-static char *_rl_read_file PARAMS((char *, size_t *));
-static int _rl_read_init_file PARAMS((const char *, int));
-static int glean_key_from_name PARAMS((char *));
+static char *_rl_read_file (char *, size_t *);
+static int _rl_read_init_file (const char *, int);
+static int glean_key_from_name (char *);
 
-static int find_boolean_var PARAMS((const char *));
-static int find_string_var PARAMS((const char *));
+static int find_boolean_var (const char *);
+static int find_string_var (const char *);
 
-static const char *boolean_varname PARAMS((int));
-static const char *string_varname PARAMS((int));
+static const char *boolean_varname (int);
+static const char *string_varname (int);
 
-static char *_rl_get_string_variable_value PARAMS((const char *));
-static int substring_member_of_array PARAMS((const char *, const char * const *));
+static char *_rl_get_string_variable_value (const char *);
+static int substring_member_of_array (const char *, const char * const *);
 
-static int _rl_get_keymap_by_name PARAMS((const char *));
-static int _rl_get_keymap_by_map PARAMS((Keymap));
+static int _rl_get_keymap_by_name (const char *);
+static int _rl_get_keymap_by_map (Keymap);
 
 static int currently_reading_init_file;
 
@@ -880,6 +880,85 @@ rl_function_of_keyseq_len (const char *keyseq, size_t len, Keymap map, int *type
   return _rl_function_of_keyseq_internal (keyseq, len, map, type);
 }
 
+/* Assuming there is a numeric argument at the beginning of KEYSEQ (the
+   caller is responsible for checking), return the index of the portion of
+   the key sequence following the numeric argument. If there's no numeric
+   argument (?), or if KEYSEQ consists solely of a numeric argument (?),
+   return -1. */
+int
+rl_trim_arg_from_keyseq	(const char *keyseq, size_t len, Keymap map)
+{
+  register int i, j, parsing_digits;
+  unsigned char ic;
+  Keymap map0;
+
+  if (map == 0)
+    map = _rl_keymap;
+  map0 = map;
+
+  /* The digits following the initial one (e.g., the binding to digit-argument)
+    or the optional `-' in a binding to digit-argument or universal-argument
+    are not added to rl_executing_keyseq. This is basically everything read by
+    rl_digit_loop. The parsing_digits logic is here in case they ever are. */
+  for (i = j = parsing_digits = 0; keyseq && i < len; i++)
+    {
+      ic = keyseq[i];
+
+      if (parsing_digits)
+	{
+	  if (_rl_digit_p (ic))
+	    {
+	      j = i + 1;
+	      continue;
+	    }
+	  parsing_digits = 0;
+	}
+
+      if (map[ic].type == ISKMAP)
+	{
+	  if (i + 1 == len)
+	    return -1;
+	  map = FUNCTION_TO_KEYMAP (map, ic);
+	  continue;
+	}
+      if (map[ic].type == ISFUNC)
+	{
+#if defined (VI_MODE)
+	  if (map[ic].function != rl_digit_argument && map[ic].function != rl_universal_argument && map[ic].function != rl_vi_arg_digit)
+#else
+	  if (map[ic].function != rl_digit_argument && map[ic].function != rl_universal_argument)
+#endif
+	    return (j);
+
+	  /* We don't bother with a keyseq that is only a numeric argument */
+	  if (i + 1 == len)
+	    return -1;
+
+	  parsing_digits = 1;
+
+	  /* This logic should be identical to rl_digit_loop */
+	  /* We accept M-- as equivalent to M--1, C-u- as equivalent to C-u-1
+	     but set parsing_digits to 2 to note that we saw `-' */
+	  if (map[ic].function == rl_universal_argument && (i + 1 == '-'))
+	    {
+	      i++;
+	      parsing_digits = 2;
+	    }
+	  if (map[ic].function == rl_digit_argument && ic == '-')
+	    {
+	      parsing_digits = 2;
+	    }
+
+	  map = map0;
+	  j = i + 1;
+	}
+    }
+
+  /* If we're still parsing digits by the time we get here, we don't allow a
+     key sequence that consists solely of a numeric argument */
+  return -1;
+}
+  
 /* The last key bindings file read. */
 static char *last_readline_init_file = (char *)NULL;
 
@@ -899,11 +978,20 @@ _rl_read_file (char *filename, size_t *sizep)
   char *buffer;
   int i, file;
 
-  file = -1;
-  if (((file = open (filename, O_RDONLY, 0666)) < 0) || (fstat (file, &finfo) < 0))
+  file = open (filename, O_RDONLY, 0666);
+  /* If the open is interrupted, retry once */
+  if (file < 0 && errno == EINTR)
     {
+      RL_CHECK_SIGNALS ();
+      file = open (filename, O_RDONLY, 0666);
+    }
+  
+  if ((file < 0) || (fstat (file, &finfo) < 0))
+    {
+      i = errno;
       if (file >= 0)
 	close (file);
+      errno = i;
       return ((char *)NULL);
     }
 
@@ -912,10 +1000,13 @@ _rl_read_file (char *filename, size_t *sizep)
   /* check for overflow on very large files */
   if (file_size != finfo.st_size || file_size + 1 < file_size)
     {
+      i = errno;
       if (file >= 0)
 	close (file);
 #if defined (EFBIG)
       errno = EFBIG;
+#else
+      errno = i;
 #endif
       return ((char *)NULL);
     }
@@ -1088,9 +1179,7 @@ _rl_init_file_error (va_alist)
 /* **************************************************************** */
 
 static int
-parse_comparison_op (s, indp)
-     const char *s;
-     int *indp;
+parse_comparison_op (const char *s, int *indp)
 {
   int i, peekc, op;
 
@@ -1143,7 +1232,7 @@ parse_comparison_op (s, indp)
 /*								    */
 /* **************************************************************** */
 
-typedef int _rl_parser_func_t PARAMS((char *));
+typedef int _rl_parser_func_t (char *);
 
 /* Things that mean `Control'. */
 const char * const _rl_possible_control_prefixes[] = {
@@ -1154,6 +1243,12 @@ const char * const _rl_possible_meta_prefixes[] = {
   "Meta", "M-", (const char *)NULL
 };
 
+/* Forward declarations */
+static int parser_if (char *);
+static int parser_else (char *);
+static int parser_endif (char *);
+static int parser_include (char *);
+
 /* Conditionals. */
 
 /* Calling programs set this to have their argv[0]. */
@@ -1234,7 +1329,7 @@ parser_if (char *args)
 #endif /* VI_MODE */
   else if (_rl_strnicmp (args, "version", 7) == 0)
     {
-      int rlversion, versionarg, op, previ, major, minor;
+      int rlversion, versionarg, op, previ, major, minor, opresult;
 
       _rl_parsing_conditionalized_out = 1;
       rlversion = RL_VERSION_MAJOR*10 + RL_VERSION_MINOR;
@@ -1294,24 +1389,25 @@ parser_if (char *args)
       switch (op)
 	{
 	case OP_EQ:
-	  _rl_parsing_conditionalized_out = rlversion == versionarg;
+ 	  opresult = rlversion == versionarg;
 	  break;
 	case OP_NE:
-	  _rl_parsing_conditionalized_out = rlversion != versionarg;
+	  opresult = rlversion != versionarg;
 	  break;
 	case OP_GT:
-	  _rl_parsing_conditionalized_out = rlversion > versionarg;
+	  opresult = rlversion > versionarg;
 	  break;
 	case OP_GE:
-	  _rl_parsing_conditionalized_out = rlversion >= versionarg;
+	  opresult = rlversion >= versionarg;
 	  break;
 	case OP_LT:
-	  _rl_parsing_conditionalized_out = rlversion < versionarg;
+	  opresult = rlversion < versionarg;
 	  break;
 	case OP_LE:
-	  _rl_parsing_conditionalized_out = rlversion <= versionarg;
+	  opresult = rlversion <= versionarg;
 	  break;
 	}
+      _rl_parsing_conditionalized_out = 1 - opresult;
     }
   /* Check to see if the first word in ARGS is the same as the
      value stored in rl_readline_name. */
@@ -1812,6 +1908,7 @@ static const struct {
   { "convert-meta",		&_rl_convert_meta_chars_to_ascii, 0 },
   { "disable-completion",	&rl_inhibit_completion,		0 },
   { "echo-control-characters",	&_rl_echo_control_chars,	0 },
+  { "enable-active-region",	&_rl_enable_active_region,	0 },
   { "enable-bracketed-paste",	&_rl_enable_bracketed_paste,	V_SPECIAL },
   { "enable-keypad",		&_rl_enable_keypad,		0 },
   { "enable-meta-key",		&_rl_enable_meta,		0 },
@@ -1882,7 +1979,7 @@ hack_special_boolean_var (int i)
     _rl_enable_active_region = _rl_enable_bracketed_paste;
 }
 
-typedef int _rl_sv_func_t PARAMS((const char *));
+typedef int _rl_sv_func_t (const char *);
 
 /* These *must* correspond to the array indices for the appropriate
    string variable.  (Though they're not used right now.) */
@@ -1896,25 +1993,29 @@ typedef int _rl_sv_func_t PARAMS((const char *));
 #define V_INT		2
 
 /* Forward declarations */
-static int sv_bell_style PARAMS((const char *));
-static int sv_combegin PARAMS((const char *));
-static int sv_dispprefix PARAMS((const char *));
-static int sv_compquery PARAMS((const char *));
-static int sv_compwidth PARAMS((const char *));
-static int sv_editmode PARAMS((const char *));
-static int sv_emacs_modestr PARAMS((const char *));
-static int sv_histsize PARAMS((const char *));
-static int sv_isrchterm PARAMS((const char *));
-static int sv_keymap PARAMS((const char *));
-static int sv_seqtimeout PARAMS((const char *));
-static int sv_viins_modestr PARAMS((const char *));
-static int sv_vicmd_modestr PARAMS((const char *));
+static int sv_region_start_color (const char *);
+static int sv_region_end_color (const char *);
+static int sv_bell_style (const char *);
+static int sv_combegin (const char *);
+static int sv_dispprefix (const char *);
+static int sv_compquery (const char *);
+static int sv_compwidth (const char *);
+static int sv_editmode (const char *);
+static int sv_emacs_modestr (const char *);
+static int sv_histsize (const char *);
+static int sv_isrchterm (const char *);
+static int sv_keymap (const char *);
+static int sv_seqtimeout (const char *);
+static int sv_viins_modestr (const char *);
+static int sv_vicmd_modestr (const char *);
 
 static const struct {
   const char * const name;
   int flags;
   _rl_sv_func_t *set_func;
 } string_varlist[] = {
+  { "active-region-end-color", V_STRING, sv_region_end_color },
+  { "active-region-start-color", V_STRING, sv_region_start_color },
   { "bell-style",	V_STRING,	sv_bell_style },
   { "comment-begin",	V_STRING,	sv_combegin },
   { "completion-display-width", V_INT,	sv_compwidth },
@@ -2133,6 +2234,18 @@ sv_seqtimeout (const char *value)
   return 0;
 }
 
+static int
+sv_region_start_color (const char *value)
+{
+  return (_rl_reset_region_color (0, value));
+}
+
+static int
+sv_region_end_color (const char *value)
+{
+  return (_rl_reset_region_color (1, value));
+}
+
 static int
 sv_bell_style (const char *value)
 {
@@ -2547,6 +2660,15 @@ _rl_get_keyname (int key)
       keyname[i++] = (c / 8) + '0';
       c = (c % 8) + '0';
     }
+  /* These characters are valid UTF-8; convert them into octal escape
+     sequences as well. This changes C. */
+  else if (c >= 160)
+    {
+      keyname[i++] = '\\';
+      keyname[i++] = '0' + ((((unsigned char)c) >> 6) & 0x07);
+      keyname[i++] = '0' + ((((unsigned char)c) >> 3) & 0x07);
+      c = (c % 8) + '0';
+    }
 
   /* Now, if the character needs to be quoted with a backslash, do that. */
   if (c == '\\' || c == '"')
diff --git a/readline/readline/callback.c b/readline/readline/callback.c
index 93f23d97bc20ed43439ee01afb19005ff7d911b5..7209ec38215e942248dd71f3b8487d923eba0881 100644
--- a/readline/readline/callback.c
+++ b/readline/readline/callback.c
@@ -115,7 +115,10 @@ rl_callback_handler_install (const char *prompt, rl_vcpfunc_t *linefunc)
 #define CALLBACK_READ_RETURN() \
   do { \
     if (rl_persistent_signal_handlers == 0) \
-      rl_clear_signals (); \
+      { \
+        rl_clear_signals (); \
+        if (_rl_caught_signal) _rl_signal_handler (_rl_caught_signal); \
+      } \
     return; \
   } while (0)
 #else
@@ -149,6 +152,14 @@ rl_callback_read_char (void)
       (*rl_redisplay_function) ();
       _rl_want_redisplay = 0;
       memcpy ((void *)_rl_top_level, (void *)olevel, sizeof (procenv_t));
+
+      /* If we longjmped because of a timeout, handle it here. */
+      if (RL_ISSTATE (RL_STATE_TIMEOUT))
+	{
+	  RL_SETSTATE (RL_STATE_DONE);
+	  rl_done = 1;
+	}
+
       CALLBACK_READ_RETURN ();
     }
 
@@ -287,7 +298,8 @@ rl_callback_read_char (void)
 	  rl_clear_signals ();
 #endif
 	  in_handler = 0;
-	  (*rl_linefunc) (line);
+	  if (rl_linefunc)			/* just in case */
+	    (*rl_linefunc) (line);
 
 	  /* If the user did not clear out the line, do it for him. */
 	  if (rl_line_buffer[0])
diff --git a/readline/readline/chardefs.h b/readline/readline/chardefs.h
index 3cf1326aab7515d572d405ad3330a4757735331c..24a25f1f105bb45b41c8eefc5ad9b34d93aa941b 100644
--- a/readline/readline/chardefs.h
+++ b/readline/readline/chardefs.h
@@ -1,6 +1,6 @@
 /* chardefs.h -- Character definitions for readline. */
 
-/* Copyright (C) 1994-2015 Free Software Foundation, Inc.
+/* Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.
@@ -26,9 +26,6 @@
 
 #if defined (HAVE_CONFIG_H)
 #  if defined (HAVE_STRING_H)
-#    if ! defined (STDC_HEADERS) && defined (HAVE_MEMORY_H)
-#      include <memory.h>
-#    endif
 #    include <string.h>
 #  endif /* HAVE_STRING_H */
 #  if defined (HAVE_STRINGS_H)
@@ -66,22 +63,26 @@
 #define UNMETA(c) ((c) & (~meta_character_bit))
 #define UNCTRL(c) _rl_to_upper(((c)|control_character_bit))
 
-#if defined STDC_HEADERS || (!defined (isascii) && !defined (HAVE_ISASCII))
-#  define IN_CTYPE_DOMAIN(c) 1
-#else
-#  define IN_CTYPE_DOMAIN(c) isascii(c)
+#ifndef UCHAR_MAX
+#  define UCHAR_MAX 255
 #endif
-
-#if !defined (isxdigit) && !defined (HAVE_ISXDIGIT) && !defined (__cplusplus)
-#  define isxdigit(c)   (isdigit((unsigned char)(c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
+#ifndef CHAR_MAX
+#  define CHAR_MAX 127
 #endif
 
-#if defined (CTYPE_NON_ASCII)
+/* use this as a proxy for C89 */
+#if defined (HAVE_STDLIB_H) && defined (HAVE_STRING_H)
+#  define IN_CTYPE_DOMAIN(c) 1
 #  define NON_NEGATIVE(c) 1
 #else
+#  define IN_CTYPE_DOMAIN(c) ((c) >= 0 && (c) <= CHAR_MAX)
 #  define NON_NEGATIVE(c) ((unsigned char)(c) == (c))
 #endif
 
+#if !defined (isxdigit) && !defined (HAVE_ISXDIGIT) && !defined (__cplusplus)
+#  define isxdigit(c)   (isdigit((unsigned char)(c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
+#endif
+
 /* Some systems define these; we want our definitions. */
 #undef ISPRINT
 
@@ -99,12 +100,12 @@
 #define _rl_uppercase_p(c)	(NON_NEGATIVE(c) && ISUPPER(c))
 #define _rl_digit_p(c)		((c) >= '0' && (c) <= '9')
 
+#define _rl_alphabetic_p(c)	(NON_NEGATIVE(c) && ISALNUM(c))
 #define _rl_pure_alphabetic(c)	(NON_NEGATIVE(c) && ISALPHA(c))
-#define ALPHABETIC(c)		(NON_NEGATIVE(c) && ISALNUM(c))
 
 #ifndef _rl_to_upper
-#  define _rl_to_upper(c) (_rl_lowercase_p(c) ? toupper((unsigned char)c) : (c))
-#  define _rl_to_lower(c) (_rl_uppercase_p(c) ? tolower((unsigned char)c) : (c))
+#  define _rl_to_upper(c) (_rl_lowercase_p(c) ? toupper((unsigned char)(c)) : (c))
+#  define _rl_to_lower(c) (_rl_uppercase_p(c) ? tolower((unsigned char)(c)) : (c))
 #endif
 
 #ifndef _rl_digit_value
diff --git a/readline/readline/colors.c b/readline/readline/colors.c
index 9e37527ef3509ce4ae33094fd26d67831c9551ce..4212c64c36d1f68499fbead576f4e4fde780bc38 100644
--- a/readline/readline/colors.c
+++ b/readline/readline/colors.c
@@ -2,7 +2,7 @@
 
    Modified by Chet Ramey for Readline.
 
-   Copyright (C) 1985, 1988, 1990-1991, 1995-2010, 2012, 2015, 2017, 2019
+   Copyright (C) 1985, 1988, 1990-1991, 1995-2021
    Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
@@ -73,6 +73,8 @@
 static bool is_colored (enum indicator_no type);
 static void restore_default_color (void);
 
+#define RL_COLOR_PREFIX_EXTENSION	".readline-colored-completion-prefix"
+
 COLOR_EXT_TYPE *_rl_color_ext_list = 0;
 
 /* Output a color indicator (which may contain nulls).  */
@@ -110,13 +112,28 @@ _rl_set_normal_color (void)
     }
 }
 
+static struct bin_str *
+_rl_custom_readline_prefix (void)
+{
+  size_t len;
+  COLOR_EXT_TYPE *ext;
+
+  len = strlen (RL_COLOR_PREFIX_EXTENSION);
+  for (ext = _rl_color_ext_list; ext; ext = ext->next)
+    if (ext->ext.len == len && STREQN (ext->ext.string, RL_COLOR_PREFIX_EXTENSION, len))
+      return (&ext->seq);
+  return (NULL);
+}
+
 bool
 _rl_print_prefix_color (void)
 {
   struct bin_str *s;
 
   /* What do we want to use for the prefix? Let's try cyan first, see colors.h */
-  s = &_rl_color_indicator[C_PREFIX];
+  s = _rl_custom_readline_prefix ();
+  if (s == 0)
+    s = &_rl_color_indicator[C_PREFIX];
   if (s->string != NULL)
     {
       if (is_colored (C_NORM))
@@ -239,8 +256,10 @@ _rl_print_color_indicator (const char *f)
       else if (S_ISSOCK (mode))
         colored_filetype = C_SOCK;
 #endif
+#if defined (S_ISBLK)
       else if (S_ISBLK (mode))
         colored_filetype = C_BLK;
+#endif
       else if (S_ISCHR (mode))
         colored_filetype = C_CHR;
       else
diff --git a/readline/readline/compat.c b/readline/readline/compat.c
index 3ade3629aef440a4d8bec22cc1419e49704c4eef..fc2a48f4aafa2896647bb6e8087e8da21e94de76 100644
--- a/readline/readline/compat.c
+++ b/readline/readline/compat.c
@@ -1,6 +1,6 @@
 /* compat.c -- backwards compatibility functions. */
 
-/* Copyright (C) 2000-2017 Free Software Foundation, Inc.
+/* Copyright (C) 2000-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.
@@ -30,18 +30,18 @@
 #include "rlstdc.h"
 #include "rltypedefs.h"
 
-extern void rl_free_undo_list PARAMS((void));
-extern int rl_maybe_save_line PARAMS((void));
-extern int rl_maybe_unsave_line PARAMS((void));
-extern int rl_maybe_replace_line PARAMS((void));
+extern void rl_free_undo_list (void);
+extern int rl_maybe_save_line (void);
+extern int rl_maybe_unsave_line (void);
+extern int rl_maybe_replace_line (void);
 
-extern int rl_crlf PARAMS((void));
-extern int rl_ding PARAMS((void));
-extern int rl_alphabetic PARAMS((int));
+extern int rl_crlf (void);
+extern int rl_ding (void);
+extern int rl_alphabetic (int);
 
-extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
-extern char *rl_username_completion_function PARAMS((const char *, int));
-extern char *rl_filename_completion_function PARAMS((const char *, int));
+extern char **rl_completion_matches (const char *, rl_compentry_func_t *);
+extern char *rl_username_completion_function (const char *, int);
+extern char *rl_filename_completion_function (const char *, int);
 
 /* Provide backwards-compatible entry points for old function names. */
 
diff --git a/readline/readline/complete.c b/readline/readline/complete.c
index fc5c3adb3564d6408214f74a0a3e64a0f0437cd4..70a0a608b85ddad06180a6eafbf8a04ec8b3aada 100644
--- a/readline/readline/complete.c
+++ b/readline/readline/complete.c
@@ -1,6 +1,6 @@
 /* complete.c -- filename completion for readline. */
 
-/* Copyright (C) 1987-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.
@@ -95,7 +95,7 @@ typedef int QSFUNC ();
 /* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
    defined. */
 #if defined (HAVE_GETPWENT) && (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))
-extern struct passwd *getpwent PARAMS((void));
+extern struct passwd *getpwent (void);
 #endif /* HAVE_GETPWENT && (!HAVE_GETPW_DECLS || _POSIX_SOURCE) */
 
 /* If non-zero, then this is the address of a function to call when
@@ -114,44 +114,44 @@ rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)N
 #endif
 
 #if defined (VISIBLE_STATS)
-static int stat_char PARAMS((char *));
+static int stat_char (char *);
 #endif
 
 #if defined (COLOR_SUPPORT)
-static int colored_stat_start PARAMS((const char *));
-static void colored_stat_end PARAMS((void));
-static int colored_prefix_start PARAMS((void));
-static void colored_prefix_end PARAMS((void));
+static int colored_stat_start (const char *);
+static void colored_stat_end (void);
+static int colored_prefix_start (void);
+static void colored_prefix_end (void);
 #endif
 
-static int path_isdir PARAMS((const char *));
+static int path_isdir (const char *);
 
-static char *rl_quote_filename PARAMS((char *, int, char *));
+static char *rl_quote_filename (char *, int, char *);
 
-static void _rl_complete_sigcleanup PARAMS((int, void *));
+static void _rl_complete_sigcleanup (int, void *);
 
-static void set_completion_defaults PARAMS((int));
-static int get_y_or_n PARAMS((int));
-static int _rl_internal_pager PARAMS((int));
-static char *printable_part PARAMS((char *));
-static int fnwidth PARAMS((const char *));
-static int fnprint PARAMS((const char *, int, const char *));
-static int print_filename PARAMS((char *, char *, int));
+static void set_completion_defaults (int);
+static int get_y_or_n (int);
+static int _rl_internal_pager (int);
+static char *printable_part (char *);
+static int fnwidth (const char *);
+static int fnprint (const char *, int, const char *);
+static int print_filename (char *, char *, int);
 
-static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));
+static char **gen_completion_matches (char *, int, int, rl_compentry_func_t *, int, int);
 
-static char **remove_duplicate_matches PARAMS((char **));
-static void insert_match PARAMS((char *, int, int, char *));
-static int append_to_match PARAMS((char *, int, int, int));
-static void insert_all_matches PARAMS((char **, int, char *));
-static int complete_fncmp PARAMS((const char *, int, const char *, int));
-static void display_matches PARAMS((char **));
-static int compute_lcd_of_matches PARAMS((char **, int, const char *));
-static int postprocess_matches PARAMS((char ***, int));
-static int compare_match PARAMS((char *, const char *));
-static int complete_get_screenwidth PARAMS((void));
+static char **remove_duplicate_matches (char **);
+static void insert_match (char *, int, int, char *);
+static int append_to_match (char *, int, int, int);
+static void insert_all_matches (char **, int, char *);
+static int complete_fncmp (const char *, int, const char *, int);
+static void display_matches (char **);
+static int compute_lcd_of_matches (char **, int, const char *);
+static int postprocess_matches (char ***, int);
+static int compare_match (char *, const char *);
+static int complete_get_screenwidth (void);
 
-static char *make_quoted_replacement PARAMS((char *, int, char *));
+static char *make_quoted_replacement (char *, int, char *);
 
 /* **************************************************************** */
 /*								    */
@@ -304,7 +304,7 @@ const char *rl_basic_quote_characters = "\"'";
 /* The list of characters that signal a break between words for
    rl_complete_internal.  The default list is the contents of
    rl_basic_word_break_characters.  */
-/*const*/ char *rl_completer_word_break_characters = (/*const*/ char *)NULL;
+const char *rl_completer_word_break_characters = 0;
 
 /* Hook function to allow an application to set the completion word
    break characters before readline breaks up the line.  Allows
@@ -757,7 +757,7 @@ fnwidth (const char *string)
   mbstate_t ps;
   int left, w;
   size_t clen;
-  wchar_t wc;
+  WCHAR_T wc;
 
   left = strlen (string) + 1;
   memset (&ps, 0, sizeof (mbstate_t));
@@ -774,7 +774,7 @@ fnwidth (const char *string)
       else
 	{
 #if defined (HANDLE_MULTIBYTE)
-	  clen = mbrtowc (&wc, string + pos, left - pos, &ps);
+	  clen = MBRTOWC (&wc, string + pos, left - pos, &ps);
 	  if (MB_INVALIDCH (clen))
 	    {
 	      width++;
@@ -812,7 +812,7 @@ fnprint (const char *to_print, int prefix_bytes, const char *real_pathname)
   const char *end;
   size_t tlen;
   int width;
-  wchar_t wc;
+  WCHAR_T wc;
 
   print_len = strlen (to_print);
   end = to_print + print_len + 1;
@@ -835,7 +835,8 @@ fnprint (const char *to_print, int prefix_bytes, const char *real_pathname)
     colored_stat_start (real_pathname);
 #endif
 
-  if (prefix_bytes && _rl_completion_prefix_display_length > 0)
+  if (prefix_bytes && _rl_completion_prefix_display_length > 0 &&
+      prefix_bytes > _rl_completion_prefix_display_length)
     {
       char ellipsis;
 
@@ -880,7 +881,7 @@ fnprint (const char *to_print, int prefix_bytes, const char *real_pathname)
       else
 	{
 #if defined (HANDLE_MULTIBYTE)
-	  tlen = mbrtowc (&wc, s, end - s, &ps);
+	  tlen = MBRTOWC (&wc, s, end - s, &ps);
 	  if (MB_INVALIDCH (tlen))
 	    {
 	      tlen = 1;
@@ -1078,7 +1079,8 @@ char
 _rl_find_completion_word (int *fp, int *dp)
 {
   int scan, end, found_quote, delimiter, pass_next, isbrk;
-  char quote_char, *brkchars;
+  char quote_char;
+  const char *brkchars;
 
   end = rl_point;
   found_quote = delimiter = 0;
@@ -1321,7 +1323,7 @@ compute_lcd_of_matches (char **match_list, int matches, const char *text)
   int v;
   size_t v1, v2;
   mbstate_t ps1, ps2;
-  wchar_t wc1, wc2;
+  WCHAR_T wc1, wc2;
 #endif
 
   /* If only one match, just use that.  Otherwise, compare each
@@ -1353,8 +1355,8 @@ compute_lcd_of_matches (char **match_list, int matches, const char *text)
 #if defined (HANDLE_MULTIBYTE)
 	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
 	      {
-		v1 = mbrtowc(&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);
-		v2 = mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);
+		v1 = MBRTOWC (&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);
+		v2 = MBRTOWC (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);
 		if (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))
 		  {
 		    if (c1 != c2)	/* do byte comparison */
@@ -1364,7 +1366,7 @@ compute_lcd_of_matches (char **match_list, int matches, const char *text)
 		if (_rl_completion_case_fold)
 		  {
 		    wc1 = towlower (wc1);
-		   wc2 = towlower (wc2);
+		    wc2 = towlower (wc2);
 		  }
 		if (wc1 != wc2)
 		  break;
@@ -1547,7 +1549,7 @@ rl_display_match_list (char **matches, int len, int max)
 
       if (common_length > _rl_completion_prefix_display_length && common_length > ELLIPSIS_LEN)
 	max -= common_length - ELLIPSIS_LEN;
-      else
+      else if (_rl_colored_completion_prefix <= 0)
 	common_length = sind = 0;
     }
 #if defined (COLOR_SUPPORT)
@@ -1979,7 +1981,7 @@ compare_match (char *text, const char *match)
     {
       temp = (*rl_filename_dequoting_function) (text, rl_completion_quote_character);
       r = strcmp (temp, match);
-      free (temp);
+      xfree (temp);
       return r;
     }      
   return (strcmp (text, match));
@@ -2029,9 +2031,25 @@ rl_complete_internal (int what_to_do)
 
   text = rl_copy_text (start, end);
   matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);
+  /* If TEXT contains quote characters, it will be dequoted as part of
+     generating the matches, and the matches will not contain any quote
+     characters. We need to dequote TEXT before performing the comparison.
+     Since compare_match performs the dequoting, and we only want to do it
+     once, we don't call compare_matches after dequoting TEXT; we call
+     strcmp directly. */
   /* nontrivial_lcd is set if the common prefix adds something to the word
      being completed. */
-  nontrivial_lcd = matches && compare_match (text, matches[0]) != 0;
+  if (rl_filename_completion_desired && rl_filename_quoting_desired &&
+      rl_completion_found_quote && rl_filename_dequoting_function)
+    {
+      char *t;
+      t = (*rl_filename_dequoting_function) (text, rl_completion_quote_character);
+      xfree (text);
+      text = t;
+      nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
+    }
+  else
+    nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
   if (what_to_do == '!' || what_to_do == '@')
     tlen = strlen (text);
   xfree (text);
@@ -2330,7 +2348,7 @@ complete_fncmp (const char *convfn, int convlen, const char *filename, int filen
 #if defined (HANDLE_MULTIBYTE)
   size_t v1, v2;
   mbstate_t ps1, ps2;
-  wchar_t wc1, wc2;
+  WCHAR_T wc1, wc2;
 #endif
 
 #if defined (HANDLE_MULTIBYTE)
@@ -2357,8 +2375,8 @@ complete_fncmp (const char *convfn, int convlen, const char *filename, int filen
 	{
 	  do
 	    {
-	      v1 = mbrtowc (&wc1, s1, convlen, &ps1);
-	      v2 = mbrtowc (&wc2, s2, filename_len, &ps2);
+	      v1 = MBRTOWC (&wc1, s1, convlen, &ps1);
+	      v2 = MBRTOWC (&wc2, s2, filename_len, &ps2);
 	      if (v1 == 0 && v2 == 0)
 		return 1;
 	      else if (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))
@@ -2407,8 +2425,8 @@ complete_fncmp (const char *convfn, int convlen, const char *filename, int filen
 	{
 	  do
 	    {
-	      v1 = mbrtowc (&wc1, s1, convlen, &ps1);
-	      v2 = mbrtowc (&wc2, s2, filename_len, &ps2);
+	      v1 = MBRTOWC (&wc1, s1, convlen, &ps1);
+	      v2 = MBRTOWC (&wc2, s2, filename_len, &ps2);
 	      if (v1 == 0 && v2 == 0)
 		return 1;
 	      else if (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))
@@ -2524,7 +2542,8 @@ rl_filename_completion_function (const char *text, int state)
 	  temp = tilde_expand (dirname);
 	  xfree (dirname);
 	  dirname = temp;
-	  tilde_dirname = 1;
+	  if (*dirname != '~')
+	    tilde_dirname = 1;	/* indicate successful tilde expansion */
 	}
 
       /* We have saved the possibly-dequoted version of the directory name
@@ -2543,11 +2562,16 @@ rl_filename_completion_function (const char *text, int state)
 	  xfree (users_dirname);
 	  users_dirname = savestring (dirname);
 	}
-      else if (tilde_dirname == 0 && rl_completion_found_quote && rl_filename_dequoting_function)
+      else if (rl_completion_found_quote && rl_filename_dequoting_function)
 	{
-	  /* delete single and double quotes */
+	  /* We already ran users_dirname through the dequoting function.
+	     If tilde_dirname == 1, we successfully performed tilde expansion
+	     on dirname. Now we need to reconcile those results. We either
+	     just copy the already-dequoted users_dirname or tilde expand it
+	     if we tilde-expanded dirname. */
+	  temp = tilde_dirname ? tilde_expand (users_dirname) : savestring (users_dirname);
 	  xfree (dirname);
-	  dirname = savestring (users_dirname);
+	  dirname = temp;
 	}
       directory = opendir (dirname);
 
diff --git a/readline/readline/config.h.in b/readline/readline/config.h.in
index 6de47b5874396c2e79acd2080c3d30110898408d..521e7789ba79d1c11200824a1c15bd80c78557fc 100644
--- a/readline/readline/config.h.in
+++ b/readline/readline/config.h.in
@@ -1,6 +1,8 @@
 /* config.h.in.  Maintained by hand. */
 
 /* Template definitions for autoconf */
+
+/* These are set by AC_USE_SYSTEM_EXTENSIONS */
 #undef __EXTENSIONS__
 #undef _ALL_SOURCE
 #undef _GNU_SOURCE
@@ -16,12 +18,9 @@
 
 #undef _FILE_OFFSET_BITS
 
-/* Define as the return type of signal handlers (int or void).  */
-#undef RETSIGTYPE
-
-#undef VOID_SIGHANDLER
-
 /* Characteristics of the compiler. */
+#undef inline
+
 #undef sig_atomic_t
 
 #undef size_t
@@ -58,6 +57,9 @@
 /* Define if you have the getpwuid function. */
 #undef HAVE_GETPWUID
 
+/* Define if you have the gettimeofday function. */
+#undef HAVE_GETTIMEOFDAY
+
 /* Define if you have the isascii function. */
 #undef HAVE_ISASCII
 
@@ -106,6 +108,9 @@
 /* Define if you have the setenv function.  */
 #undef HAVE_SETENV
 
+/* Define if you have the setitimer function.  */
+#undef HAVE_SETITIMER
+
 /* Define if you have the setlocale function. */
 #undef HAVE_SETLOCALE
 
@@ -120,6 +125,9 @@
 /* Define if you have the strpbrk function.  */
 #undef HAVE_STRPBRK
 
+/* Define if you have the sysconf function.  */
+#undef HAVE_SYSCONF
+
 /* Define if you have the tcgetattr function.  */
 #undef HAVE_TCGETATTR
 
@@ -147,8 +155,6 @@
 /* and whether it works */
 #undef WCWIDTH_BROKEN
 
-#undef STDC_HEADERS
-
 /* Define if you have the <dirent.h> header file.  */
 #undef HAVE_DIRENT_H
 
@@ -218,6 +224,9 @@
 /* Define if you have the <sys/stream.h> header file.  */
 #undef HAVE_SYS_STREAM_H
 
+/* Define if you have the <sys/time.h> header file.  */
+#undef HAVE_SYS_TIME_H
+
 /* Define if you have the <termcap.h> header file.  */
 #undef HAVE_TERMCAP_H
 
@@ -257,8 +266,6 @@
 #undef HAVE_DECL_AUDIT_USER_TTY
 
 /* Definitions pulled in from aclocal.m4. */
-#undef VOID_SIGHANDLER
-
 #undef GWINSZ_IN_SYS_IOCTL
 
 #undef STRUCT_WINSIZE_IN_SYS_IOCTL
@@ -279,6 +286,8 @@
 
 #undef HAVE_STRUCT_DIRENT_D_NAMLEN
 
+#undef HAVE_TIMEVAL
+
 #undef HAVE_BSD_SIGNALS
 
 #undef HAVE_POSIX_SIGNALS
diff --git a/readline/readline/configure b/readline/readline/configure
index 6ea4545e26f25e8ee923d02a9855f43088b5abc6..151009f1b0c7684daf3146334a34aa0eaabfe673 100755
--- a/readline/readline/configure
+++ b/readline/readline/configure
@@ -724,6 +724,7 @@ ac_subst_files=''
 ac_user_opts='
 enable_option_checking
 with_curses
+with_shared_termcap_library
 enable_multibyte
 enable_static
 enable_install_examples
@@ -1366,6 +1367,9 @@ Optional Packages:
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-curses           use the curses library instead of the termcap
                           library
+  --with-shared-termcap-library
+                          link the readline shared library against the
+                          termcap/curses shared library [[default=NO]]
 
 Some influential environment variables:
   CC          C compiler command
@@ -1863,6 +1867,63 @@ $as_echo "$ac_res" >&6; }
 
 } # ac_fn_c_check_func
 
+# ac_fn_c_check_member LINENO AGGR MEMBER VAR INCLUDES
+# ----------------------------------------------------
+# Tries to find if the field MEMBER exists in type AGGR, after including
+# INCLUDES, setting cache variable VAR accordingly.
+ac_fn_c_check_member ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2.$3" >&5
+$as_echo_n "checking for $2.$3... " >&6; }
+if eval \${$4+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$5
+int
+main ()
+{
+static $2 ac_aggr;
+if (ac_aggr.$3)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$4=yes"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$5
+int
+main ()
+{
+static $2 ac_aggr;
+if (sizeof ac_aggr.$3)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$4=yes"
+else
+  eval "$4=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$4
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_member
+
 # ac_fn_c_check_decl LINENO SYMBOL VAR INCLUDES
 # ---------------------------------------------
 # Tests whether SYMBOL is declared in INCLUDES, setting cache variable VAR
@@ -2482,7 +2543,7 @@ ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
 ac_config_headers="$ac_config_headers config.h"
 
 
-LIBVERSION=8.1
+LIBVERSION=8.2
 
 # Make sure we can run config.sub.
 $SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
@@ -2558,6 +2619,7 @@ case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
 opt_curses=no
+opt_shared_termcap_lib=no
 
 
 # Check whether --with-curses was given.
@@ -2566,6 +2628,12 @@ if test "${with_curses+set}" = set; then :
 fi
 
 
+# Check whether --with-shared-termcap-library was given.
+if test "${with_shared_termcap_library+set}" = set; then :
+  withval=$with_shared_termcap_library; opt_shared_termcap_lib=$withval
+fi
+
+
 if test "$opt_curses" = "yes"; then
 	prefer_curses=yes
 fi
@@ -3923,11 +3991,10 @@ $as_echo "$ac_cv_safe_to_define___extensions__" >&6; }
 
 
 
-
 # If we're using gcc and the user hasn't specified CFLAGS, add -O2 to CFLAGS
 if test -n "$want_auto_cflags" ; then
-	AUTO_CFLAGS="-g ${GCC+-O2}"
-	STYLE_CFLAGS="${GCC+-Wno-parentheses} ${GCC+-Wno-format-security}"
+	AUTO_CFLAGS="-g ${GCC:+-O2}"
+	STYLE_CFLAGS="${GCC:+-Wno-parentheses} ${GCC:+-Wno-format-security} ${GCC:+-Wno-tautological-constant-out-of-range-compare}"
 fi
 
 if test $ac_cv_c_compiler_gnu = yes; then
@@ -4254,6 +4321,13 @@ fi
 MAKE_SHELL=/bin/sh
 
 
+
+# codeset.m4 serial 5 (gettext-0.18.2)
+
+
+
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for an ANSI C-conforming const" >&5
 $as_echo_n "checking for an ANSI C-conforming const... " >&6; }
 if ${ac_cv_c_const+:} false; then :
@@ -4335,6 +4409,48 @@ $as_echo "#define const /**/" >>confdefs.h
 
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for inline" >&5
+$as_echo_n "checking for inline... " >&6; }
+if ${ac_cv_c_inline+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
+
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_inline=$ac_kw
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  test "$ac_cv_c_inline" != no && break
+done
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_inline" >&5
+$as_echo "$ac_cv_c_inline" >&6; }
+
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  *)
+    case $ac_cv_c_inline in
+      no) ac_val=;;
+      *) ac_val=$ac_cv_c_inline;;
+    esac
+    cat >>confdefs.h <<_ACEOF
+#ifndef __cplusplus
+#define inline $ac_val
+#endif
+_ACEOF
+    ;;
+esac
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for function prototypes" >&5
 $as_echo_n "checking for function prototypes... " >&6; }
 if test "$ac_cv_prog_cc_c89" != no; then
@@ -4419,40 +4535,6 @@ $as_echo "#define volatile /**/" >>confdefs.h
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking return type of signal handlers" >&5
-$as_echo_n "checking return type of signal handlers... " >&6; }
-if ${ac_cv_type_signal+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <signal.h>
-
-int
-main ()
-{
-return *(signal (0, 0)) (0) == 1;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_type_signal=int
-else
-  ac_cv_type_signal=void
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_type_signal" >&5
-$as_echo "$ac_cv_type_signal" >&6; }
-
-cat >>confdefs.h <<_ACEOF
-#define RETSIGTYPE $ac_cv_type_signal
-_ACEOF
-
-
-
 ac_fn_c_check_type "$LINENO" "size_t" "ac_cv_type_size_t" "$ac_includes_default"
 if test "x$ac_cv_type_size_t" = xyes; then :
 
@@ -4476,119 +4558,6 @@ _ACEOF
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if ${ac_cv_header_stdc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_header_stdc=yes
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <string.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then :
-  :
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
-
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
-
-$as_echo "#define STDC_HEADERS 1" >>confdefs.h
-
-fi
-
-
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stat file-mode macros are broken" >&5
 $as_echo_n "checking whether stat file-mode macros are broken... " >&6; }
 if ${ac_cv_header_stat_broken+:} false; then :
@@ -4790,7 +4759,7 @@ fi
 fi
 
 
-for ac_func in fcntl kill lstat readlink
+for ac_func in fcntl gettimeofday kill lstat pselect readlink select setitimer
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
@@ -4802,8 +4771,8 @@ _ACEOF
 fi
 done
 
-for ac_func in fnmatch memmove pselect putenv select setenv setlocale \
-		strcasecmp strpbrk tcgetattr vsnprintf
+for ac_func in fnmatch memmove putenv setenv setlocale \
+		strcasecmp strpbrk sysconf tcgetattr vsnprintf
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
@@ -4990,7 +4959,8 @@ fi
 
 done
 
-for ac_header in sys/ioctl.h sys/pte.h sys/stream.h sys/select.h sys/file.h
+for ac_header in sys/ioctl.h sys/pte.h sys/stream.h sys/select.h \
+		sys/time.h sys/file.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
@@ -5223,16 +5193,20 @@ rm -rf conftest*
 fi
 
 
-
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for type of signal functions" >&5
 $as_echo_n "checking for type of signal functions... " >&6; }
 if ${bash_cv_signal_vintage+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
+if ${bash_cv_posix_signals+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
+
 #include <signal.h>
+
 int
 main ()
 {
@@ -5248,60 +5222,91 @@ main ()
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  bash_cv_signal_vintage=posix
+  bash_cv_posix_signals=yes
 else
+  bash_cv_posix_signals=no
 
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+
+if test $bash_cv_posix_signals = yes; then
+  bash_cv_signal_vintage=posix
+else
+  if ${bash_cv_bsd_signals+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
+
 #include <signal.h>
+
 int
 main ()
 {
 
-	int mask = sigmask(SIGINT);
-	sigsetmask(mask); sigblock(mask); sigpause(mask);
+int mask = sigmask(SIGINT);
+sigsetmask(mask); sigblock(mask); sigpause(mask);
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  bash_cv_signal_vintage=4.2bsd
+  bash_cv_bsd_signals=yes
 else
+  bash_cv_bsd_signals=no
 
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+
+  if test $bash_cv_bsd_signals = yes; then
+    bash_cv_signal_vintage=4.2bsd
+  else
+    if ${bash_cv_sysv_signals+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-	#include <signal.h>
-	RETSIGTYPE foo() { }
+#include <signal.h>
+void foo() { }
+
 int
 main ()
 {
 
-		int mask = sigmask(SIGINT);
-		sigset(SIGINT, foo); sigrelse(SIGINT);
-		sighold(SIGINT); sigpause(SIGINT);
+int mask = sigmask(SIGINT);
+sigset(SIGINT, foo); sigrelse(SIGINT);
+sighold(SIGINT); sigpause(SIGINT);
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  bash_cv_signal_vintage=svr3
+  bash_cv_sysv_signals=yes
 else
-  bash_cv_signal_vintage=v7
+  bash_cv_sysv_signals=no
 
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-
 fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
 
+
+    if test $bash_cv_sysv_signals = yes; then
+      bash_cv_signal_vintage=svr3
+    else
+      bash_cv_signal_vintage=v7
+    fi
+  fi
 fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
 
 fi
 
@@ -5319,7 +5324,6 @@ $as_echo "#define HAVE_USG_SIGHOLD 1" >>confdefs.h
 fi
 
 
-
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking if signal handlers must be reinstalled when invoked" >&5
 $as_echo_n "checking if signal handlers must be reinstalled when invoked... " >&6; }
 if ${bash_cv_must_reinstall_sighandlers+:} false; then :
@@ -5340,7 +5344,7 @@ else
 #endif
 #include <stdlib.h>
 
-typedef RETSIGTYPE sigfunc();
+typedef void sigfunc();
 
 volatile int nsigint;
 
@@ -5362,7 +5366,7 @@ set_signal_handler(sig, handler)
 #define set_signal_handler(s, h) signal(s, h)
 #endif
 
-RETSIGTYPE
+void
 sigint(s)
 int s;
 {
@@ -5406,9 +5410,13 @@ if ${bash_cv_func_sigsetjmp+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test "$cross_compiling" = yes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to missing" >&5
-$as_echo "$as_me: WARNING: cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to missing" >&2;}
-     bash_cv_func_sigsetjmp=missing
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to $bash_cv_posix_signals" >&5
+$as_echo "$as_me: WARNING: cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to $bash_cv_posix_signals" >&2;}
+     if test "$bash_cv_posix_signals" = "yes" ; then
+	bash_cv_func_sigsetjmp=present
+     else
+	bash_cv_func_sigsetjmp=missing
+     fi
 
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -5430,21 +5438,30 @@ exit (1);
 #else
 
 int code;
-sigset_t set, oset;
+sigset_t set, oset, nset;
 sigjmp_buf xx;
 
 /* get the mask */
 sigemptyset(&set);
 sigemptyset(&oset);
-sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &set);
+
 sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
+/* paranoia -- make sure SIGINT is not blocked */
+sigdelset (&oset, SIGINT);
+sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
 
 /* save it */
 code = sigsetjmp(xx, 1);
 if (code)
-  exit(0);	/* could get sigmask and compare to oset here. */
+{
+  sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &nset);
+  /* could compare nset to oset here, but we just look for SIGINT */
+  if (sigismember (&nset, SIGINT))
+    exit(1);
+  exit(0);
+}
 
-/* change it */
+/* change it so that SIGINT is blocked */
 sigaddset(&set, SIGINT);
 sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
 
@@ -5453,6 +5470,7 @@ siglongjmp(xx, 10);
 exit(1);
 #endif
 }
+
 _ACEOF
 if ac_fn_c_try_run "$LINENO"; then :
   bash_cv_func_sigsetjmp=present
@@ -5480,8 +5498,8 @@ else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-#include <sys/types.h>
-#include <sys/stat.h>
+		#include <sys/types.h>
+		#include <sys/stat.h>
 
 int
 main ()
@@ -5506,7 +5524,6 @@ if test $bash_cv_func_lstat = yes; then
 
 fi
 
-
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether or not strcoll and strcmp differ" >&5
 $as_echo_n "checking whether or not strcoll and strcmp differ... " >&6; }
 if ${bash_cv_func_strcoll_broken+:} false; then :
@@ -5579,72 +5596,6 @@ $as_echo "#define STRCOLL_BROKEN 1" >>confdefs.h
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the ctype macros accept non-ascii characters" >&5
-$as_echo_n "checking whether the ctype macros accept non-ascii characters... " >&6; }
-if ${bash_cv_func_ctype_nonascii+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cannot check ctype macros if cross compiling -- defaulting to no" >&5
-$as_echo "$as_me: WARNING: cannot check ctype macros if cross compiling -- defaulting to no" >&2;}
-    bash_cv_func_ctype_nonascii=no
-
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#ifdef HAVE_LOCALE_H
-#include <locale.h>
-#endif
-#include <stdio.h>
-#include <ctype.h>
-#include <stdlib.h>
-
-int
-main(c, v)
-int	c;
-char	*v[];
-{
-	char	*deflocale;
-	unsigned char x;
-	int	r1, r2;
-
-#ifdef HAVE_SETLOCALE
-	/* We take a shot here.  If that locale is not known, try the
-	   system default.  We try this one because '\342' (226) is
-	   known to be a printable character in that locale. */
-	deflocale = setlocale(LC_ALL, "en_US.ISO8859-1");
-	if (deflocale == 0)
-		deflocale = setlocale(LC_ALL, "");
-#endif
-
-	x = '\342';
-	r1 = isprint(x);
-	x -= 128;
-	r2 = isprint(x);
-	exit (r1 == 0 || r2 == 0);
-}
-
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-  bash_cv_func_ctype_nonascii=yes
-else
-  bash_cv_func_ctype_nonascii=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bash_cv_func_ctype_nonascii" >&5
-$as_echo "$bash_cv_func_ctype_nonascii" >&6; }
-if test $bash_cv_func_ctype_nonascii = yes; then
-$as_echo "#define CTYPE_NON_ASCII 1" >>confdefs.h
-
-fi
-
-
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether getpw functions are declared in pwd.h" >&5
 $as_echo_n "checking whether getpw functions are declared in pwd.h... " >&6; }
 if ${bash_cv_getpw_declared+:} false; then :
@@ -5739,6 +5690,20 @@ $as_echo "#define GWINSZ_IN_SYS_IOCTL 1" >>confdefs.h
 fi
 
 
+
+ for ac_header in inttypes.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "inttypes.h" "ac_cv_header_inttypes_h" "$ac_includes_default"
+if test "x$ac_cv_header_inttypes_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_INTTYPES_H 1
+_ACEOF
+
+fi
+
+done
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sig_atomic_t in signal.h" >&5
 $as_echo_n "checking for sig_atomic_t in signal.h... " >&6; }
 if ${ac_cv_have_sig_atomic_t+:} false; then :
@@ -5746,9 +5711,7 @@ if ${ac_cv_have_sig_atomic_t+:} false; then :
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-
-#include <signal.h>
-
+ #include <signal.h>
 int
 main ()
 {
@@ -5769,54 +5732,50 @@ fi
 $as_echo "$ac_cv_have_sig_atomic_t" >&6; }
 if test "$ac_cv_have_sig_atomic_t" = "no"
 then
-    ac_fn_c_check_type "$LINENO" "sig_atomic_t" "ac_cv_type_sig_atomic_t" "$ac_includes_default"
-if test "x$ac_cv_type_sig_atomic_t" = xyes; then :
-
-else
-
-cat >>confdefs.h <<_ACEOF
-#define sig_atomic_t int
-_ACEOF
 
-fi
-
-fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether signal handlers are of type void" >&5
-$as_echo_n "checking whether signal handlers are of type void... " >&6; }
-if ${bash_cv_void_sighandler+:} false; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sig_atomic_t" >&5
+$as_echo_n "checking for sig_atomic_t... " >&6; }
+if ${bash_cv_type_sig_atomic_t+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/types.h>
-#include <signal.h>
-#ifdef signal
-#undef signal
+#if HAVE_STDLIB_H
+#include <stdlib.h>
 #endif
-#ifdef __cplusplus
-extern "C"
+#if HAVE_STDDEF_H
+#include <stddef.h>
 #endif
-void (*signal ()) ();
-int
-main ()
-{
-int i;
-  ;
-  return 0;
-}
+#if HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+#include <signal.h>
+
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  bash_cv_void_sighandler=yes
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "sig_atomic_t" >/dev/null 2>&1; then :
+  bash_cv_type_sig_atomic_t=yes
 else
-  bash_cv_void_sighandler=no
+  bash_cv_type_sig_atomic_t=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest*
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bash_cv_type_sig_atomic_t" >&5
+$as_echo "$bash_cv_type_sig_atomic_t" >&6; }
+
+if test $bash_cv_type_sig_atomic_t = no; then
+  cat >>confdefs.h <<_ACEOF
+#define sig_atomic_t int
+_ACEOF
+
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bash_cv_void_sighandler" >&5
-$as_echo "$bash_cv_void_sighandler" >&6; }
-if test $bash_cv_void_sighandler = yes; then
-$as_echo "#define VOID_SIGHANDLER 1" >>confdefs.h
 
 fi
 
@@ -5828,6 +5787,7 @@ if ${bash_cv_tiocstat_in_ioctl+:} false; then :
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
+
 #include <sys/types.h>
 #include <sys/ioctl.h>
 int
@@ -5842,6 +5802,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
   bash_cv_tiocstat_in_ioctl=yes
 else
   bash_cv_tiocstat_in_ioctl=no
+
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
@@ -5860,6 +5821,7 @@ if ${bash_cv_fionread_in_ioctl+:} false; then :
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
+
 #include <sys/types.h>
 #include <sys/ioctl.h>
 int
@@ -5874,6 +5836,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
   bash_cv_fionread_in_ioctl=yes
 else
   bash_cv_fionread_in_ioctl=no
+
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
@@ -5921,42 +5884,76 @@ $as_echo_n "checking for struct winsize in sys/ioctl.h and termios.h... " >&6; }
 if ${bash_cv_struct_winsize_header+:} false; then :
   $as_echo_n "(cached) " >&6
 else
+
+if ${bash_cv_struct_winsize_ioctl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
+
 #include <sys/types.h>
 #include <sys/ioctl.h>
+
 int
 main ()
 {
+
 struct winsize x;
+if (sizeof (x) > 0) return (0);
+
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
-  bash_cv_struct_winsize_header=ioctl_h
+  bash_cv_struct_winsize_ioctl=yes
+else
+  bash_cv_struct_winsize_ioctl=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+
+if ${bash_cv_struct_winsize_termios+:} false; then :
+  $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
+
 #include <sys/types.h>
-#include <termios.h>
+#include <sys/termios.h>
+
 int
 main ()
 {
+
 struct winsize x;
+if (sizeof (x) > 0) return (0);
+
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
-  bash_cv_struct_winsize_header=termios_h
+  bash_cv_struct_winsize_termios=yes
 else
-  bash_cv_struct_winsize_header=other
+  bash_cv_struct_winsize_termios=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+
+if test $bash_cv_struct_winsize_ioctl = yes; then
+  bash_cv_struct_winsize_header=ioctl_h
+elif test $bash_cv_struct_winsize_termios = yes; then
+  bash_cv_struct_winsize_header=termios_h
+else
+  bash_cv_struct_winsize_header=other
+fi
+
 fi
 
 if test $bash_cv_struct_winsize_header = ioctl_h; then
@@ -5977,12 +5974,12 @@ fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct dirent.d_ino" >&5
 $as_echo_n "checking for struct dirent.d_ino... " >&6; }
-if ${bash_cv_dirent_has_dino+:} false; then :
+if ${bash_cv_dirent_has_d_ino+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
 
+
+ac_fn_c_check_member "$LINENO" "struct dirent" "d_ino" "ac_cv_member_struct_dirent_d_ino" "
 #include <stdio.h>
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
@@ -6003,27 +6000,24 @@ else
 # endif
 #endif /* HAVE_DIRENT_H */
 
-int
-main ()
-{
-
-struct dirent d; int z; z = d.d_ino;
+"
+if test "x$ac_cv_member_struct_dirent_d_ino" = xyes; then :
 
-  ;
-  return 0;
-}
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STRUCT_DIRENT_D_INO 1
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  bash_cv_dirent_has_dino=yes
+
+bash_cv_dirent_has_d_ino=yes
 else
-  bash_cv_dirent_has_dino=no
+  bash_cv_dirent_has_d_ino=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bash_cv_dirent_has_dino" >&5
-$as_echo "$bash_cv_dirent_has_dino" >&6; }
-if test $bash_cv_dirent_has_dino = yes; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bash_cv_dirent_has_d_ino" >&5
+$as_echo "$bash_cv_dirent_has_d_ino" >&6; }
+if test $bash_cv_dirent_has_d_ino = yes; then
 $as_echo "#define HAVE_STRUCT_DIRENT_D_INO 1" >>confdefs.h
 
 fi
@@ -6034,9 +6028,9 @@ $as_echo_n "checking for struct dirent.d_fileno... " >&6; }
 if ${bash_cv_dirent_has_d_fileno+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
 
+
+ac_fn_c_check_member "$LINENO" "struct dirent" "d_fileno" "ac_cv_member_struct_dirent_d_fileno" "
 #include <stdio.h>
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
@@ -6057,28 +6051,62 @@ else
 # endif
 #endif /* HAVE_DIRENT_H */
 
+"
+if test "x$ac_cv_member_struct_dirent_d_fileno" = xyes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STRUCT_DIRENT_D_FILENO 1
+_ACEOF
+
+bash_cv_dirent_has_d_fileno=yes
+else
+  bash_cv_dirent_has_d_fileno=no
+fi
+
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bash_cv_dirent_has_d_fileno" >&5
+$as_echo "$bash_cv_dirent_has_d_fileno" >&6; }
+if test $bash_cv_dirent_has_d_fileno = yes; then
+$as_echo "#define HAVE_STRUCT_DIRENT_D_FILENO 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for struct timeval in sys/time.h and time.h" >&5
+$as_echo_n "checking for struct timeval in sys/time.h and time.h... " >&6; }
+if ${bash_cv_struct_timeval+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#if HAVE_SYS_TIME_H
+		  #include <sys/time.h>
+		  #endif
+		  #include <time.h>
+
 int
 main ()
 {
-
-struct dirent d; int z; z = d.d_fileno;
+static struct timeval x; x.tv_sec = x.tv_usec;
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
-  bash_cv_dirent_has_d_fileno=yes
+  bash_cv_struct_timeval=yes
 else
-  bash_cv_dirent_has_d_fileno=no
+  bash_cv_struct_timeval=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bash_cv_dirent_has_d_fileno" >&5
-$as_echo "$bash_cv_dirent_has_d_fileno" >&6; }
-if test $bash_cv_dirent_has_d_fileno = yes; then
-$as_echo "#define HAVE_STRUCT_DIRENT_D_FILENO 1" >>confdefs.h
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bash_cv_struct_timeval" >&5
+$as_echo "$bash_cv_struct_timeval" >&6; }
+if test $bash_cv_struct_timeval = yes; then
+  $as_echo "#define HAVE_TIMEVAL 1" >>confdefs.h
 
 fi
 
@@ -6359,7 +6387,8 @@ elif test $bash_cv_termcap_lib = libc; then
 TERMCAP_LIB=
 TERMCAP_DEP=
 else
-TERMCAP_LIB=-lcurses
+# we assume ncurses is installed somewhere the linker can find it
+TERMCAP_LIB=-lncurses
 TERMCAP_DEP=
 fi
 
@@ -6385,6 +6414,10 @@ fi
 done
 
 fi
+case "$opt_shared_termcap_lib" in
+[Yy][Ee][Ss])	SHARED_TERMCAP="$TERMCAP_LIB" ;;
+-l*)		SHARED_TERMCAP="$opt_shared_termcap_lib" ;;
+esac
 
 case "$TERMCAP_LIB" in
 -ltinfo)  TERMCAP_PKG_CONFIG_LIB=tinfo ;;
@@ -6395,6 +6428,40 @@ case "$TERMCAP_LIB" in
 esac
 
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for nl_langinfo and CODESET" >&5
+$as_echo_n "checking for nl_langinfo and CODESET... " >&6; }
+if ${am_cv_langinfo_codeset+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <langinfo.h>
+int
+main ()
+{
+char* cs = nl_langinfo(CODESET); return !cs;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  am_cv_langinfo_codeset=yes
+else
+  am_cv_langinfo_codeset=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_langinfo_codeset" >&5
+$as_echo "$am_cv_langinfo_codeset" >&6; }
+  if test $am_cv_langinfo_codeset = yes; then
+
+$as_echo "#define HAVE_LANGINFO_CODESET 1" >>confdefs.h
+
+  fi
+
+
 for ac_header in wctype.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "wctype.h" "ac_cv_header_wctype_h" "$ac_includes_default"
@@ -6592,36 +6659,7 @@ fi
 done
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for nl_langinfo and CODESET" >&5
-$as_echo_n "checking for nl_langinfo and CODESET... " >&6; }
-if ${bash_cv_langinfo_codeset+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <langinfo.h>
-int
-main ()
-{
-char* cs = nl_langinfo(CODESET);
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  bash_cv_langinfo_codeset=yes
-else
-  bash_cv_langinfo_codeset=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $bash_cv_langinfo_codeset" >&5
-$as_echo "$bash_cv_langinfo_codeset" >&6; }
-if test $bash_cv_langinfo_codeset = yes; then
-  $as_echo "#define HAVE_LANGINFO_CODESET 1" >>confdefs.h
 
-fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for wchar_t in wchar.h" >&5
 $as_echo_n "checking for wchar_t in wchar.h... " >&6; }
@@ -6630,8 +6668,8 @@ if ${bash_cv_type_wchar_t+:} false; then :
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <wchar.h>
 
+#include <wchar.h>
 int
 main ()
 {
@@ -6647,6 +6685,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
   bash_cv_type_wchar_t=yes
 else
   bash_cv_type_wchar_t=no
+
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
@@ -6665,6 +6704,7 @@ if ${bash_cv_type_wctype_t+:} false; then :
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
+
 #include <wctype.h>
 int
 main ()
@@ -6681,6 +6721,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
   bash_cv_type_wctype_t=yes
 else
   bash_cv_type_wctype_t=no
+
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
@@ -6699,6 +6740,7 @@ if ${bash_cv_type_wint_t+:} false; then :
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
+
 #include <wctype.h>
 int
 main ()
@@ -6715,6 +6757,7 @@ if ac_fn_c_try_compile "$LINENO"; then :
   bash_cv_type_wint_t=yes
 else
   bash_cv_type_wint_t=no
+
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
@@ -6733,6 +6776,7 @@ if ${bash_cv_wcwidth_broken+:} false; then :
 else
   if test "$cross_compiling" = yes; then :
   bash_cv_wcwidth_broken=no
+
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -6848,10 +6892,12 @@ if test -f ${srcdir}/support/shobj-conf; then
 $as_echo_n "checking configuration for building shared libraries... " >&6; }
         eval `TERMCAP_LIB=$TERMCAP_LIB ${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c ${host_cpu} -o ${host_os} -v ${host_vendor}`
 
-#	case "$SHLIB_LIBS" in
-#	*curses*|*termcap*|*termlib*)	;;
-#	*)			SHLIB_LIBS="$SHLIB_LIBS $TERMCAP_LIB" ;;
-#	esac
+	# SHARED_TERMCAP is set only if opt_shared_termcap_library is set
+	case "$SHLIB_LIBS" in
+	*curses*|*tinfo*)	;;
+	*termcap*|*termlib*)	;;	# common aliases
+	*)		SHLIB_LIBS="$SHLIB_LIBS $SHARED_TERMCAP" ;;
+	esac
 
 
 
@@ -6916,6 +6962,7 @@ esac
 
 
 
+# CFLAGS=${CFLAGS-"$AUTO_CFLAGS"}
 if test -n "$want_auto_cflags"; then
 	CFLAGS="$AUTO_CFLAGS"
 fi
@@ -6937,9 +6984,11 @@ CFLAGS="$CFLAGS $STYLE_CFLAGS"
 
 
 
-ac_config_files="$ac_config_files Makefile doc/Makefile examples/Makefile shlib/Makefile readline.pc"
+ac_config_files="$ac_config_files Makefile doc/Makefile examples/Makefile shlib/Makefile readline.pc history.pc"
+
+
+ac_config_commands="$ac_config_commands stamp-h"
 
-ac_config_commands="$ac_config_commands default"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -7641,7 +7690,8 @@ do
     "examples/Makefile") CONFIG_FILES="$CONFIG_FILES examples/Makefile" ;;
     "shlib/Makefile") CONFIG_FILES="$CONFIG_FILES shlib/Makefile" ;;
     "readline.pc") CONFIG_FILES="$CONFIG_FILES readline.pc" ;;
-    "default") CONFIG_COMMANDS="$CONFIG_COMMANDS default" ;;
+    "history.pc") CONFIG_FILES="$CONFIG_FILES history.pc" ;;
+    "stamp-h") CONFIG_COMMANDS="$CONFIG_COMMANDS stamp-h" ;;
 
   *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
@@ -8197,10 +8247,7 @@ $as_echo "$as_me: executing $ac_file commands" >&6;}
 
 
   case $ac_file$ac_mode in
-    "default":C)
-# Makefile uses this timestamp file to record whether config.h is up to date.
-echo > stamp-h
- ;;
+    "stamp-h":C) echo > stamp-h ;;
 
   esac
 done # for ac_tag
diff --git a/readline/readline/configure.ac b/readline/readline/configure.ac
index f2900752e8d97b112b3fb7841fcd239fe6b102f8..518cae4c51f820f2ff7ef60777e772eb77d28365 100644
--- a/readline/readline/configure.ac
+++ b/readline/readline/configure.ac
@@ -5,7 +5,7 @@ dnl report bugs to chet@po.cwru.edu
 dnl
 dnl Process this file with autoconf to produce a configure script.
 
-# Copyright (C) 1987-2020 Free Software Foundation, Inc.
+# Copyright (C) 1987-2022 Free Software Foundation, Inc.
 
 #   This program is free software: you can redistribute it and/or modify
 #   it under the terms of the GNU General Public License as published by
@@ -36,16 +36,18 @@ AC_CONFIG_AUX_DIR(../..)
 AC_CONFIG_HEADERS(config.h)
 
 dnl update the value of RL_READLINE_VERSION in readline.h when this changes
-LIBVERSION=8.1
+LIBVERSION=8.2
 
 AC_CANONICAL_HOST
 AC_CANONICAL_BUILD
 
 dnl configure defaults
 opt_curses=no
+opt_shared_termcap_lib=no
 
 dnl arguments to configure
 AC_ARG_WITH(curses, AS_HELP_STRING([--with-curses], [use the curses library instead of the termcap library]), opt_curses=$withval)
+AC_ARG_WITH(shared-termcap-library, AS_HELP_STRING([--with-shared-termcap-library], [link the readline shared library against the termcap/curses shared library [[default=NO]]]), opt_shared_termcap_lib=$withval)
 
 if test "$opt_curses" = "yes"; then
 	prefer_curses=yes
@@ -119,8 +121,8 @@ AC_USE_SYSTEM_EXTENSIONS
 
 # If we're using gcc and the user hasn't specified CFLAGS, add -O2 to CFLAGS
 if test -n "$want_auto_cflags" ; then
-	AUTO_CFLAGS="-g ${GCC+-O2}"
-	STYLE_CFLAGS="${GCC+-Wno-parentheses} ${GCC+-Wno-format-security}"
+	AUTO_CFLAGS="-g ${GCC:+-O2}"
+	STYLE_CFLAGS="${GCC:+-Wno-parentheses} ${GCC:+-Wno-format-security} ${GCC:+-Wno-tautological-constant-out-of-range-compare}"
 fi
 
 AC_PROG_GCC_TRADITIONAL
@@ -134,24 +136,25 @@ AC_PROG_RANLIB
 MAKE_SHELL=/bin/sh
 AC_SUBST(MAKE_SHELL)
 
+dnl include files for gettext
+
+m4_include([m4/codeset.m4])
+
 AC_C_CONST
+AC_C_INLINE
 AC_C_PROTOTYPES
 AC_C_CHAR_UNSIGNED
 AC_C_VOLATILE
 
-AC_TYPE_SIGNAL
-
 AC_TYPE_SIZE_T
 AC_CHECK_TYPE(ssize_t, int)
 
-AC_HEADER_STDC
-
 AC_HEADER_STAT
 AC_HEADER_DIRENT
 
-AC_CHECK_FUNCS(fcntl kill lstat readlink)
-AC_CHECK_FUNCS(fnmatch memmove pselect putenv select setenv setlocale \
-		strcasecmp strpbrk tcgetattr vsnprintf)
+AC_CHECK_FUNCS(fcntl gettimeofday kill lstat pselect readlink select setitimer)
+AC_CHECK_FUNCS(fnmatch memmove putenv setenv setlocale \
+		strcasecmp strpbrk sysconf tcgetattr vsnprintf)
 AC_CHECK_FUNCS(isascii isxdigit)
 AC_CHECK_FUNCS(getpwent getpwnam getpwuid)
 
@@ -161,7 +164,8 @@ AC_FUNC_STRCOLL
 AC_CHECK_HEADERS(fcntl.h unistd.h stdlib.h varargs.h stdarg.h stdbool.h \
 		string.h strings.h \
 		limits.h locale.h pwd.h memory.h termcap.h termios.h termio.h)
-AC_CHECK_HEADERS(sys/ioctl.h sys/pte.h sys/stream.h sys/select.h sys/file.h)
+AC_CHECK_HEADERS(sys/ioctl.h sys/pte.h sys/stream.h sys/select.h \
+		sys/time.h sys/file.h)
 
 AC_CHECK_HEADERS(sys/ptem.h,,,
 [[
@@ -178,14 +182,12 @@ BASH_SYS_REINSTALL_SIGHANDLERS
 BASH_FUNC_POSIX_SETJMP
 BASH_FUNC_LSTAT
 BASH_FUNC_STRCOLL
-BASH_FUNC_CTYPE_NONASCII
 
 BASH_CHECK_GETPW_FUNCS
 
 AC_HEADER_TIOCGWINSZ
 
 BASH_TYPE_SIG_ATOMIC_T
-BASH_TYPE_SIGHANDLER
 
 BASH_HAVE_TIOCSTAT
 BASH_HAVE_FIONREAD
@@ -193,6 +195,7 @@ BASH_CHECK_SPEED_T
 BASH_STRUCT_WINSIZE
 BASH_STRUCT_DIRENT_D_INO
 BASH_STRUCT_DIRENT_D_FILENO
+BASH_STRUCT_TIMEVAL
 
 AC_CHECK_HEADERS(libaudit.h)
 AC_CHECK_DECLS([AUDIT_USER_TTY],,, [[#include <linux/audit.h>]])
@@ -213,6 +216,10 @@ fi
 if test "$TERMCAP_LIB" = "-lncurses"; then
 	AC_CHECK_HEADERS(ncurses/termcap.h)
 fi
+case "$opt_shared_termcap_lib" in
+[[Yy]][[Ee]][[Ss]])	SHARED_TERMCAP="$TERMCAP_LIB" ;;
+-l*)		SHARED_TERMCAP="$opt_shared_termcap_lib" ;;
+esac
 
 case "$TERMCAP_LIB" in
 -ltinfo)  TERMCAP_PKG_CONFIG_LIB=tinfo ;;
@@ -243,10 +250,12 @@ if test -f ${srcdir}/support/shobj-conf; then
         AC_MSG_CHECKING(configuration for building shared libraries)
         eval `TERMCAP_LIB=$TERMCAP_LIB ${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c ${host_cpu} -o ${host_os} -v ${host_vendor}`
 
-#	case "$SHLIB_LIBS" in
-#	*curses*|*termcap*|*termlib*)	;;
-#	*)			SHLIB_LIBS="$SHLIB_LIBS $TERMCAP_LIB" ;;
-#	esac
+	# SHARED_TERMCAP is set only if opt_shared_termcap_library is set
+	case "$SHLIB_LIBS" in
+	*curses*|*tinfo*)	;;
+	*termcap*|*termlib*)	;;	# common aliases
+	*)		SHLIB_LIBS="$SHLIB_LIBS $SHARED_TERMCAP" ;;
+	esac
 	
         AC_SUBST(SHOBJ_CC)
         AC_SUBST(SHOBJ_CFLAGS)
@@ -310,6 +319,7 @@ esac
 
 AC_SUBST(BUILD_DIR)
 
+# CFLAGS=${CFLAGS-"$AUTO_CFLAGS"}
 if test -n "$want_auto_cflags"; then
 	CFLAGS="$AUTO_CFLAGS"
 fi
@@ -331,8 +341,9 @@ AC_SUBST(LIBVERSION)
 AC_SUBST(TERMCAP_LIB)
 AC_SUBST(TERMCAP_PKG_CONFIG_LIB)
 
-AC_OUTPUT([Makefile doc/Makefile examples/Makefile shlib/Makefile readline.pc],
-[
-# Makefile uses this timestamp file to record whether config.h is up to date.
-echo > stamp-h
-])
+AC_CONFIG_FILES([Makefile doc/Makefile examples/Makefile shlib/Makefile readline.pc history.pc])
+
+dnl Makefile uses this timestamp file to record whether config.h is up to date.
+AC_CONFIG_COMMANDS([stamp-h], [echo > stamp-h])
+
+AC_OUTPUT
diff --git a/readline/readline/display.c b/readline/readline/display.c
index 38b3d0e761369b3c7c71721c733af64805a72bb2..803d4cebadba81cf1c792da1bf6a6c726497c83f 100644
--- a/readline/readline/display.c
+++ b/readline/readline/display.c
@@ -1,6 +1,6 @@
 /* display.c -- readline redisplay facility. */
 
-/* Copyright (C) 1987-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2022 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library    
    for reading lines of text with interactive input and history editing.
@@ -63,23 +63,23 @@
 extern char *strchr (), *strrchr ();
 #endif /* !strchr && !__STDC__ */
 
-static void putc_face PARAMS((int, int, char *));
-static void puts_face PARAMS((const char *, const char *, int));
-static void norm_face PARAMS((char *, int));
+static void putc_face (int, int, char *);
+static void puts_face (const char *, const char *, int);
+static void norm_face (char *, int);
 
-static void update_line PARAMS((char *, char *, char *, char *, int, int, int, int));
-static void space_to_eol PARAMS((int));
-static void delete_chars PARAMS((int));
-static void insert_some_chars PARAMS((char *, int, int));
-static void open_some_spaces PARAMS((int));
-static void cr PARAMS((void));
-static void redraw_prompt PARAMS((char *));
-static void _rl_move_cursor_relative PARAMS((int, const char *, const char *));
+static void update_line (char *, char *, char *, char *, int, int, int, int);
+static void space_to_eol (int);
+static void delete_chars (int);
+static void insert_some_chars (char *, int, int);
+static void open_some_spaces (int);
+static void cr (void);
+static void redraw_prompt (char *);
+static void _rl_move_cursor_relative (int, const char *, const char *);
 
 /* Values for FLAGS */
 #define PMT_MULTILINE	0x01
 
-static char *expand_prompt PARAMS((char *, int, int *, int *, int *, int *));
+static char *expand_prompt (char *, int, int *, int *, int *, int *);
 
 #define DEFAULT_LINE_BUFFER_SIZE	1024
 
@@ -115,7 +115,7 @@ static int line_structures_initialized = 0;
 #define inv_face	(line_state_invisible->lface)
 
 #if defined (HANDLE_MULTIBYTE)
-static int _rl_col_width PARAMS((const char *, int, int, int));
+static int _rl_col_width (const char *, int, int, int);
 #else
 #  define _rl_col_width(l, s, e, f)	(((e) <= (s)) ? 0 : (e) - (s))
 #endif
@@ -356,7 +356,7 @@ expand_prompt (char *pmt, int flags, int *lp, int *lip, int *niflp, int *vlp)
 {
   char *r, *ret, *p, *igstart, *nprompt, *ms;
   int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;
-  int mlen, newlines, newlines_guess, bound;
+  int mlen, newlines, newlines_guess, bound, can_add_invis;
   int mb_cur_max;
 
   /* We only expand the mode string for the last line of a multiline prompt
@@ -372,6 +372,7 @@ expand_prompt (char *pmt, int flags, int *lp, int *lip, int *niflp, int *vlp)
   else
     nprompt = pmt;
 
+  can_add_invis = 0;
   mb_cur_max = MB_CUR_MAX;
 
   if (_rl_screenwidth == 0)
@@ -434,6 +435,19 @@ expand_prompt (char *pmt, int flags, int *lp, int *lip, int *niflp, int *vlp)
       else if (ignoring && *p == RL_PROMPT_END_IGNORE)
 	{
 	  ignoring = 0;
+	  /* If we have a run of invisible characters, adjust local_prompt_newlines
+	     to add them, since update_line expects them to be counted before
+	     wrapping the line. */
+	  if (can_add_invis)
+	    {
+	      local_prompt_newlines[newlines] = r - ret;
+	      /* If we're adding to the number of invisible characters on the
+		 first line of the prompt, but we've already set the number of
+		 invisible characters on that line, we need to adjust the
+		 counter. */
+	      if (invflset && newlines == 1)
+		invfl = ninvis;
+	    }
 	  if (p != (igstart + 1))
 	    last = r - ret - 1;
 	  continue;
@@ -498,10 +512,17 @@ expand_prompt (char *pmt, int flags, int *lp, int *lip, int *niflp, int *vlp)
 	        new = r - ret;
 	      local_prompt_newlines[++newlines] = new;
 	    }
+
+	  /* What if a physical character of width >= 2 is split? There is
+	     code that wraps before the physical screen width if the character
+	     width would exceed it, but it needs to be checked against this
+	     code and local_prompt_newlines[]. */
+	  if (ignoring == 0)
+	    can_add_invis = (physchars == bound); 
 	}
     }
 
-  if (rl < _rl_screenwidth)
+  if (rl <= _rl_screenwidth)
     invfl = ninvis;
 
   *r = '\0';
@@ -515,7 +536,7 @@ expand_prompt (char *pmt, int flags, int *lp, int *lip, int *niflp, int *vlp)
     *vlp = physchars;
 
   if (nprompt != pmt)
-    free (nprompt);
+    xfree (nprompt);
 
   return ret;
 }
@@ -749,7 +770,7 @@ rl_redisplay (void)
   int hl_begin, hl_end;
   int mb_cur_max = MB_CUR_MAX;
 #if defined (HANDLE_MULTIBYTE)
-  wchar_t wc;
+  WCHAR_T wc;
   size_t wc_bytes;
   int wc_width;
   mbstate_t ps;
@@ -983,11 +1004,11 @@ rl_redisplay (void)
       memset (&ps, 0, sizeof (mbstate_t));
       if (_rl_utf8locale && UTF8_SINGLEBYTE(rl_line_buffer[0]))
 	{
-	  wc = (wchar_t)rl_line_buffer[0];
+	  wc = (WCHAR_T)rl_line_buffer[0];
 	  wc_bytes = 1;
 	}
       else
-	wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);
+	wc_bytes = MBRTOWC (&wc, rl_line_buffer, rl_end, &ps);
     }
   else
     wc_bytes = 1;
@@ -1158,12 +1179,12 @@ rl_redisplay (void)
 	  in += wc_bytes;
 	  if (_rl_utf8locale && UTF8_SINGLEBYTE(rl_line_buffer[in]))
 	    {
-	      wc = (wchar_t)rl_line_buffer[in];
+	      wc = (WCHAR_T)rl_line_buffer[in];
 	      wc_bytes = 1;
 	      memset (&ps, 0, sizeof (mbstate_t));	/* re-init state */
 	    }
 	  else
-	    wc_bytes = mbrtowc (&wc, rl_line_buffer + in, rl_end - in, &ps);
+	    wc_bytes = MBRTOWC (&wc, rl_line_buffer + in, rl_end - in, &ps);
 	}
       else
         in++;
@@ -1582,9 +1603,9 @@ putc_face (int c, int face, char *cur_face)
       if (face != FACE_NORMAL && face != FACE_STANDOUT)
 	return;
       if (face == FACE_STANDOUT && cf == FACE_NORMAL)
-        _rl_standout_on ();
+	_rl_region_color_on ();
       if (face == FACE_NORMAL && cf == FACE_STANDOUT)
-        _rl_standout_off ();
+	_rl_region_color_off ();
       *cur_face = face;
     }
   if (c != EOF)
@@ -1598,7 +1619,7 @@ puts_face (const char *str, const char *face, int n)
   char cur_face;
 
   for (cur_face = FACE_NORMAL, i = 0; i < n; i++)
-    putc_face (str[i], face[i], &cur_face);
+    putc_face ((unsigned char) str[i], face[i], &cur_face);
   putc_face (EOF, FACE_NORMAL, &cur_face);
 }
 
@@ -1662,7 +1683,7 @@ update_line (char *old, char *old_face, char *new, char *new_face, int current_l
 #if defined (HANDLE_MULTIBYTE)
       if (mb_cur_max > 1 && rl_byte_oriented == 0)
 	{
-	  wchar_t wc;
+	  WCHAR_T wc;
 	  mbstate_t ps;
 	  int oldwidth, newwidth;
 	  int oldbytes, newbytes;
@@ -1681,7 +1702,7 @@ update_line (char *old, char *old_face, char *new, char *new_face, int current_l
 
 	  /* 1. how many screen positions does first char in old consume? */
 	  memset (&ps, 0, sizeof (mbstate_t));
-	  ret = mbrtowc (&wc, old, mb_cur_max, &ps);
+	  ret = MBRTOWC (&wc, old, mb_cur_max, &ps);
 	  oldbytes = ret;
 	  if (MB_INVALIDCH (ret))
 	    {
@@ -1697,7 +1718,7 @@ update_line (char *old, char *old_face, char *new, char *new_face, int current_l
 
 	  /* 2. how many screen positions does the first char in new consume? */
 	  memset (&ps, 0, sizeof (mbstate_t));
-	  ret = mbrtowc (&wc, new, mb_cur_max, &ps);
+	  ret = MBRTOWC (&wc, new, mb_cur_max, &ps);
 	  newbytes = ret;
 	  if (MB_INVALIDCH (ret))
 	    {
@@ -1718,7 +1739,7 @@ update_line (char *old, char *old_face, char *new, char *new_face, int current_l
 	    {
 	      int t;
 
-	      ret = mbrtowc (&wc, new+newbytes, mb_cur_max, &ps);
+	      ret = MBRTOWC (&wc, new+newbytes, mb_cur_max, &ps);
 	      if (MB_INVALIDCH (ret))
 		{
 		  newwidth += 1;
@@ -1740,7 +1761,7 @@ update_line (char *old, char *old_face, char *new, char *new_face, int current_l
 	    {
 	      int t;
 
-	      ret = mbrtowc (&wc, old+oldbytes, mb_cur_max, &ps);
+	      ret = MBRTOWC (&wc, old+oldbytes, mb_cur_max, &ps);
 	      if (MB_INVALIDCH (ret))
 		{
 		  oldwidth += 1;
@@ -1952,14 +1973,14 @@ update_line (char *old, char *old_face, char *new, char *new_face, int current_l
 #if defined (HANDLE_MULTIBYTE)
   if (mb_cur_max > 1 && rl_byte_oriented == 0 && _rl_utf8locale)
     {
-      wchar_t wc;
+      WCHAR_T wc;
       mbstate_t ps = { 0 };
       int t;
 
       /* If the first character in the difference is a zero-width character,
 	 assume it's a combining character and back one up so the two base
 	 characters no longer compare equivalently. */
-      t = mbrtowc (&wc, ofd, mb_cur_max, &ps);
+      t = MBRTOWC (&wc, ofd, mb_cur_max, &ps);
       if (t > 0 && UNICODE_COMBINING_CHAR (wc) && WCWIDTH (wc) == 0)
 	{
 	  old_offset = _rl_find_prev_mbchar (old, ofd - old, MB_FIND_ANY);
@@ -2421,9 +2442,24 @@ dumb_update:
 		((nfd-new) < (prompt_last_invisible-(current_line*_rl_screenwidth+prompt_invis_chars_first_line))))
 	    ADJUST_CPOS (wrap_offset - prompt_invis_chars_first_line);
 
-	  /* XXX - what happens if wrap_offset == prompt_invis_chars_first_line
-	     and we are drawing the first line (current_line == 0)? We should
-	     adjust by _rl_last_c_pos -= prompt_invis_chars_first_line */
+	  /* What happens if wrap_offset == prompt_invis_chars_first_line
+	     and we are drawing the first line (current_line == 0), or if we
+	     are drawing the first line and changing the number of invisible
+	     characters in the line? If we're starting to draw before the last
+	     invisible character in the prompt, we need to adjust by
+	     _rl_last_c_pos -= prompt_invis_chars_first_line. This can happen
+	     when we finish reading a digit argument (with the "(arg: N)"
+	     prompt) and are switching back to displaying a line with a prompt
+	     containing invisible characters, since we have to redraw the
+	     entire prompt string. */
+	  if ((mb_cur_max > 1 && rl_byte_oriented == 0) &&
+		current_line == 0 && wrap_offset &&
+		displaying_prompt_first_line &&
+		wrap_offset == prompt_invis_chars_first_line &&
+		visible_wrap_offset != current_invis_chars &&
+		visible_wrap_offset != prompt_invis_chars_first_line &&
+		((nfd-new) < prompt_last_invisible))
+	    ADJUST_CPOS (prompt_invis_chars_first_line);
 	}
     }
   else				/* Delete characters from line. */
@@ -2573,7 +2609,8 @@ rl_clear_visible_line (void)
   for (curr_line = _rl_last_v_pos; curr_line >= 0; curr_line--)
     {
       _rl_move_vert (curr_line);
-      _rl_clear_to_eol (0);
+      _rl_clear_to_eol (_rl_screenwidth);
+      _rl_cr ();		/* in case we use space_to_eol() */
     }
 
   return 0;
@@ -2646,11 +2683,8 @@ rl_forced_update_display (void)
   register char *temp;
 
   if (visible_line)
-    {
-      temp = visible_line;
-      while (*temp)
-	*temp++ = '\0';
-    }
+    memset (visible_line, 0, line_size);
+
   rl_on_new_line ();
   forced_display++;
   (*rl_redisplay_function) ();
@@ -3304,9 +3338,9 @@ _rl_update_final (void)
       puts_face (&last_line[_rl_screenwidth - 1 + woff],
 		 &last_face[_rl_screenwidth - 1 + woff], 1);
     }
-  _rl_vis_botlin = 0;
-  if (botline_length > 0 || _rl_last_c_pos > 0)
+  if ((_rl_vis_botlin == 0 && botline_length == 0) || botline_length > 0 || _rl_last_c_pos > 0)
     rl_crlf ();
+  _rl_vis_botlin = 0;
   fflush (rl_outstream);
   rl_display_fixed++;
 }
@@ -3357,27 +3391,16 @@ _rl_redisplay_after_sigwinch (void)
      screen line. */
   if (_rl_term_cr)
     {
-      _rl_move_vert (_rl_vis_botlin);
-
-      _rl_cr ();
-      _rl_last_c_pos = 0;
-
-#if !defined (__MSDOS__)
-      if (_rl_term_clreol)
-	tputs (_rl_term_clreol, 1, _rl_output_character_function);
-      else
-#endif
-	{
-	  space_to_eol (_rl_screenwidth);
-	  _rl_cr ();
-	}
-
+      rl_clear_visible_line ();
       if (_rl_last_v_pos > 0)
 	_rl_move_vert (0);
     }
   else
     rl_crlf ();
 
+  if (_rl_screenwidth < prompt_visible_length)
+    _rl_reset_prompt ();		/* update local_prompt_newlines array */
+
   /* Redraw only the last line of a multi-line prompt. */
   t = strrchr (rl_display_prompt, '\n');
   if (t)
@@ -3451,7 +3474,7 @@ _rl_refresh_line (void)
 static int
 _rl_col_width (const char *str, int start, int end, int flags)
 {
-  wchar_t wc;
+  WCHAR_T wc;
   mbstate_t ps;
   int tmp, point, width, max;
 
@@ -3520,10 +3543,10 @@ _rl_col_width (const char *str, int start, int end, int flags)
       if (_rl_utf8locale && UTF8_SINGLEBYTE(str[point]))
 	{
 	  tmp = 1;
-	  wc = (wchar_t) str[point];
+	  wc = (WCHAR_T) str[point];
 	}
       else
-	tmp = mbrtowc (&wc, str + point, max, &ps);
+	tmp = MBRTOWC (&wc, str + point, max, &ps);
       if (MB_INVALIDCH ((size_t)tmp))
 	{
 	  /* In this case, the bytes are invalid or too short to compose a
diff --git a/readline/readline/doc/Makefile.in b/readline/readline/doc/Makefile.in
index a38bc9eb4a876c181fd6f134e5f4211f77ad7177..20a36184f7508a9cc114275cf211eef3be042788 100644
--- a/readline/readline/doc/Makefile.in
+++ b/readline/readline/doc/Makefile.in
@@ -154,15 +154,16 @@ history.ps:	history.dvi
 # This leaves readline.html and rlman.html -- rlman.html is for www.gnu.org
 #
 readline.html:	${RLSRC}
-	$(TEXI2HTML) -menu -monolithic -I $(TEXINPUTDIR) $(srcdir)/rlman.texi
-	sed -e 's:rlman.html:readline.html:g' rlman.html > readline.html
-	$(RM) rlman.html
+	$(MAKEINFO) -o $@ --html --no-split -I$(TEXINPUTDIR) $(srcdir)/rlman.texi
+
+rlman.html:	${RLSRC}
+	$(MAKEINFO) -o $@ --html --no-split -I$(TEXINPUTDIR) $(srcdir)/rlman.texi
 
 rluserman.html:	${RLSRC}
-	$(TEXI2HTML) -menu -monolithic -I $(TEXINPUTDIR) $(srcdir)/rluserman.texi
+	$(MAKEINFO) --html --no-split -I$(TEXINPUTDIR) $(srcdir)/rluserman.texi
 
 history.html:	${HISTSRC}
-	$(TEXI2HTML) -menu -monolithic -I $(TEXINPUTDIR) $(srcdir)/history.texi
+	$(MAKEINFO) --html --no-split -I$(TEXINPUTDIR) $(srcdir)/history.texi
 
 readline.0: readline.3
 
diff --git a/readline/readline/doc/history.3 b/readline/readline/doc/history.3
index df6cd376c4763d5bae658bb9f626f7458d707452..06419cff564359ef8b3f633a1de83ca148bedfc3 100644
--- a/readline/readline/doc/history.3
+++ b/readline/readline/doc/history.3
@@ -291,7 +291,7 @@ in new commands.  The basic history manipulation commands are
 identical to
 the history substitution provided by \fBbash\fP.
 .PP
-The programmer can also use the Readline library, which
+The programmer can also use the readline library, which
 includes some history manipulation by default, and has the added
 advantage of command line editing.
 .PP
diff --git a/readline/readline/doc/history.texi b/readline/readline/doc/history.texi
index 7a3a4767e7a591ded5f14e0b4879cd4a28358e37..721118bce1e8bfb9a9bbf75da627c22fb5ef458e 100644
--- a/readline/readline/doc/history.texi
+++ b/readline/readline/doc/history.texi
@@ -12,7 +12,7 @@ This document describes the GNU History library
 a programming tool that provides a consistent user interface for
 recalling lines of previously typed input.
 
-Copyright @copyright{} 1988--2020 Free Software Foundation, Inc.
+Copyright @copyright{} 1988--2022 Free Software Foundation, Inc.
 
 @quotation
 Permission is granted to copy, distribute and/or modify this document
diff --git a/readline/readline/doc/hstech.texi b/readline/readline/doc/hstech.texi
index 7ac11953df304255a3f64424ab073656ab731e84..da6417b48fda487e24853fab3d7176912ba89e10 100644
--- a/readline/readline/doc/hstech.texi
+++ b/readline/readline/doc/hstech.texi
@@ -1,7 +1,7 @@
 @ignore
 This file documents the user interface to the GNU History library.
 
-Copyright (C) 1988-2020 Free Software Foundation, Inc.
+Copyright (C) 1988-2022 Free Software Foundation, Inc.
 Authored by Brian Fox and Chet Ramey.
 
 Permission is granted to make and distribute verbatim copies of this manual
diff --git a/readline/readline/doc/hsuser.texi b/readline/readline/doc/hsuser.texi
index 5e30ded7896e753141d6be32f54c90b82b2381f8..2d291763f200f760c41cea8f06b29811fded3035 100644
--- a/readline/readline/doc/hsuser.texi
+++ b/readline/readline/doc/hsuser.texi
@@ -1,7 +1,7 @@
 @ignore
 This file documents the user interface to the GNU History library.
 
-Copyright (C) 1988--2020 Free Software Foundation, Inc.
+Copyright (C) 1988--2022 Free Software Foundation, Inc.
 Authored by Brian Fox and Chet Ramey.
 
 Permission is granted to make and distribute verbatim copies of this manual
@@ -216,8 +216,9 @@ end of the history, and an index of @samp{-1} refers to the current
 @code{history -d} command.
 
 @item -d @var{start}-@var{end}
-Delete the history entries between positions @var{start} and @var{end},
-inclusive.  Positive and negative values for @var{start} and @var{end}
+Delete the range of history entries between positions @var{start} and
+@var{end}, inclusive.
+Positive and negative values for @var{start} and @var{end}
 are interpreted as described above.
 
 @item -a
@@ -247,10 +248,15 @@ the history list as a single entry.
 
 @end table
 
-When any of the @option{-w}, @option{-r}, @option{-a}, or @option{-n} options is
-used, if @var{filename}
-is given, then it is used as the history file.  If not, then
-the value of the @env{HISTFILE} variable is used.
+If a @var{filename} argument is supplied
+when any of the @option{-w}, @option{-r}, @option{-a}, or @option{-n} options
+is used, Bash uses @var{filename} as the history file.
+If not, then the value of the @env{HISTFILE} variable is used.
+
+The return value is 0 unless an invalid option is encountered, an
+error occurs while reading or writing the history file, an invalid
+@var{offset} or range is supplied as an argument to @option{-d}, or the
+history expansion supplied as an argument to @option{-p} fails.
 
 @end table
 @end ifset
@@ -509,7 +515,7 @@ substituted, or, if no previous history substitutions took place,
 the last @var{string}
 in a !?@var{string}@code{[?]}
 search.
-If @var{new} is is null, each matching @var{old} is deleted.
+If @var{new} is null, each matching @var{old} is deleted.
 The final delimiter is optional if it is the last
 character on the input line.
 
diff --git a/readline/readline/doc/readline.3 b/readline/readline/doc/readline.3
index 179c7814bcd384110e37df8e072a6841e08693f2..77ef02a6a9f8b70f829543cd9b97a421a07c90ab 100644
--- a/readline/readline/doc/readline.3
+++ b/readline/readline/doc/readline.3
@@ -6,9 +6,9 @@
 .\"	Case Western Reserve University
 .\"	chet.ramey@case.edu
 .\"
-.\"	Last Change: Tue Mar 24 09:27:30 EDT 2020
+.\"	Last Change: Mon Sep 19 11:11:22 EDT 2022
 .\"
-.TH READLINE 3 "2020 October 29" "GNU Readline 8.1"
+.TH READLINE 3 "2022 September 19" "GNU Readline 8.2"
 .\"
 .\" File Name macro.  This used to be `.PN', for Path Name,
 .\" but Sun doesn't seem to like that very much.
@@ -339,6 +339,30 @@ The variables and their default values are:
 .PP
 .PD 0
 .TP
+.B active\-region\-start\-color
+A string variable that controls the text color and background when displaying
+the text in the active region (see the description of
+\fBenable\-active\-region\fP below).
+This string must not take up any physical character positions on the display,
+so it should consist only of terminal escape sequences.
+It is output to the terminal before displaying the text in the active region.
+This variable is reset to the default value whenever the terminal type changes.
+The default value is the string that puts the terminal in standout mode,
+as obtained from the terminal's terminfo description.
+A sample value might be \f(CW"\ee[01;33m"\fP.
+.TP
+.B active\-region\-end\-color
+A string variable that "undoes" the effects of \fBactive\-region\-start\-color\fP
+and restores "normal" terminal display appearance after displaying text
+in the active region.
+This string must not take up any physical character positions on the display,
+so it should consist only of terminal escape sequences.
+It is output to the terminal after displaying the text in the active region.
+This variable is reset to the default value whenever the terminal type changes.
+The default value is the string that restores the terminal from standout mode,
+as obtained from the terminal's terminfo description.
+A sample value might be \f(CW"\ee[0m\fP".
+.TP
 .B bell\-style (audible)
 Controls what happens when readline wants to ring the terminal bell.
 If set to \fBnone\fP, readline never rings the bell.  If set to
@@ -359,6 +383,9 @@ If set to \fBOn\fP, when listing completions, readline displays the
 common prefix of the set of possible completions using a different color.
 The color definitions are taken from the value of the \fBLS_COLORS\fP
 environment variable.
+If there is a color definition in \fB$LS_COLORS\fP for the custom suffix
+"readline-colored-completion-prefix", readline uses this color for
+the common prefix instead of its default.
 .TP
 .B colored\-stats (Off)
 If set to \fBOn\fP, readline displays possible completions using different
@@ -408,7 +435,8 @@ If the number of possible completions is greater than
 or equal to the value of this variable,
 readline will ask whether or not the user wishes to view them;
 otherwise they are simply listed
-on the terminal.  A negative value causes readline to never ask.
+on the terminal.
+A negative value causes readline to never ask.
 .TP
 .B convert\-meta (On)
 If set to \fBOn\fP, readline will convert characters with the
@@ -417,6 +445,8 @@ by stripping the eighth bit and prefixing it with an
 escape character (in effect, using escape as the \fImeta prefix\fP).
 The default is \fIOn\fP, but readline will set it to \fIOff\fP if the
 locale contains eight-bit characters.
+This variable is dependent on the \fBLC_CTYPE\fP locale category, and 
+may change if the locale is changed.
 .TP
 .B disable\-completion (Off)
 If set to \fBOn\fP, readline will inhibit word completion.  Completion 
@@ -447,12 +477,25 @@ Use the \e1 and \e2 escapes to begin and end sequences of
 non-printing characters, which can be used to embed a terminal control 
 sequence into the mode string.
 .TP
+.B enable\-active\-region (On)
+The \fIpoint\fP is the current cursor position, and \fImark\fP refers
+to a saved cursor position.
+The text between the point and mark is referred to as the \fIregion\fP.
+When this variable is set to \fIOn\fP, readline allows certain commands
+to designate the region as \fIactive\fP.
+When the region is active, readline highlights the text in the region using
+the value of the \fBactive\-region\-start\-color\fP, which defaults to the
+string that enables
+the terminal's standout mode.
+The active region shows the text inserted by bracketed-paste and any
+matching text found by incremental and non-incremental history searches.
+.TP
 .B enable\-bracketed\-paste (On)
-When set to \fBOn\fP, readline will configure the terminal in a way
-that will enable it to insert each paste into the editing buffer as a
-single string of characters, instead of treating each character as if
-it had been read from the keyboard.  This can prevent pasted characters
-from being interpreted as editing commands.
+When set to \fBOn\fP, readline configures the terminal to insert each
+paste into the editing buffer as a single string of characters, instead
+of treating each character as if it had been read from the keyboard.
+This prevents readline from executing any editing commands bound to key
+sequences appearing in the pasted text.
 .TP
 .B enable\-keypad (Off)
 When set to \fBOn\fP, readline will try to enable the application
@@ -497,6 +540,8 @@ regardless of what the terminal claims it can support.  The name
 is a synonym for this variable.
 The default is \fIOff\fP, but readline will set it to \fIOn\fP if the 
 locale contains eight-bit characters.
+This variable is dependent on the \fBLC_CTYPE\fP locale category, and 
+may change if the locale is changed.
 .TP
 .B isearch\-terminators (``C\-[ C\-J'')
 The string of characters that should terminate an incremental
@@ -560,6 +605,8 @@ eighth bit set directly rather than as a meta-prefixed escape
 sequence.
 The default is \fIOff\fP, but readline will set it to \fIOn\fP if the
 locale contains eight-bit characters.
+This variable is dependent on the \fBLC_CTYPE\fP locale category, and
+may change if the locale is changed.
 .TP
 .B page\-completions (On)
 If set to \fBOn\fP, readline uses an internal \fImore\fP-like pager
@@ -803,14 +850,14 @@ composed of alphanumeric characters (letters and digits).
 .B previous\-screen\-line
 Attempt to move point to the same physical screen column on the previous
 physical screen line. This will not have the desired effect if the current
-Readline line does not take up more than one physical line or if point is not
+readline line does not take up more than one physical line or if point is not
 greater than the length of the prompt plus the screen width.
 .TP
 .B next\-screen\-line
 Attempt to move point to the same physical screen column on the next
 physical screen line. This will not have the desired effect if the current
-Readline line does not take up more than one physical line or if the length
-of the current Readline line is not greater than the length of the prompt
+readline line does not take up more than one physical line or if the length
+of the current readline line is not greater than the length of the prompt
 plus the screen width.
 .TP
 .B clear\-display (M\-C\-l)
@@ -853,6 +900,21 @@ Move to the first line in the history.
 Move to the end of the input history, i.e., the line currently being
 entered.
 .TP
+.B
+operate\-and\-get\-next (C\-o)
+Accept the current line for return to the calling application as if a
+newline had been entered,
+and fetch the next line relative to the current line from the history
+for editing.
+A numeric argument, if supplied, specifies the history entry to use instead
+of the current line.
+.TP
+.B
+fetch\-history
+With a numeric argument, fetch that entry from the history list
+and make it the current line.
+Without an argument, move back to the first entry in the history list.
+.TP
 .B reverse\-search\-history (C\-r)
 Search backward starting at the current line and moving `up' through
 the history as necessary.  This is an incremental search.
@@ -919,15 +981,6 @@ the direction to move through the history.  A negative argument switches
 the direction through the history (back or forward).
 The history expansion facilities are used to extract the last argument,
 as if the "!$" history expansion had been specified.
-.TP
-.B
-operate\-and\-get\-next (C\-o)
-Accept the current line for return to the calling application as if a
-newline had been entered,
-and fetch the next line relative to the current line from the history
-for editing.
-A numeric argument, if supplied, specifies the history entry to use instead
-of the current line.
 .PD
 .SS Commands for Changing Text
 .PD 0
@@ -937,7 +990,7 @@ The character indicating end-of-file as set, for example, by
 .if t \f(CWstty\fP.
 .if n ``stty''.
 If this character is read when there are no characters
-on the line, and point is at the beginning of the line, Readline
+on the line, and point is at the beginning of the line, readline
 interprets it as the end of input and returns
 .SM
 .BR EOF .
@@ -1206,11 +1259,11 @@ the saved position, and the old cursor position is saved as the mark.
 .TP
 .B character\-search (C\-])
 A character is read and point is moved to the next occurrence of that
-character.  A negative count searches for previous occurrences.
+character.  A negative argument searches for previous occurrences.
 .TP
 .B character\-search\-backward (M\-C\-])
 A character is read and point is moved to the previous occurrence of that
-character.  A negative count searches for subsequent occurrences.
+character.  A negative argument searches for subsequent occurrences.
 .TP
 .B skip\-csi\-sequence
 Read enough characters to consume a multi-key sequence such as those
diff --git a/readline/readline/doc/rlman.texi b/readline/readline/doc/rlman.texi
index ec7487b7a78812f10d236078f88fd1b431aa03c5..d046b87d1fbdfa5bcfe15cd8f64979104b56cadb 100644
--- a/readline/readline/doc/rlman.texi
+++ b/readline/readline/doc/rlman.texi
@@ -13,7 +13,7 @@ This manual describes the GNU Readline Library
 consistency of user interface across discrete programs which provide
 a command line interface.
 
-Copyright @copyright{} 1988--2020 Free Software Foundation, Inc.
+Copyright @copyright{} 1988--2022 Free Software Foundation, Inc.
 
 @quotation
 Permission is granted to copy, distribute and/or modify this document
diff --git a/readline/readline/doc/rltech.texi b/readline/readline/doc/rltech.texi
index 797e34d95e053fba57c5a1e25794a54ab0708c59..a93f77dabf81de0d9575aaf0947747f3f0bc96d5 100644
--- a/readline/readline/doc/rltech.texi
+++ b/readline/readline/doc/rltech.texi
@@ -7,7 +7,7 @@ This document describes the GNU Readline Library, a utility for aiding
 in the consistency of user interface across discrete programs that need
 to provide a command line interface.
 
-Copyright (C) 1988--2020 Free Software Foundation, Inc.
+Copyright (C) 1988--2022 Free Software Foundation, Inc.
 
 Permission is granted to make and distribute verbatim copies of
 this manual provided the copyright notice and this permission notice
@@ -393,7 +393,7 @@ value 0x0402.
 @end deftypevar
 
 @deftypevar {int} rl_gnu_readline_p
-Always set to 1, denoting that this is @sc{gnu} readline rather than some
+Always set to 1, denoting that this is @sc{gnu} Readline rather than some
 emulation.
 @end deftypevar
 
@@ -463,6 +463,11 @@ If non-zero, this is the address of a function to call if a read system
 call is interrupted when Readline is reading terminal input.
 @end deftypevar
 
+@deftypevar {rl_hook_func_t *} rl_timeout_event_hook
+If non-zero, this is the address of a function to call if Readline times
+out while reading input.
+@end deftypevar
+
 @deftypevar {rl_hook_func_t *} rl_input_available_hook
 If non-zero, Readline will use this function's return value when it needs
 to determine whether or not there is available input on the current input
@@ -510,7 +515,7 @@ By default, this is set to @code{rl_deprep_terminal}
 
 @deftypevar {Keymap} rl_executing_keymap
 This variable is set to the keymap (@pxref{Keymaps}) in which the
-currently executing readline function was found.
+currently executing Readline function was found.
 @end deftypevar 
 
 @deftypevar {Keymap} rl_binding_keymap
@@ -596,6 +601,10 @@ the current call to @code{readline()}.
 @item RL_STATE_DONE
 Readline has read a key sequence bound to @code{accept-line}
 and is about to return the line to the caller.
+@item RL_STATE_TIMEOUT
+Readline has timed out (it did not receive a line or specified number of
+characters before the timeout duration specified by @code{rl_set_timeout}
+elapsed) and is returning that status to the caller.
 @item RL_STATE_EOF
 Readline has read an EOF character (e.g., the stty @samp{EOF} character)
 or encountered a read error and is about to return a NULL line to the caller.
@@ -887,6 +896,15 @@ It takes a "translated" key sequence and should be used if the key sequence
 can include NUL.
 @end deftypefun
 
+@deftypefun {int} rl_trim_arg_from_keyseq (const char *keyseq, size_t len, Keymap map)
+If there is a numeric argument at the beginning of @var{keyseq}, possibly
+including digits, return the index of the first character in @var{keyseq}
+following the numeric argument.
+This can be used to skip over the numeric argument (which is available as
+@code{rl_numeric_arg} while traversing the key sequence that invoked the
+current command.
+@end deftypefun
+
 @deftypefun {char **} rl_invoking_keyseqs (rl_command_func_t *function)
 Return an array of strings representing the key sequences used to
 invoke @var{function} in the current keymap.
@@ -898,7 +916,7 @@ invoke @var{function} in the keymap @var{map}.
 @end deftypefun
 
 @deftypefun void rl_function_dumper (int readable)
-Print the readline function names and the key sequences currently
+Print the Readline function names and the key sequences currently
 bound to them to @code{rl_outstream}.  If @var{readable} is non-zero,
 the list is formatted in such a way that it can be made part of an
 @code{inputrc} file and re-read.
@@ -1074,8 +1092,9 @@ It returns the number of visible characters on the last line of the
 Applications may indicate that the prompt contains characters that take
 up no physical screen space when displayed by bracketing a sequence of
 such characters with the special markers @code{RL_PROMPT_START_IGNORE}
-and @code{RL_PROMPT_END_IGNORE} (declared in @file{readline.h}).  This may
-be used to embed terminal-specific escape sequences in prompts.
+and @code{RL_PROMPT_END_IGNORE} (declared in @file{readline.h} as
+@samp{\001} and @samp{\002}, respectively).
+This may be used to embed terminal-specific escape sequences in prompts.
 @end deftypefun
 
 @deftypefun int rl_set_prompt (const char *prompt)
@@ -1162,6 +1181,30 @@ The default waiting period is one-tenth of a second.
 Returns the old timeout value.
 @end deftypefun
 
+@deftypefun int rl_set_timeout (unsigned int secs, unsigned int usecs)
+Set a timeout for subsequent calls to @code{readline()}. If Readline does
+not read a complete line, or the number of characters specified by
+@code{rl_num_chars_to_read}, before the duration specified by @var{secs}
+(in seconds) and @var{usecs} (microseconds), it returns and sets
+@code{RL_STATE_TIMEOUT} in @code{rl_readline_state}.
+Passing 0 for @code{secs} and @code{usecs} cancels any previously set
+timeout; the convenience macro @code{rl_clear_timeout()} is shorthand
+for this.
+Returns 0 if the timeout is set successfully.
+@end deftypefun
+
+@deftypefun int rl_timeout_remaining (unsigned int *secs, unsigned int *usecs)
+Return the number of seconds and microseconds remaining in the current
+timeout duration in @var{*secs} and @var{*usecs}, respectively.
+Both @var{*secs} and @var{*usecs} must be non-NULL to return any values.
+The return value is -1 on error or when there is no timeout set,
+0 when the timeout has expired (leaving @var{*secs} and @var{*usecs}
+unchanged),
+and 1 if the timeout has not expired.
+If either of @var{secs} and @var{usecs} is @code{NULL},
+the return value indicates whether the timeout has expired.
+@end deftypefun
+
 @node Terminal Management
 @subsection Terminal Management
 
@@ -1315,7 +1358,7 @@ that it can be made part of an @code{inputrc} file and re-read.
 
 @deftypefun int rl_variable_bind (const char *variable, const char *value)
 Make the Readline variable @var{variable} have @var{value}.
-This behaves as if the readline command
+This behaves as if the Readline command
 @samp{set @var{variable} @var{value}} had been executed in an @code{inputrc}
 file (@pxref{Readline Init File Syntax}).
 @end deftypefun
@@ -1326,7 +1369,7 @@ For boolean variables, this string is either @samp{on} or @samp{off}.
 @end deftypefun
 
 @deftypefun void rl_variable_dumper (int readable)
-Print the readline variable names and their current values
+Print the Readline variable names and their current values
 to @code{rl_outstream}.
 If @var{readable} is non-zero, the list is formatted in such a way
 that it can be made part of an @code{inputrc} file and re-read.
@@ -1357,7 +1400,7 @@ Readline saves in the history list.
 Enable an @emph{active} mark.
 When this is enabled, the text between point and mark (the @var{region}) is
 displayed in the terminal's standout mode (a @var{face}).
-This is called by various readline functions that set the mark and insert
+This is called by various Readline functions that set the mark and insert
 text, and is available for applications to call.
 @end deftypefun
 
@@ -1366,10 +1409,10 @@ Turn off the active mark.
 @end deftypefun
 
 @deftypefun {void} rl_keep_mark_active (void)
-Indicate that the mark should remain active when the current readline function
-completes and after redisplay occurs.
+Indicate that the mark should remain active when the current Readline
+function completes and after redisplay occurs.
 In most cases, the mark remains active for only the duration of a single
-bindable readline function.
+bindable Readline function.
 @end deftypefun
 
 @deftypefun {int} rl_mark_active_p (void)
@@ -1382,12 +1425,12 @@ Return a non-zero value if the mark is currently active; zero otherwise.
 An alternate interface is available to plain @code{readline()}.  Some
 applications need to interleave keyboard I/O with file, device, or
 window system I/O, typically by using a main loop to @code{select()}
-on various file descriptors.  To accommodate this need, readline can
+on various file descriptors.  To accommodate this need, Readline can
 also be invoked as a `callback' function from an event loop.  There
 are functions available to make this easy.
 
 @deftypefun void rl_callback_handler_install (const char *prompt, rl_vcpfunc_t *lhandler)
-Set up the terminal for readline I/O and display the initial
+Set up the terminal for Readline I/O and display the initial
 expanded value of @var{prompt}.  Save the value of @var{lhandler} to
 use as a handler function to call when a complete line of input has been
 entered.
@@ -1622,7 +1665,7 @@ main (int c, char **v)
 
 Signals are asynchronous events sent to a process by the Unix kernel,
 sometimes on behalf of another process.  They are intended to indicate
-exceptional events, like a user pressing the interrupt key on his terminal,
+exceptional events, like a user pressing the terminal's interrupt key,
 or a network connection being broken.  There is a class of signals that can
 be sent to the process currently reading input from the keyboard.  Since
 Readline changes the terminal attributes when it is called, it needs to
@@ -1772,7 +1815,7 @@ a @code{SIGWINCH}.
 
 @deftypefun void rl_echo_signal_char (int sig)
 If an application wishes to install its own signal handlers, but still
-have readline display characters that generate signals, calling this
+have Readline display characters that generate signals, calling this
 function with @var{sig} set to @code{SIGINT}, @code{SIGQUIT}, or
 @code{SIGTSTP} will display the character generating that signal.
 @end deftypefun
@@ -2170,9 +2213,10 @@ shell variables and hostnames.
 
 @deftypevar int rl_completion_query_items
 Up to this many items will be displayed in response to a
-possible-completions call.  After that, readline asks the user if she is sure
-she wants to see them all.  The default value is 100.  A negative value 
-indicates that Readline should never ask the user.
+possible-completions call.  After that, Readline asks the user for
+confirmation before displaying them.
+The default value is 100.  A negative value 
+indicates that Readline should never ask for confirmation.
 @end deftypevar
 
 @deftypevar {int} rl_completion_append_character
@@ -2324,6 +2368,7 @@ history list.
 #include <fcntl.h>
 #include <stdio.h>
 #include <errno.h>
+#include <locale.h>
 
 #if defined (HAVE_STRING_H)
 #  include <string.h>
@@ -2404,6 +2449,8 @@ main (argc, argv)
 @{
   char *line, *s;
 
+  setlocale (LC_ALL, "");
+
   progname = argv[0];
 
   initialize_readline ();	/* Bind our completer. */
diff --git a/readline/readline/doc/rluser.texi b/readline/readline/doc/rluser.texi
index 26b0ff072c7a8503f3e9e567ca4cfecdd3dcc506..cbcbb45cf4c033aeac748bf44debb78ce392e2a2 100644
--- a/readline/readline/doc/rluser.texi
+++ b/readline/readline/doc/rluser.texi
@@ -9,7 +9,7 @@ use these features.  There is a document entitled "readline.texinfo"
 which contains both end-user and programmer documentation for the
 GNU Readline Library.
 
-Copyright (C) 1988--2020 Free Software Foundation, Inc.
+Copyright (C) 1988--2022 Free Software Foundation, Inc.
 
 Authored by Brian Fox and Chet Ramey.
 
@@ -179,7 +179,7 @@ empty line.
 @end table
 
 @noindent
-(Depending on your configuration, the @key{Backspace} key be set to
+(Depending on your configuration, the @key{Backspace} key might be set to
 delete the character to the left of the cursor and the @key{DEL} key set
 to delete the character underneath the cursor, like @kbd{C-d}, rather
 than the character to the left of the cursor.)
@@ -246,7 +246,7 @@ words, to the end of the next word.
 Word boundaries are the same as those used by @kbd{M-f}.
 
 @item M-@key{DEL}
-Kill from the cursor the start of the current word, or, if between
+Kill from the cursor to the start of the current word, or, if between
 words, to the start of the previous word.
 Word boundaries are the same as those used by @kbd{M-b}.
 
@@ -339,7 +339,8 @@ Although the Readline library comes with a set of Emacs-like
 keybindings installed by default, it is possible to use a different set
 of keybindings.
 Any user can customize programs that use Readline by putting
-commands in an @dfn{inputrc} file, conventionally in his home directory.
+commands in an @dfn{inputrc} file,
+conventionally in their home directory.
 The name of this
 @ifset BashFeatures
 file is taken from the value of the shell variable @env{INPUTRC}.  If
@@ -418,6 +419,32 @@ variables.
 @cindex variables, readline
 @table @code
 
+@item active-region-start-color
+@vindex active-region-start-color
+A string variable that controls the text color and background when displaying
+the text in the active region (see the description of
+@code{enable-active-region} below).
+This string must not take up any physical character positions on the display,
+so it should consist only of terminal escape sequences.
+It is output to the terminal before displaying the text in the active region.
+This variable is reset to the default value whenever the terminal type changes.
+The default value is the string that puts the terminal in standout mode,
+as obtained from the terminal's terminfo description.
+A sample value might be @samp{\e[01;33m}.
+
+@item active-region-end-color
+@vindex active-region-end-color
+A string variable that "undoes" the effects of @code{active-region-start-color}
+and restores "normal" terminal display appearance after displaying text
+in the active region.
+This string must not take up any physical character positions on the display,
+so it should consist only of terminal escape sequences.
+It is output to the terminal after displaying the text in the active region.
+This variable is reset to the default value whenever the terminal type changes.
+The default value is the string that restores the terminal from standout mode,
+as obtained from the terminal's terminfo description.
+A sample value might be @samp{\e[0m}.
+
 @item bell-style
 @vindex bell-style
 Controls what happens when Readline wants to ring the terminal bell.
@@ -444,6 +471,9 @@ If set to @samp{on}, when listing completions, Readline displays the
 common prefix of the set of possible completions using a different color.
 The color definitions are taken from the value of the @env{LS_COLORS}
 environment variable.
+If there is a color definition in @env{LS_COLORS} for the custom suffix
+@samp{readline-colored-completion-prefix}, Readline uses this color for
+the common prefix instead of its default.
 The default is @samp{off}.
 
 @item colored-stats
@@ -496,8 +526,9 @@ asked whether the list of possibilities should be displayed.
 If the number of possible completions is greater than or equal to this value,
 Readline will ask whether or not the user wishes to view them;
 otherwise, they are simply listed.
-This variable must be set to an integer value greater than or equal to 0.
-A negative value means Readline should never ask.
+This variable must be set to an integer value greater than or equal to zero.
+A zero value means Readline should never ask; negative values are
+treated as zero.
 The default limit is @code{100}.
 
 @item convert-meta
@@ -505,9 +536,12 @@ The default limit is @code{100}.
 If set to @samp{on}, Readline will convert characters with the
 eighth bit set to an @sc{ascii} key sequence by stripping the eighth
 bit and prefixing an @key{ESC} character, converting them to a
-meta-prefixed key sequence.  The default value is @samp{on}, but
+meta-prefixed key sequence.
+The default value is @samp{on}, but
 will be set to @samp{off} if the locale is one that contains
 eight-bit characters.
+This variable is dependent on the @code{LC_CTYPE} locale category, and
+may change if the locale is changed.
 
 @item disable-completion
 @vindex disable-completion
@@ -518,7 +552,7 @@ been mapped to @code{self-insert}.  The default is @samp{off}.
 @item echo-control-characters
 @vindex echo-control-characters
 When set to @samp{on}, on operating systems that indicate they support it,
-readline echoes a character corresponding to a signal generated from the
+Readline echoes a character corresponding to a signal generated from the
 keyboard.  The default is @samp{on}.
 
 @item editing-mode
@@ -540,13 +574,30 @@ non-printing characters, which can be used to embed a terminal control
 sequence into the mode string.
 The default is @samp{@@}.
 
+@item enable-active-region
+@vindex enable-active-region
+The @dfn{point} is the current cursor position, and @dfn{mark} refers
+to a saved cursor position (@pxref{Commands For Moving}).
+The text between the point and mark is referred to as the @dfn{region}.
+When this variable is set to @samp{On}, Readline allows certain commands
+to designate the region as @dfn{active}.
+When the region is active, Readline highlights the text in the region using
+the value of the @code{active-region-start-color}, which defaults to the
+string that enables
+the terminal's standout mode.
+The active region shows the text inserted by bracketed-paste and any
+matching text found by incremental and non-incremental history searches.
+The default is @samp{On}.
+
 @item enable-bracketed-paste
 @vindex enable-bracketed-paste
-When set to @samp{On}, Readline will configure the terminal in a way
-that will enable it to insert each paste into the editing buffer as a
-single string of characters, instead of treating each character as if
-it had been read from the keyboard.  This can prevent pasted characters
-from being interpreted as editing commands.  The default is @samp{On}.
+When set to @samp{On}, Readline configures the terminal to insert each
+paste into the editing buffer as a single string of characters, instead
+of treating each character as if it had been read from the keyboard.
+This is called putting the terminal into @dfn{bracketed paste mode};
+it prevents Readline from executing any editing commands bound to key
+sequences appearing in the pasted text.
+The default is @samp{On}.
 
 @item enable-keypad
 @vindex enable-keypad
@@ -601,6 +652,8 @@ regardless of what the terminal claims it can support.  The
 default value is @samp{off}, but Readline will set it to @samp{on} if the 
 locale contains eight-bit characters.
 The name @code{meta-flag} is a synonym for this variable.
+This variable is dependent on the @code{LC_CTYPE} locale category, and
+may change if the locale is changed.
 
 @item isearch-terminators
 @vindex isearch-terminators
@@ -683,6 +736,8 @@ eighth bit set directly rather than as a meta-prefixed escape
 sequence.
 The default is @samp{off}, but Readline will set it to @samp{on} if the
 locale contains eight-bit characters.
+This variable is dependent on the @code{LC_CTYPE} locale category, and
+may change if the locale is changed.
 
 @item page-completions
 @vindex page-completions
@@ -700,7 +755,7 @@ The default is @samp{off}.
 If set to @samp{on}, Readline will undo all changes to history lines
 before returning when @code{accept-line} is executed.  By default,
 history lines may be modified and retain individual undo lists across
-calls to @code{readline}.  The default is @samp{off}.
+calls to @code{readline()}.  The default is @samp{off}.
 
 @item show-all-if-ambiguous
 @vindex show-all-if-ambiguous
@@ -732,7 +787,7 @@ The default value is @samp{off}.
 @vindex skip-completed-text
 If set to @samp{on}, this alters the default completion behavior when
 inserting a single match into the line.  It's only active when
-performing completion in the middle of a word.  If enabled, readline
+performing completion in the middle of a word.  If enabled, Readline
 does not insert characters from the completion that match characters
 after point in the word being completed, so portions of the word
 following the cursor are not duplicated.
@@ -792,12 +847,12 @@ interpreted as part of the key name.
 The name of the key can be expressed in different ways, depending on
 what you find most comfortable.
 
-In addition to command names, readline allows keys to be bound
+In addition to command names, Readline allows keys to be bound
 to a string that is inserted when the key is pressed (a @var{macro}).
 
 @ifset BashFeatures
 The @w{@code{bind -p}} command displays Readline function names and
-bindings in a format that can put directly into an initialization file.
+bindings in a format that can be put directly into an initialization file.
 @xref{Bash Builtins}.
 @end ifset
 
@@ -1332,6 +1387,11 @@ for editing.
 A numeric argument, if supplied, specifies the history entry to use instead
 of the current line.
 
+@item fetch-history ()
+With a numeric argument, fetch that entry from the history list
+and make it the current line.
+Without an argument, move back to the first entry in the history list.
+
 @end ftable
 
 @node Commands For Text
@@ -1668,7 +1728,7 @@ Re-execute the last keyboard macro defined, by making the characters
 in the macro appear as if typed at the keyboard.
 
 @item print-last-kbd-macro ()
-Print the last keboard macro defined in a format suitable for the
+Print the last keyboard macro defined in a format suitable for the
 @var{inputrc} file.
 
 @end ftable
@@ -1721,11 +1781,11 @@ the saved position, and the old cursor position is saved as the mark.
 
 @item character-search (C-])
 A character is read and point is moved to the next occurrence of that
-character.  A negative count searches for previous occurrences.
+character.  A negative argument searches for previous occurrences.
 
 @item character-search-backward (M-C-])
 A character is read and point is moved to the previous occurrence
-of that character.  A negative count searches for subsequent
+of that character.  A negative argument searches for subsequent
 occurrences.
 
 @item skip-csi-sequence ()
@@ -1733,7 +1793,7 @@ Read enough characters to consume a multi-key sequence such as those
 defined for keys like Home and End.  Such sequences begin with a
 Control Sequence Indicator (CSI), usually ESC-[.  If this sequence is
 bound to "\e[", keys producing such sequences will have no effect
-unless explicitly bound to a readline command, instead of inserting
+unless explicitly bound to a Readline command, instead of inserting
 stray characters into the editing buffer.  This is unbound by default,
 but usually bound to ESC-[.
 
@@ -1772,6 +1832,11 @@ the output is formatted in such a way that it can be made part
 of an @var{inputrc} file.  This command is unbound by default.
 
 @ifset BashFeatures
+@item spell-correct-word (C-x s)
+Perform spelling correction on the current word, treating it as a directory
+or filename, in the same way as the @code{cdspell} shell option.
+Word boundaries are the same as those used by @code{shell-forward-word}.
+
 @item glob-complete-word (M-g)
 The word before point is treated as a pattern for pathname expansion,
 with an asterisk implicitly appended.  This pattern is used to
@@ -2224,6 +2289,7 @@ Names of all shell variables.  May also be specified as @option{-v}.
 @item -C @var{command}
 @var{command} is executed in a subshell environment, and its output is
 used as the possible completions.
+Arguments are passed as with the @option{-F} option.
 
 @item -F @var{function}
 The shell function @var{function} is executed in the current shell
@@ -2401,7 +2467,7 @@ via @var{CDPATH}: Readline can't tell those completions are directories).
 The @option{-o nospace} option tells Readline to not append a space
 character to the directory name, in case we want to append to it.
 The @option{-o bashdefault} option brings in the rest of the "Bash default"
-completions -- possible completion that Bash adds to the default Readline
+completions -- possible completions that Bash adds to the default Readline
 set.  These include things like command name completion, variable completion
 for words beginning with @samp{$} or @samp{$@{}, completions containing pathname
 expansion patterns (@pxref{Filename Expansion}), and so on.
diff --git a/readline/readline/doc/rluserman.texi b/readline/readline/doc/rluserman.texi
index 6e8e848b6e5ae993259eb3a964e8573fe3a73fc5..ae9ec6eb4f8f267d80202adccfe193aa622b7fd1 100644
--- a/readline/readline/doc/rluserman.texi
+++ b/readline/readline/doc/rluserman.texi
@@ -12,7 +12,7 @@ This manual describes the end user interface of the GNU Readline Library
 consistency of user interface across discrete programs which provide
 a command line interface.
 
-Copyright @copyright{} 1988--2020 Free Software Foundation, Inc.
+Copyright @copyright{} 1988--2022 Free Software Foundation, Inc.
 
 @quotation
 Permission is granted to copy, distribute and/or modify this document
diff --git a/readline/readline/doc/texi2dvi b/readline/readline/doc/texi2dvi
old mode 100755
new mode 100644
diff --git a/readline/readline/doc/texi2html b/readline/readline/doc/texi2html
old mode 100755
new mode 100644
diff --git a/readline/readline/doc/version.texi b/readline/readline/doc/version.texi
index abb9cb6ba573493530f878612d271b4c80848fce..d310273405152877ce211fe53d644851f6fad667 100644
--- a/readline/readline/doc/version.texi
+++ b/readline/readline/doc/version.texi
@@ -1,10 +1,11 @@
 @ignore
-Copyright (C) 1988-2020 Free Software Foundation, Inc. 
+Copyright (C) 1988-2022 Free Software Foundation, Inc. 
 @end ignore
 
-@set EDITION 8.1
-@set VERSION 8.1
-@set UPDATED 29 October 2020
-@set UPDATED-MONTH October 2020
+@set EDITION 8.2
+@set VERSION 8.2
 
-@set LASTCHANGE Thu Oct 29 16:49:01 EDT 2020
+@set UPDATED 19 September 2022
+@set UPDATED-MONTH September 2022
+
+@set LASTCHANGE Mon Sep 19 11:15:16 EDT 2022
diff --git a/readline/readline/examples/Makefile.in b/readline/readline/examples/Makefile.in
index 4a7c39e0a4fb306dd2b1e3f1c10fc080183fd885..291c6b7adf8256de95e0ab47a806c199bd284cc3 100644
--- a/readline/readline/examples/Makefile.in
+++ b/readline/readline/examples/Makefile.in
@@ -72,17 +72,17 @@ TERMCAP_LIB = @TERMCAP_LIB@
 SOURCES = excallback.c fileman.c histexamp.c manexamp.c rl-fgets.c rl.c \
 		rlbasic.c rlcat.c rlevent.c rlptytest.c rltest.c rlversion.c \
 		rltest2.c rl-callbacktest.c hist_erasedups.c hist_purgecmd.c \
-		rlkeymaps.c
+		rlkeymaps.c rl-timeout.c
 
 EXECUTABLES = fileman$(EXEEXT) rltest$(EXEEXT) rl$(EXEEXT) rlcat$(EXEEXT) \
 		rlevent$(EXEEXT) rlversion$(EXEEXT) histexamp$(EXEEXT) \
 		rl-callbacktest$(EXEEXT) rlbasic$(EXEEXT) \
 		hist_erasedups$(EXEEXT) hist_purgecmd$(EXEEXT) \
-		rlkeymaps$(EXEEXT)
+		rlkeymaps$(EXEEXT) rl-timeout$(EXEEXT)
 
 OBJECTS = fileman.o rltest.o rl.o rlevent.o rlcat.o rlversion.o histexamp.o \
 	  rltest2.o rl-callbacktest.o rlbasic.o hist_erasedups.o hist_purgecmd.o \
-	  rlkeymaps.o
+	  rlkeymaps.o rl-timeout.o
 
 OTHEREXE = rlptytest$(EXEEXT)
 OTHEROBJ = rlptytest.o
@@ -141,6 +141,9 @@ rl-callbacktest$(EXEEXT): rl-callbacktest.o $(READLINE_LIB)
 rlptytest$(EXEEXT): rlptytest.o $(READLINE_LIB)
 	$(CC) $(LDFLAGS) -o $@ rlptytest.o $(READLINE_LIB) $(TERMCAP_LIB) $(LIBUTIL)
 
+rl-timeout$(EXEEXT): rl-timeout.o $(READLINE_LIB)
+	$(CC) $(LDFLAGS) -o $@ rl-timeout.o $(READLINE_LIB) $(TERMCAP_LIB)
+
 rlversion$(EXEEXT): rlversion.o $(READLINE_LIB)
 	$(CC) $(LDFLAGS) -o $@ rlversion.o $(READLINE_LIB) $(TERMCAP_LIB)
 
@@ -173,6 +176,7 @@ rlkeymaps.o: rlkeymaps.c
 rlcat.o: rlcat.c
 rlptytest.o: rlptytest.c
 rl-callbacktest.o: rl-callbacktest.c
+rl-timeout.o: rl-timeout.c
 
 fileman.o: $(top_srcdir)/readline.h
 rltest.o: $(top_srcdir)/readline.h
@@ -186,3 +190,4 @@ rlbasic.o: $(top_srcdir)/readline.h $(top_srcdir)/history.h
 rlcat.o: $(top_srcdir)/readline.h $(top_srcdir)/history.h
 rlptytest.o: $(top_srcdir)/readline.h $(top_srcdir)/history.h
 rl-callbacktest.o: $(top_srcdir)/readline.h $(top_srcdir)/history.h
+rl-timeout.o: $(top_srcdir)/readline.h $(top_srcdir)/history.h
diff --git a/readline/readline/examples/excallback.c b/readline/readline/examples/excallback.c
index 4206acfca4a518c8081d1e5389e2fdcb1b51bb8c..923c9238b6ecaf9d799171ec6aa9002f4089c1a5 100644
--- a/readline/readline/examples/excallback.c
+++ b/readline/readline/examples/excallback.c
@@ -50,6 +50,8 @@ Copyright (C) 1999 Jeff Solomon
 #include <stdio.h>
 #include <termios.h>	/* xxx - should make this more general */
 
+#include <locale.h>
+
 #ifdef READLINE_LIBRARY
 #  include "readline.h"
 #else
@@ -104,6 +106,8 @@ main()
 {
     fd_set fds;
 
+    setlocale (LC_ALL, "");
+
     /* Adjust the terminal slightly before the handler is installed. Disable
      * canonical mode processing and set the input character time flag to be
      * non-blocking.
diff --git a/readline/readline/examples/fileman.c b/readline/readline/examples/fileman.c
index f8d0be73eef1cba00906cb919b133783063c66a0..2a8b097ad146b74abce85369c906a6cf426280ac 100644
--- a/readline/readline/examples/fileman.c
+++ b/readline/readline/examples/fileman.c
@@ -417,7 +417,7 @@ com_help (arg)
 
   if (!printed)
     {
-      printf ("No commands match `%s'.  Possibilties are:\n", arg);
+      printf ("No commands match `%s'.  Possibilities are:\n", arg);
 
       for (i = 0; commands[i].name; i++)
         {
diff --git a/readline/readline/examples/rl-callbacktest.c b/readline/readline/examples/rl-callbacktest.c
index 3525ffd99935c4d3e841a1a69ca703adede08451..7febacd14c47f69ddc9f71cfbc2d6e9b6791b8b8 100644
--- a/readline/readline/examples/rl-callbacktest.c
+++ b/readline/readline/examples/rl-callbacktest.c
@@ -2,7 +2,6 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
-#include <locale.h>
 
 /* Used for select(2) */
 #include <sys/types.h>
@@ -13,6 +12,8 @@
 #include <errno.h>
 #include <stdio.h>
 
+#include <locale.h>
+
 /* Standard readline include files. */
 #if defined (READLINE_LIBRARY)
 #  include "readline.h"
@@ -72,7 +73,6 @@ main (int c, char **v)
   fd_set fds;
   int r;
 
-
   setlocale (LC_ALL, "");
 
   /* Handle SIGWINCH */
diff --git a/readline/readline/examples/rl-test-timeout b/readline/readline/examples/rl-test-timeout
new file mode 100644
index 0000000000000000000000000000000000000000..2c9de1a7b41bbb2e2560ea7c9e3bfff0e33a117c
--- /dev/null
+++ b/readline/readline/examples/rl-test-timeout
@@ -0,0 +1,6 @@
+./rl-timeout readline1 0.5
+./rl-timeout readline2 0.25
+
+./rl-timeout callback1 0.5
+./rl-timeout callback2 0.5
+
diff --git a/readline/readline/examples/rl-timeout.c b/readline/readline/examples/rl-timeout.c
new file mode 100644
index 0000000000000000000000000000000000000000..b8a24bafb94fcd8670a73ba977f8ca6eaf6e0907
--- /dev/null
+++ b/readline/readline/examples/rl-timeout.c
@@ -0,0 +1,245 @@
+/* rl-timeout: test various readline builtin timeouts. */
+
+/* Copyright (C) 2021 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library (Readline), a library for
+   reading lines of text with interactive input and history editing.
+
+   Readline is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   Readline is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with readline.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/* Standard include files. stdio.h is required. */
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <limits.h>
+
+/* Used for select(2) */
+#include <sys/types.h>
+#include <sys/select.h>
+
+#include <errno.h>
+#include <stdio.h>
+
+/* Standard readline include files. */
+#if defined (READLINE_LIBRARY)
+#  include "readline.h"
+#  include "history.h"
+#else
+#  include <readline/readline.h>
+#  include <readline/history.h>
+#endif
+
+extern int errno;
+
+static void cb_linehandler (char *);
+
+int timeout_secs = 1, timeout_usecs = 0;
+int running;
+const char *prompt = "rl-timeout$ ";
+
+/* **************************************************************** */
+/*								    */
+/* Example 1: readline () with rl_readline_state		    */
+/*								    */
+/* **************************************************************** */
+
+void
+rltest_timeout_readline1 ()
+{
+  const char *temp;
+
+  rl_set_timeout (timeout_secs, timeout_usecs);
+  temp = readline (prompt);
+  if (RL_ISSTATE (RL_STATE_TIMEOUT))
+    printf ("timeout\n");
+  else if (temp == NULL)
+    printf ("no input line\n");
+  else
+    printf ("input line: %s\n", temp);
+  free ((void *) temp);
+}
+
+/* **************************************************************** */
+/*								    */
+/* Example 2: readline () with rl_timeout_event_hook		    */
+/*								    */
+/* **************************************************************** */
+
+static int
+timeout_handler ()
+{
+  printf ("timeout\n");
+  return READERR;
+}
+
+void
+rltest_timeout_readline2 ()
+{
+  const char *temp;
+
+  rl_set_timeout (timeout_secs, timeout_usecs);
+  rl_timeout_event_hook = timeout_handler;
+  temp = readline (prompt);
+  if (temp == NULL)
+    printf ("no input line\n");
+  else
+    printf ("input line: %s\n", temp);
+  free ((void *)temp);
+}
+
+/* **************************************************************** */
+/*								    */
+/* Example 3: rl_callback_* () with rl_timeout_remaining	    */
+/*								    */
+/* **************************************************************** */
+
+/* Callback function called for each line when accept-line executed, EOF
+   seen, or EOF character read.  This sets a flag and returns; it could
+   also call exit(3). */
+static void
+cb_linehandler (char *line)
+{
+  /* Can use ^D (stty eof) or `exit' to exit. */
+  if (line == NULL || strcmp (line, "exit") == 0)
+    {
+      if (line == 0)
+	printf ("\n");
+      printf ("exit\n");
+      /* This function needs to be called to reset the terminal settings,
+	 and calling it from the line handler keeps one extra prompt from
+	 being displayed. */
+      rl_callback_handler_remove ();
+
+      running = 0;
+    }
+  else
+    {
+      if (*line)
+	add_history (line);
+      printf ("input line: %s\n", line);
+      free (line);
+    }
+}
+
+void
+rltest_timeout_callback1 ()
+{
+  fd_set fds;
+  int r;
+  unsigned sec, usec;
+
+  rl_set_timeout (timeout_secs, timeout_usecs);
+  rl_callback_handler_install (prompt, cb_linehandler);
+  running = 1;
+  while (running)
+    {
+      FD_ZERO (&fds);
+      FD_SET (fileno (rl_instream), &fds);
+      r = rl_timeout_remaining (&sec, &usec);
+      if (r == 1)
+	{
+	  struct timeval timeout = {sec, usec};
+	  r = select (FD_SETSIZE, &fds, NULL, NULL, &timeout);
+	}
+      if (r < 0 && errno != EINTR)
+	{
+	  perror ("rl-timeout: select");
+	  rl_callback_handler_remove ();
+	  break;
+	}
+      else if (r == 0)
+	{
+	  printf ("rl-timeout: timeout\n");
+	  rl_callback_handler_remove ();
+	  break;
+	}
+
+      if (FD_ISSET (fileno (rl_instream), &fds))
+	rl_callback_read_char ();
+    }
+
+  printf ("rl-timeout: Event loop has exited\n");
+}
+
+/* **************************************************************** */
+/*								    */
+/* Example 4: rl_callback_* () with rl_timeout_event_hook	    */
+/*								    */
+/* **************************************************************** */
+
+static int
+cb_timeouthandler ()
+{
+  printf ("timeout\n");
+  rl_callback_handler_remove ();
+  running = 0;
+  return READERR;
+}
+
+void
+rltest_timeout_callback2 ()
+{
+  int r;
+
+  rl_set_timeout (timeout_secs, timeout_usecs);
+  rl_timeout_event_hook = cb_timeouthandler;
+  rl_callback_handler_install (prompt, cb_linehandler);
+  running = 1;
+  while (running)
+    rl_callback_read_char ();
+
+  printf ("rl-timeout: Event loop has exited\n");
+}
+
+int
+main (int argc, char **argv)
+{
+  if (argc >= 2)
+    {
+      if (argc >= 3)
+	{
+	  double timeout = atof (argv[2]);
+	  if (timeout <= 0.0)
+	    {
+	      fprintf (stderr, "rl-timeout: specify a positive number for timeout.\n");
+	      return 2;
+	    }
+	  else if (timeout > UINT_MAX)
+	    {
+	      fprintf (stderr, "rl-timeout: timeout too large.\n");
+	      return 2;
+	    }
+	  timeout_secs = (unsigned) timeout;
+	  timeout_usecs = (unsigned) ((timeout - timeout_secs) * 1000000 + 0.5);
+	}
+
+      if (strcmp (argv[1], "readline1") == 0)
+	rltest_timeout_readline1 ();
+      else if (strcmp (argv[1], "readline2") == 0)
+	rltest_timeout_readline2 ();
+      else if (strcmp (argv[1], "callback1") == 0)
+	rltest_timeout_callback1 ();
+      else if (strcmp (argv[1], "callback2") == 0)
+	rltest_timeout_callback2 ();
+      else
+	return 2;
+    }
+  else
+    {
+      fprintf (stderr, "usage: rl-timeout [readline1 | readline2 | callback1 | callback2] [timeout]\n");
+      return 2;
+    }
+  return 0;
+}
diff --git a/readline/readline/examples/rl.c b/readline/readline/examples/rl.c
index a5cf276cb943afcf88a12691c2d7c160dcb11262..39e5b8ebb5d1be6b748a9d8bab3d3feb190e0784 100644
--- a/readline/readline/examples/rl.c
+++ b/readline/readline/examples/rl.c
@@ -38,6 +38,10 @@
 extern void exit();
 #endif
 
+#ifdef HAVE_LOCALE_H
+#  include <locale.h>
+#endif
+
 #if defined (READLINE_LIBRARY)
 #  include "posixstat.h"
 #  include "readline.h"
@@ -93,6 +97,10 @@ main (argc, argv)
   else
     progname++;
 
+#ifdef HAVE_SETLOCALE
+  setlocale (LC_ALL, "");
+#endif
+
   /* defaults */
   prompt = "readline$ ";
   fd = nch = 0;
diff --git a/readline/readline/examples/rlbasic.c b/readline/readline/examples/rlbasic.c
index 6a9601f52a699caa033273abf85e9689406ad07a..1ce4da973d902005e25672cd7838fc6614e3cd9a 100644
--- a/readline/readline/examples/rlbasic.c
+++ b/readline/readline/examples/rlbasic.c
@@ -3,6 +3,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#ifdef HAVE_LOCALE_H
+#  include <locale.h>
+#endif
+
 #if defined (READLINE_LIBRARY)
 #  include "readline.h"
 #  include "history.h"
@@ -16,6 +20,10 @@ main (int c, char **v)
 {
 	char *input;
 
+#ifdef HAVE_SETLOCALE
+	setlocale (LC_ALL, "");
+#endif
+
 	for (;;) {
 		input = readline ((char *)NULL);
 		if (input == 0)
diff --git a/readline/readline/examples/rlcat.c b/readline/readline/examples/rlcat.c
index b4942413f8bebb6d08b83e035ce7dde3a9c52bf7..f1b036260cdc28211c4906fd9ec9807b91fb5b1a 100644
--- a/readline/readline/examples/rlcat.c
+++ b/readline/readline/examples/rlcat.c
@@ -45,6 +45,10 @@
 extern void exit();
 #endif
 
+#ifdef HAVE_LOCALE_H
+#  include <locale.h>
+#endif
+
 #ifndef errno
 extern int errno;
 #endif
@@ -79,6 +83,10 @@ main (argc, argv)
   char *temp;
   int opt, Vflag, Nflag;
 
+#ifdef HAVE_SETLOCALE
+  setlocale (LC_ALL, "");
+#endif
+
   progname = strrchr(argv[0], '/');
   if (progname == 0)
     progname = argv[0];
diff --git a/readline/readline/examples/rlevent.c b/readline/readline/examples/rlevent.c
index 8143cb02aa0742a4dd4e040515a11bcdb6740138..1b7f4eb25a433f8bcd4a872313c99129f06d044d 100644
--- a/readline/readline/examples/rlevent.c
+++ b/readline/readline/examples/rlevent.c
@@ -44,6 +44,10 @@ extern int sleep();
 extern void exit();
 #endif
 
+#ifdef HAVE_LOCALE_H
+#  include <locale.h>
+#endif
+
 #if defined (READLINE_LIBRARY)
 #  include "posixstat.h"
 #  include "readline.h"
@@ -101,6 +105,10 @@ main (argc, argv)
   int opt, fd, nch;
   FILE *ifp;
 
+#ifdef HAVE_SETLOCALE
+  setlocale (LC_ALL, "");
+#endif
+
   progname = strrchr(argv[0], '/');
   if (progname == 0)
     progname = argv[0];
diff --git a/readline/readline/examples/rlptytest.c b/readline/readline/examples/rlptytest.c
index 9c42f8a2795385dc0ae49eb339264a72f77f8ead..d170f62ff822cc12d66319e6dec2af2633d37bb4 100644
--- a/readline/readline/examples/rlptytest.c
+++ b/readline/readline/examples/rlptytest.c
@@ -25,6 +25,10 @@
 #include <util.h>
 #endif
 
+#ifdef HAVE_LOCALE_H
+#  include <locale.h>
+#endif
+
 #ifdef READLINE_LIBRARY
 #  include "readline.h"
 #else
@@ -220,7 +224,7 @@ static enum { RESET, TCBREAK } ttystate = RESET;
  *
  * fd    - The file descriptor of the terminal
  * 
- * Returns: 0 on sucess, -1 on error
+ * Returns: 0 on success, -1 on error
  */
 int tty_cbreak(int fd){
    struct termios buf;
@@ -315,6 +319,11 @@ int
 main()
 {
   int val;
+
+#ifdef HAVE_SETLOCALE
+  setlocale (LC_ALL, "");
+#endif
+
   val = openpty (&masterfd, &slavefd, NULL, NULL, NULL);
   if (val == -1)
     return -1;
diff --git a/readline/readline/examples/rltest.c b/readline/readline/examples/rltest.c
index 65abe87cc044d39175d58408d60ad27674c3e8be..8b7c00c8c49a0e7f071c09f1d93d818b597afd23 100644
--- a/readline/readline/examples/rltest.c
+++ b/readline/readline/examples/rltest.c
@@ -36,6 +36,10 @@
 extern void exit();
 #endif
 
+#ifdef HAVE_LOCALE_H
+#  include <locale.h>
+#endif
+
 #ifdef READLINE_LIBRARY
 #  include "readline.h"
 #  include "history.h"
@@ -52,6 +56,10 @@ main ()
   char *temp, *prompt;
   int done;
 
+#ifdef HAVE_SETLOCALE
+  setlocale (LC_ALL, "");
+#endif
+
   temp = (char *)NULL;
   prompt = "readline$ ";
   done = 0;
diff --git a/readline/readline/funmap.c b/readline/readline/funmap.c
index eca49a3e4f61c0e57289d10352219830c59214ba..8b1cb4028db7fb0afe1e677d08d2a0ee12cac007 100644
--- a/readline/readline/funmap.c
+++ b/readline/readline/funmap.c
@@ -1,6 +1,6 @@
 /* funmap.c -- attach names to functions. */
 
-/* Copyright (C) 1987-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -46,7 +46,7 @@ typedef int QSFUNC (const void *, const void *);
 typedef int QSFUNC ();
 #endif
 
-extern int _rl_qsort_string_compare PARAMS((char **, char **));
+extern int _rl_qsort_string_compare (char **, char **);
 
 FUNMAP **funmap;
 static int funmap_size;
@@ -93,6 +93,7 @@ static const FUNMAP default_funmap[] = {
   { "end-of-history", rl_end_of_history },
   { "end-of-line", rl_end_of_line },
   { "exchange-point-and-mark", rl_exchange_point_and_mark },
+  { "fetch-history", rl_fetch_history },
   { "forward-backward-delete-char", rl_rubout_or_delete },
   { "forward-byte", rl_forward_byte },
   { "forward-char", rl_forward_char },
@@ -198,6 +199,7 @@ static const FUNMAP default_funmap[] = {
   { "vi-set-mark", rl_vi_set_mark },
   { "vi-subst", rl_vi_subst },
   { "vi-tilde-expand", rl_vi_tilde_expand },
+  { "vi-undo", rl_vi_undo },
   { "vi-unix-word-rubout", rl_vi_unix_word_rubout },
   { "vi-yank-arg", rl_vi_yank_arg },
   { "vi-yank-pop", rl_vi_yank_pop },
diff --git a/readline/readline/histexpand.c b/readline/readline/histexpand.c
index b986dba0513f4cf4e28c167953df53f3ae5fa505..8ab68091e64cd750c58d785f2aa1a05a061a3d9b 100644
--- a/readline/readline/histexpand.c
+++ b/readline/readline/histexpand.c
@@ -1,6 +1,6 @@
 /* histexpand.c -- history expansion. */
 
-/* Copyright (C) 1989-2018 Free Software Foundation, Inc.
+/* Copyright (C) 1989-2021 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (History), a set of
    routines for managing the text of previously typed lines.
@@ -57,7 +57,7 @@
 
 #define fielddelim(c)	(whitespace(c) || (c) == '\n')
 
-typedef int _hist_search_func_t PARAMS((const char *, int));
+typedef int _hist_search_func_t (const char *, int);
 
 static char error_pointer;
 
@@ -70,14 +70,14 @@ static int subst_rhs_len;
    specifications from word designators.  Static for now */
 static char *history_event_delimiter_chars = HISTORY_EVENT_DELIMITERS;
 
-static char *get_history_word_specifier PARAMS((char *, char *, int *));
-static int history_tokenize_word PARAMS((const char *, int));
-static char **history_tokenize_internal PARAMS((const char *, int, int *));
-static char *history_substring PARAMS((const char *, int, int));
-static void freewords PARAMS((char **, int));
-static char *history_find_word PARAMS((char *, int));
+static char *get_history_word_specifier (char *, char *, int *);
+static int history_tokenize_word (const char *, int);
+static char **history_tokenize_internal (const char *, int, int *);
+static char *history_substring (const char *, int, int);
+static void freewords (char **, int);
+static char *history_find_word (char *, int);
 
-static char *quote_breaks PARAMS((char *));
+static char *quote_breaks (char *);
 
 /* Variables exported by this file. */
 /* The character that represents the start of a history expansion
@@ -1207,13 +1207,36 @@ history_expand (char *hstring, char **output)
 	     characters in history_no_expand_chars, then it is not a
 	     candidate for expansion of any kind. */
 	  if (cc == 0 || member (cc, history_no_expand_chars) ||
-			 (dquote && cc == '"') ||
-	  		 (history_inhibit_expansion_function && (*history_inhibit_expansion_function) (string, i)))
+			 (dquote && cc == '"'))
 	    {
 	      ADD_CHAR (string[i]);
 	      break;
 	    }
 
+	  /* If the application has defined a function to determine whether
+	     or not a history expansion should be performed, call it here. */
+	  /* We check against what we've expanded so far, with the current
+	     expansion appended, because that seems to be what csh does. We
+	     decide to expand based on what we have to this point, not what
+	     we started with. */
+	  if (history_inhibit_expansion_function)
+	    {
+	      int save_j, temp;
+
+	      save_j = j;
+	      ADD_CHAR (string[i]);
+	      ADD_CHAR (cc);
+
+	      temp = (*history_inhibit_expansion_function) (result, save_j);
+	      if (temp)
+		{
+		  result[--j] = '\0';	/* `unadd' cc, leaving ADD_CHAR(string[i]) */
+		  break;
+		}
+	      else
+	        result[j = save_j] = '\0';
+	    }
+
 #if defined (NO_BANG_HASH_MODIFIERS)
 	  /* There is something that is listed as a `word specifier' in csh
 	     documentation which means `the expanded text to this point'.
diff --git a/readline/readline/histfile.c b/readline/readline/histfile.c
index f0fa5ce15fe1a90d2e6c28e9f0729893e5589fee..3bfec5500db515ebafc2310555019711bdd93f4a 100644
--- a/readline/readline/histfile.c
+++ b/readline/readline/histfile.c
@@ -114,8 +114,6 @@ extern int errno;
 #  define PATH_MAX	1024	/* default */
 #endif
 
-extern void _hs_append_history_line PARAMS((int, const char *));
-
 /* history file version; currently unused */
 int history_file_version = 1;
 
@@ -141,11 +139,11 @@ int history_lines_written_to_file = 0;
    for more extensive tests. */
 #define HIST_TIMESTAMP_START(s)		(*(s) == history_comment_char && isdigit ((unsigned char)(s)[1]) )
 
-static char *history_backupfile PARAMS((const char *));
-static char *history_tempfile PARAMS((const char *));
-static int histfile_backup PARAMS((const char *, const char *));
-static int histfile_restore PARAMS((const char *, const char *));
-static int history_rename PARAMS((const char *, const char *));
+static char *history_backupfile (const char *);
+static char *history_tempfile (const char *);
+static int histfile_backup (const char *, const char *);
+static int histfile_restore (const char *, const char *);
+static int history_rename (const char *, const char *);
 
 /* Return the string that should be used in the place of this
    filename.  This only matters when you don't specify the
@@ -312,7 +310,7 @@ read_history_range (const char *filename, int from, int to)
 
   if (file_size == 0)
     {
-      free (input);
+      xfree (input);
       close (file);
       return 0;	/* don't waste time if we don't have to */
     }
diff --git a/readline/readline/histlib.h b/readline/readline/histlib.h
index 9627b24500012e03eefa8ad0e7dc056b756ed246..29fc4d2e5781dc24d6885f6317f2604695799002 100644
--- a/readline/readline/histlib.h
+++ b/readline/readline/histlib.h
@@ -1,6 +1,6 @@
 /* histlib.h -- internal definitions for the history library. */
 
-/* Copyright (C) 1989-2009 Free Software Foundation, Inc.
+/* Copyright (C) 1989-2009,2021-2022 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (History), a set of
    routines for managing the text of previously typed lines.
@@ -80,6 +80,13 @@ extern char *strchr ();
 /* internal extern function declarations used by other parts of the library */
 
 /* histsearch.c */
-extern int _hs_history_patsearch PARAMS((const char *, int, int));
+extern int _hs_history_patsearch (const char *, int, int);
+
+/* history.c */
+extern void _hs_replace_history_data (int, histdata_t *, histdata_t *);
+extern int _hs_at_end_of_history (void);
+
+/* histfile.c */
+extern void _hs_append_history_line (int, const char *);
 
 #endif /* !_HISTLIB_H_ */
diff --git a/readline/readline/history.c b/readline/readline/history.c
index 67158b14bc711b73462dca023f69873bde271459..81d4c1687b659045f9da5b3b82c58ff9bb4d37b7 100644
--- a/readline/readline/history.c
+++ b/readline/readline/history.c
@@ -1,6 +1,6 @@
 /* history.c -- standalone history library */
 
-/* Copyright (C) 1989-2017 Free Software Foundation, Inc.
+/* Copyright (C) 1989-2021 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (History), a set of
    routines for managing the text of previously typed lines.
@@ -62,7 +62,7 @@ extern int errno;
 /* The number of slots to increase the_history by. */
 #define DEFAULT_HISTORY_GROW_SIZE 50
 
-static char *hist_inittime PARAMS((void));
+static char *hist_inittime (void);
 
 /* **************************************************************** */
 /*								    */
@@ -165,6 +165,13 @@ history_set_pos (int pos)
   history_offset = pos;
   return (1);
 }
+
+/* Are we currently at the end of the history list? */
+int
+_hs_at_end_of_history (void)
+{
+  return (the_history == 0 || history_offset == history_length);
+}
  
 /* Return the current history array.  The caller has to be careful, since this
    is the actual array of data, and could be bashed or made corrupt easily.
@@ -390,7 +397,7 @@ replace_history_entry (int which, const char *line, histdata_t data)
 
   temp->line = savestring (line);
   temp->data = data;
-  temp->timestamp = savestring (old_value->timestamp);
+  temp->timestamp = old_value->timestamp ? savestring (old_value->timestamp) : 0;
   the_history[which] = temp;
 
   return (old_value);
diff --git a/readline/readline/history.h b/readline/readline/history.h
index cc3de29a64231d083d7b282e2eb247d692dbe521..5208f9a463b2a18c5a6e9ee32d120980e989eaaf 100644
--- a/readline/readline/history.h
+++ b/readline/readline/history.h
@@ -1,6 +1,6 @@
 /* history.h -- the names of functions that you can call in history. */
 
-/* Copyright (C) 1989-2015 Free Software Foundation, Inc.
+/* Copyright (C) 1989-2022 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (History), a set of
    routines for managing the text of previously typed lines.
@@ -42,6 +42,11 @@ typedef void *histdata_t;
 typedef char *histdata_t;
 #endif
 
+/* Let's not step on anyone else's define for now, since we don't use this yet. */
+#ifndef HS_HISTORY_VERSION
+#  define HS_HISTORY_VERSION 0x0802	/* History 8.2 */
+#endif
+
 /* The structure used to store a history entry. */
 typedef struct _hist_entry {
   char *line;
@@ -68,102 +73,102 @@ typedef struct _hist_state {
 
 /* Begin a session in which the history functions might be used.  This
    just initializes the interactive variables. */
-extern void using_history PARAMS((void));
+extern void using_history (void);
 
 /* Return the current HISTORY_STATE of the history. */
-extern HISTORY_STATE *history_get_history_state PARAMS((void));
+extern HISTORY_STATE *history_get_history_state (void);
 
 /* Set the state of the current history array to STATE. */
-extern void history_set_history_state PARAMS((HISTORY_STATE *));
+extern void history_set_history_state (HISTORY_STATE *);
 
 /* Manage the history list. */
 
 /* Place STRING at the end of the history list.
    The associated data field (if any) is set to NULL. */
-extern void add_history PARAMS((const char *));
+extern void add_history (const char *);
 
 /* Change the timestamp associated with the most recent history entry to
    STRING. */
-extern void add_history_time PARAMS((const char *));
+extern void add_history_time (const char *);
 
 /* Remove an entry from the history list.  WHICH is the magic number that
    tells us which element to delete.  The elements are numbered from 0. */
-extern HIST_ENTRY *remove_history PARAMS((int));
+extern HIST_ENTRY *remove_history (int);
 
 /* Remove a set of entries from the history list: FIRST to LAST, inclusive */
-extern HIST_ENTRY **remove_history_range PARAMS((int, int));
+extern HIST_ENTRY **remove_history_range (int, int);
 
 /* Allocate a history entry consisting of STRING and TIMESTAMP and return
    a pointer to it. */
-extern HIST_ENTRY *alloc_history_entry PARAMS((char *, char *));
+extern HIST_ENTRY *alloc_history_entry (char *, char *);
 
 /* Copy the history entry H, but not the (opaque) data pointer */
-extern HIST_ENTRY *copy_history_entry PARAMS((HIST_ENTRY *));
+extern HIST_ENTRY *copy_history_entry (HIST_ENTRY *);
 
 /* Free the history entry H and return any application-specific data
    associated with it. */
-extern histdata_t free_history_entry PARAMS((HIST_ENTRY *));
+extern histdata_t free_history_entry (HIST_ENTRY *);
 
 /* Make the history entry at WHICH have LINE and DATA.  This returns
    the old entry so you can dispose of the data.  In the case of an
    invalid WHICH, a NULL pointer is returned. */
-extern HIST_ENTRY *replace_history_entry PARAMS((int, const char *, histdata_t));
+extern HIST_ENTRY *replace_history_entry (int, const char *, histdata_t);
 
 /* Clear the history list and start over. */
-extern void clear_history PARAMS((void));
+extern void clear_history (void);
 
 /* Stifle the history list, remembering only MAX number of entries. */
-extern void stifle_history PARAMS((int));
+extern void stifle_history (int);
 
 /* Stop stifling the history.  This returns the previous amount the
    history was stifled by.  The value is positive if the history was
    stifled, negative if it wasn't. */
-extern int unstifle_history PARAMS((void));
+extern int unstifle_history (void);
 
 /* Return 1 if the history is stifled, 0 if it is not. */
-extern int history_is_stifled PARAMS((void));
+extern int history_is_stifled (void);
 
 /* Information about the history list. */
 
 /* Return a NULL terminated array of HIST_ENTRY which is the current input
    history.  Element 0 of this list is the beginning of time.  If there
    is no history, return NULL. */
-extern HIST_ENTRY **history_list PARAMS((void));
+extern HIST_ENTRY **history_list (void);
 
 /* Returns the number which says what history element we are now
    looking at.  */
-extern int where_history PARAMS((void));
+extern int where_history (void);
   
 /* Return the history entry at the current position, as determined by
    history_offset.  If there is no entry there, return a NULL pointer. */
-extern HIST_ENTRY *current_history PARAMS((void));
+extern HIST_ENTRY *current_history (void);
 
 /* Return the history entry which is logically at OFFSET in the history
    array.  OFFSET is relative to history_base. */
-extern HIST_ENTRY *history_get PARAMS((int));
+extern HIST_ENTRY *history_get (int);
 
 /* Return the timestamp associated with the HIST_ENTRY * passed as an
    argument */
-extern time_t history_get_time PARAMS((HIST_ENTRY *));
+extern time_t history_get_time (HIST_ENTRY *);
 
 /* Return the number of bytes that the primary history entries are using.
    This just adds up the lengths of the_history->lines. */
-extern int history_total_bytes PARAMS((void));
+extern int history_total_bytes (void);
 
 /* Moving around the history list. */
 
 /* Set the position in the history list to POS. */
-extern int history_set_pos PARAMS((int));
+extern int history_set_pos (int);
 
 /* Back up history_offset to the previous history entry, and return
    a pointer to that entry.  If there is no previous entry, return
    a NULL pointer. */
-extern HIST_ENTRY *previous_history PARAMS((void));
+extern HIST_ENTRY *previous_history (void);
 
 /* Move history_offset forward to the next item in the input_history,
    and return the a pointer to that entry.  If there is no next entry,
    return a NULL pointer. */
-extern HIST_ENTRY *next_history PARAMS((void));
+extern HIST_ENTRY *next_history (void);
 
 /* Searching the history list. */
 
@@ -173,45 +178,45 @@ extern HIST_ENTRY *next_history PARAMS((void));
    current_history () is the history entry, and the value of this function
    is the offset in the line of that history entry that the string was
    found in.  Otherwise, nothing is changed, and a -1 is returned. */
-extern int history_search PARAMS((const char *, int));
+extern int history_search (const char *, int);
 
 /* Search the history for STRING, starting at history_offset.
    The search is anchored: matching lines must begin with string.
    DIRECTION is as in history_search(). */
-extern int history_search_prefix PARAMS((const char *, int));
+extern int history_search_prefix (const char *, int);
 
 /* Search for STRING in the history list, starting at POS, an
    absolute index into the list.  DIR, if negative, says to search
    backwards from POS, else forwards.
    Returns the absolute index of the history element where STRING
    was found, or -1 otherwise. */
-extern int history_search_pos PARAMS((const char *, int, int));
+extern int history_search_pos (const char *, int, int);
 
 /* Managing the history file. */
 
 /* Add the contents of FILENAME to the history list, a line at a time.
    If FILENAME is NULL, then read from ~/.history.  Returns 0 if
    successful, or errno if not. */
-extern int read_history PARAMS((const char *));
+extern int read_history (const char *);
 
 /* Read a range of lines from FILENAME, adding them to the history list.
    Start reading at the FROM'th line and end at the TO'th.  If FROM
    is zero, start at the beginning.  If TO is less than FROM, read
    until the end of the file.  If FILENAME is NULL, then read from
    ~/.history.  Returns 0 if successful, or errno if not. */
-extern int read_history_range PARAMS((const char *, int, int));
+extern int read_history_range (const char *, int, int);
 
 /* Write the current history to FILENAME.  If FILENAME is NULL,
    then write the history list to ~/.history.  Values returned
    are as in read_history ().  */
-extern int write_history PARAMS((const char *));
+extern int write_history (const char *);
 
 /* Append NELEMENT entries to FILENAME.  The entries appended are from
    the end of the list minus NELEMENTs up to the end of the list. */
-extern int append_history PARAMS((int, const char *));
+extern int append_history (int, const char *);
 
 /* Truncate the history file, leaving only the last NLINES lines. */
-extern int history_truncate_file PARAMS((const char *, int));
+extern int history_truncate_file (const char *, int);
 
 /* History expansion. */
 
@@ -227,12 +232,12 @@ extern int history_truncate_file PARAMS((const char *, int));
 
   If an error occurred in expansion, then OUTPUT contains a descriptive
   error message. */
-extern int history_expand PARAMS((char *, char **));
+extern int history_expand (char *, char **);
 
 /* Extract a string segment consisting of the FIRST through LAST
    arguments present in STRING.  Arguments are broken up as in
    the shell. */
-extern char *history_arg_extract PARAMS((int, int, const char *));
+extern char *history_arg_extract (int, int, const char *);
 
 /* Return the text of the history event beginning at the current
    offset into STRING.  Pass STRING with *INDEX equal to the
@@ -240,11 +245,11 @@ extern char *history_arg_extract PARAMS((int, int, const char *));
    DELIMITING_QUOTE is a character that is allowed to end the string
    specification for what to search for in addition to the normal
    characters `:', ` ', `\t', `\n', and sometimes `?'. */
-extern char *get_history_event PARAMS((const char *, int *, int));
+extern char *get_history_event (const char *, int *, int);
 
 /* Return an array of tokens, much as the shell might.  The tokens are
    parsed out of STRING. */
-extern char **history_tokenize PARAMS((const char *));
+extern char **history_tokenize (const char *);
 
 /* Exported history variables. */
 extern int history_base;
diff --git a/readline/readline/history.pc.in b/readline/readline/history.pc.in
new file mode 100644
index 0000000000000000000000000000000000000000..8a80775ded8a564ebfc5dc8846cfe23e824e9a31
--- /dev/null
+++ b/readline/readline/history.pc.in
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: History
+Description: Gnu History library for managing previously-entered lines
+URL: http://tiswww.cwru.edu/php/chet/readline/rltop.html
+Version: @LIBVERSION@
+Libs: -L${libdir} -lhistory
+Cflags: -I${includedir}
diff --git a/readline/readline/histsearch.c b/readline/readline/histsearch.c
index 7a426c96781429785f1b44ad3241da43e63df545..b62c06b7bf066a32fcc4b24bc8b3aa8c8910488c 100644
--- a/readline/readline/histsearch.c
+++ b/readline/readline/histsearch.c
@@ -1,6 +1,6 @@
 /* histsearch.c -- searching the history list. */
 
-/* Copyright (C) 1989, 1992-2009,2017 Free Software Foundation, Inc.
+/* Copyright (C) 1989, 1992-2009,2017,2021 Free Software Foundation, Inc.
 
    This file contains the GNU History Library (History), a set of
    routines for managing the text of previously typed lines.
@@ -51,7 +51,7 @@
    string. */
 char *history_search_delimiter_chars = (char *)NULL;
 
-static int history_search_internal PARAMS((const char *, int, int));
+static int history_search_internal (const char *, int, int);
 
 /* Search the history for STRING, starting at history_offset.
    If DIRECTION < 0, then the search is through previous entries, else
@@ -248,7 +248,7 @@ _hs_history_patsearch (const char *string, int direction, int flags)
   ret = history_search_internal (pat, direction, flags|PATTERN_SEARCH);
 
   if (pat != string)
-    free (pat);
+    xfree (pat);
   return ret;
 }
 	
diff --git a/readline/readline/input.c b/readline/readline/input.c
index 61b0fde3c87f25644fd9ff7ec1ef0e02d14c403c..f68fcac553c33a1a75e4c43912d4f4464d421db1 100644
--- a/readline/readline/input.c
+++ b/readline/readline/input.c
@@ -1,6 +1,6 @@
 /* input.c -- character input functions for readline. */
 
-/* Copyright (C) 1994-2017 Free Software Foundation, Inc.
+/* Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -50,6 +50,7 @@
 #include <signal.h>
 
 #include "posixselect.h"
+#include "posixtime.h"
 
 #if defined (FIONREAD_IN_SYS_IOCTL)
 #  include <sys/ioctl.h>
@@ -78,7 +79,7 @@ extern int errno;
 #  define O_NDELAY O_NONBLOCK	/* Posix style */
 #endif
 
-#if defined (HAVE_PSELECT)
+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
 extern sigset_t _rl_orig_sigset;
 #endif
 
@@ -89,6 +90,9 @@ rl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;
 /* A function to call if a read(2) is interrupted by a signal. */
 rl_hook_func_t *rl_signal_event_hook = (rl_hook_func_t *)NULL;
 
+/* A function to call when readline times out after a time is specified. */
+rl_hook_func_t *rl_timeout_event_hook = (rl_hook_func_t *)NULL;
+
 /* A function to replace _rl_input_available for applications using the
    callback interface. */
 rl_hook_func_t *rl_input_available_hook = (rl_hook_func_t *)NULL;
@@ -97,9 +101,9 @@ rl_getc_func_t *rl_getc_function = rl_getc;
 
 static int _keyboard_input_timeout = 100000;		/* 0.1 seconds; it's in usec */
 
-static int ibuffer_space PARAMS((void));
-static int rl_get_char PARAMS((int *));
-static int rl_gather_tyi PARAMS((void));
+static int ibuffer_space (void);
+static int rl_get_char (int *);
+static int rl_gather_tyi (void);
 
 /* Windows isatty returns true for every character device, including the null
    device, so we need to perform additional checks. */
@@ -132,6 +136,38 @@ win32_isatty (int fd)
 #define isatty(x)	win32_isatty(x)
 #endif
 
+/* Readline timeouts */
+
+/* I don't know how to set a timeout for _getch() in MinGW32, so we use
+   SIGALRM. */
+#if (defined (HAVE_PSELECT) || defined (HAVE_SELECT)) && !defined (__MINGW32__)
+#  define RL_TIMEOUT_USE_SELECT
+#else
+#  define RL_TIMEOUT_USE_SIGALRM
+#endif
+
+int rl_set_timeout (unsigned int, unsigned int);
+int rl_timeout_remaining (unsigned int *, unsigned int *);
+
+int _rl_timeout_init (void);
+int _rl_timeout_sigalrm_handler (void);
+#if defined (RL_TIMEOUT_USE_SELECT)
+int _rl_timeout_select (int, fd_set *, fd_set *, fd_set *, const struct timeval *, const sigset_t *);
+#endif
+
+static void _rl_timeout_handle (void);
+#if defined (RL_TIMEOUT_USE_SIGALRM)
+static int set_alarm (unsigned int *, unsigned int *);
+static void reset_alarm (void);
+#endif
+
+/* We implement timeouts as a future time using a supplied interval
+   (timeout_duration) from when the timeout is set (timeout_point).
+   That allows us to easily determine whether the timeout has occurred
+   and compute the time remaining until it does. */
+static struct timeval timeout_point;
+static struct timeval timeout_duration;
+
 /* **************************************************************** */
 /*								    */
 /*			Character Input Buffering       	    */
@@ -214,7 +250,7 @@ rl_gather_tyi (void)
   register int tem, result;
   int chars_avail, k;
   char input;
-#if defined(HAVE_SELECT)
+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
   fd_set readfds, exceptfds;
   struct timeval timeout;
 #endif
@@ -223,13 +259,17 @@ rl_gather_tyi (void)
   input = 0;
   tty = fileno (rl_instream);
 
-#if defined (HAVE_SELECT)
+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
   FD_ZERO (&readfds);
   FD_ZERO (&exceptfds);
   FD_SET (tty, &readfds);
   FD_SET (tty, &exceptfds);
   USEC_TO_TIMEVAL (_keyboard_input_timeout, timeout);
+#if defined (RL_TIMEOUT_USE_SELECT)
+  result = _rl_timeout_select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout, NULL);
+#else
   result = select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout);
+#endif
   if (result <= 0)
     return 0;	/* Nothing to read. */
 #endif
@@ -330,11 +370,11 @@ rl_set_keyboard_input_timeout (int u)
 int
 _rl_input_available (void)
 {
-#if defined(HAVE_SELECT)
+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
   fd_set readfds, exceptfds;
   struct timeval timeout;
 #endif
-#if !defined (HAVE_SELECT) && defined(FIONREAD)
+#if !defined (HAVE_SELECT) && defined (FIONREAD)
   int chars_avail;
 #endif
   int tty;
@@ -344,13 +384,17 @@ _rl_input_available (void)
 
   tty = fileno (rl_instream);
 
-#if defined (HAVE_SELECT)
+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
   FD_ZERO (&readfds);
   FD_ZERO (&exceptfds);
   FD_SET (tty, &readfds);
   FD_SET (tty, &exceptfds);
   USEC_TO_TIMEVAL (_keyboard_input_timeout, timeout);
+#  if defined (RL_TIMEOUT_USE_SELECT)
+  return (_rl_timeout_select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout, NULL) > 0);
+#  else
   return (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) > 0);
+#  endif
 #else
 
 #if defined (FIONREAD)
@@ -463,6 +507,242 @@ rl_clear_pending_input (void)
   return 0;
 }
 
+/* **************************************************************** */
+/*								    */
+/*			    Timeout utility			    */
+/*								    */
+/* **************************************************************** */
+
+#if defined (RL_TIMEOUT_USE_SIGALRM)
+#  if defined (HAVE_SETITIMER)
+
+static int
+set_alarm (unsigned int *secs, unsigned int *usecs)
+{
+  struct itimerval it;
+
+  timerclear (&it.it_interval);
+  timerset (&it.it_value, *secs, *usecs);
+  return setitimer (ITIMER_REAL, &it, NULL);
+}
+
+static void
+reset_alarm ()
+{
+  struct itimerval it;
+
+  timerclear (&it.it_interval);
+  timerclear (&it.it_value);
+  setitimer (ITIMER_REAL, &it, NULL);
+}
+#  else
+static int
+set_alarm (unsigned int *secs, unsigned int *usecs)
+{
+  if (*secs == 0 || *usecs >= USEC_PER_SEC / 2)
+    (*secs)++;
+  *usecs = 0;
+
+  return alarm (*secs);
+}
+static void
+reset_alarm ()
+{
+  alarm (0);
+}
+#  endif
+#endif
+
+/* Set a timeout which will be used for the next call of `readline
+   ()'.  When (0, 0) are specified the timeout is cleared.  */
+int
+rl_set_timeout (unsigned int secs, unsigned int usecs)
+{
+  timeout_duration.tv_sec = secs + usecs / USEC_PER_SEC;
+  timeout_duration.tv_usec = usecs % USEC_PER_SEC;
+
+  return 0;
+}
+
+/* Start measuring the time.  Returns 0 on success.  Returns -1 on
+   error. */
+int
+_rl_timeout_init (void)
+{
+  unsigned int secs, usecs;
+
+  /* Clear the timeout state of the previous edit */
+  RL_UNSETSTATE(RL_STATE_TIMEOUT);
+  timerclear (&timeout_point);
+
+  /* Return 0 when timeout is unset. */
+  if (timerisunset (&timeout_duration))
+    return 0;
+
+  /* Return -1 on gettimeofday error. */
+  if (gettimeofday(&timeout_point, 0) != 0)
+    {
+      timerclear (&timeout_point);
+      return -1;
+    }
+
+  secs = timeout_duration.tv_sec;
+  usecs = timeout_duration.tv_usec;
+
+#if defined (RL_TIMEOUT_USE_SIGALRM)
+  /* If select(2)/pselect(2) is unavailable, use SIGALRM. */
+  if (set_alarm (&secs, &usecs) < 0)
+    return -1;
+#endif
+
+  timeout_point.tv_sec += secs;
+  timeout_point.tv_usec += usecs;
+  if (timeout_point.tv_usec >= USEC_PER_SEC)
+    {
+      timeout_point.tv_sec++;
+      timeout_point.tv_usec -= USEC_PER_SEC;
+    }
+
+  return 0;
+}
+
+/* Get the remaining time until the scheduled timeout.  Returns -1 on
+   error or no timeout set with secs and usecs unchanged.  Returns 0
+   on an expired timeout with secs and usecs unchanged.  Returns 1
+   when the timeout has not yet expired.  The remaining time is stored
+   in secs and usecs.  When NULL is specified to either of the
+   arguments, just the expiration is tested. */
+int
+rl_timeout_remaining (unsigned int *secs, unsigned int *usecs)
+{
+  struct timeval current_time;
+
+  /* Return -1 when timeout is unset. */
+  if (timerisunset (&timeout_point))
+    {
+      errno = 0;
+      return -1;
+    }
+
+  /* Return -1 on error. errno is set by gettimeofday. */
+  if (gettimeofday(&current_time, 0) != 0)
+    return -1;
+
+  /* Return 0 when timeout has already expired. */
+  /* could use timercmp (&timeout_point, &current_time, <) here */
+  if (current_time.tv_sec > timeout_point.tv_sec ||
+	(current_time.tv_sec == timeout_point.tv_sec &&
+	 current_time.tv_usec >= timeout_point.tv_usec))
+    return 0;
+
+  if (secs && usecs)
+    {
+      *secs = timeout_point.tv_sec - current_time.tv_sec;
+      *usecs = timeout_point.tv_usec - current_time.tv_usec;
+      if (timeout_point.tv_usec < current_time.tv_usec)
+	{
+	  (*secs)--;
+	  *usecs += USEC_PER_SEC;
+	}
+    }
+
+  return 1;
+}
+
+/* This should only be called if RL_TIMEOUT_USE_SELECT is defined. */
+
+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
+int
+_rl_timeout_select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout, const sigset_t *sigmask)
+{
+  int result;
+#if defined (HAVE_PSELECT)
+  struct timespec ts;
+#else
+  sigset_t origmask;
+  struct timeval tv;
+#endif
+  int tmout_status;
+  struct timeval tmout;
+  unsigned int sec, usec;
+
+  /* When the remaining time for rl_timeout is shorter than the
+     keyboard input timeout, replace `timeout' with the remaining time
+     for `rl_timeout' and set `tmout_status = 1'. */
+  tmout_status = rl_timeout_remaining (&sec, &usec);
+  tmout.tv_sec = sec;
+  tmout.tv_usec = usec;
+
+  if (tmout_status == 0)
+    _rl_timeout_handle ();
+  else if (tmout_status == 1)
+    {
+      if (timeout == NULL || timercmp (&tmout, timeout, <))
+	timeout = &tmout;
+      else
+	tmout_status = -1;
+    }
+
+#if defined (HAVE_PSELECT)
+  if (timeout)
+    {
+      TIMEVAL_TO_TIMESPEC (timeout, &ts);
+      result = pselect (nfds, readfds, writefds, exceptfds, &ts, sigmask);
+    }
+  else
+    result = pselect (nfds, readfds, writefds, exceptfds, NULL, sigmask);
+#else
+  if (sigmask)
+    sigprocmask (SIG_SETMASK, sigmask, &origmask);
+
+  if (timeout)
+    {
+      tv.tv_sec = timeout->tv_sec;
+      tv.tv_usec = timeout->tv_usec;
+      result = select (nfds, readfds, writefds, exceptfds, &tv);
+    }
+  else
+    result = select (nfds, readfds, writefds, exceptfds, NULL);
+
+  if (sigmask)
+    sigprocmask (SIG_SETMASK, &origmask, NULL);
+#endif
+
+  if (tmout_status == 1 && result == 0)
+    _rl_timeout_handle ();
+
+  return result;
+}
+#endif
+
+static void
+_rl_timeout_handle ()
+{
+  if (rl_timeout_event_hook)
+    (*rl_timeout_event_hook) ();
+
+  RL_SETSTATE(RL_STATE_TIMEOUT);
+  _rl_abort_internal ();
+}
+
+int
+_rl_timeout_handle_sigalrm ()
+{
+#if defined (RL_TIMEOUT_USE_SIGALRM)
+  if (timerisunset (&timeout_point))
+    return -1;
+
+  /* Reset `timeout_point' to the current time to ensure that later
+     calls of `rl_timeout_pending ()' return 0 (timeout expired). */
+  if (gettimeofday(&timeout_point, 0) != 0)
+    timerclear (&timeout_point);
+
+  reset_alarm ();
+
+  _rl_timeout_handle ();
+#endif
+  return -1;
+}
 /* **************************************************************** */
 /*								    */
 /*			     Character Input			    */
@@ -497,6 +777,7 @@ rl_read_key (void)
 	      if ((r = rl_gather_tyi ()) < 0)	/* XXX - EIO */
 		{
 		  rl_done = 1;
+		  RL_SETSTATE (RL_STATE_DONE);
 		  return (errno == EIO ? (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF) : '\n');
 		}
 	      else if (r > 0)			/* read something */
@@ -523,37 +804,57 @@ rl_read_key (void)
 int
 rl_getc (FILE *stream)
 {
-  int result;
+  int result, ostate, osig;
   unsigned char c;
-#if defined (HAVE_PSELECT)
+  int fd;
+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
   sigset_t empty_set;
   fd_set readfds;
 #endif
 
+  fd = fileno (stream);
   while (1)
     {
+      osig = _rl_caught_signal;
+      ostate = rl_readline_state;
+
       RL_CHECK_SIGNALS ();
 
+#if defined (READLINE_CALLBACKS)
+      /* Do signal handling post-processing here, but just in callback mode
+	 for right now because the signal cleanup can change some of the
+	 callback state, and we need to either let the application have a
+	 chance to react or abort some current operation that gets cleaned
+	 up by rl_callback_sigcleanup(). If not, we'll just run through the
+	 loop again. */
+      if (osig != 0 && (ostate & RL_STATE_CALLBACK))
+	goto postproc_signal;
+#endif
+
       /* We know at this point that _rl_caught_signal == 0 */
 
 #if defined (__MINGW32__)
-      if (isatty (fileno (stream)))
+      if (isatty (fd)
 	return (_getch ());	/* "There is no error return." */
 #endif
       result = 0;
-#if defined (HAVE_PSELECT)
+#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)
+      /* At this point, if we have pselect, we're using select/pselect for the
+	 timeouts. We handled MinGW above. */
       FD_ZERO (&readfds);
-      FD_SET (fileno (stream), &readfds);
+      FD_SET (fd, &readfds);
 #  if defined (HANDLE_SIGNALS)
-      result = pselect (fileno (stream) + 1, &readfds, NULL, NULL, NULL, &_rl_orig_sigset);
+      result = _rl_timeout_select (fd + 1, &readfds, NULL, NULL, NULL, &_rl_orig_sigset);
 #  else
       sigemptyset (&empty_set);
       sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &empty_set);
-      result = pselect (fileno (stream) + 1, &readfds, NULL, NULL, NULL, &empty_set);
+      result = _rl_timeout_select (fd + 1, &readfds, NULL, NULL, NULL, &empty_set);
 #  endif /* HANDLE_SIGNALS */
+      if (result == 0)
+        _rl_timeout_handle ();		/* check the timeout */
 #endif
       if (result >= 0)
-	result = read (fileno (stream), &c, sizeof (unsigned char));
+	result = read (fd, &c, sizeof (unsigned char));
 
       if (result == sizeof (unsigned char))
 	return (c);
@@ -582,7 +883,7 @@ rl_getc (FILE *stream)
 
       if (errno == X_EWOULDBLOCK || errno == X_EAGAIN)
 	{
-	  if (sh_unset_nodelay_mode (fileno (stream)) < 0)
+	  if (sh_unset_nodelay_mode (fd) < 0)
 	    return (EOF);
 	  continue;
 	}
@@ -593,6 +894,9 @@ rl_getc (FILE *stream)
 /* fprintf(stderr, "rl_getc: result = %d errno = %d\n", result, errno); */
 
 handle_error:
+      osig = _rl_caught_signal;
+      ostate = rl_readline_state;
+
       /* If the error that we received was EINTR, then try again,
 	 this is simply an interrupted system call to read ().  We allow
 	 the read to be interrupted if we caught SIGHUP, SIGTERM, or any
@@ -633,8 +937,17 @@ handle_error:
         RL_CHECK_SIGNALS ();
 #endif  /* SIGALRM */
 
+postproc_signal:
+      /* POSIX says read(2)/pselect(2)/select(2) don't return EINTR for any
+	 reason other than being interrupted by a signal, so we can safely
+	 call the application's signal event hook. */
       if (rl_signal_event_hook)
 	(*rl_signal_event_hook) ();
+#if defined (READLINE_CALLBACKS)
+      else if (osig == SIGINT && (ostate & RL_STATE_CALLBACK) && (ostate & (RL_STATE_ISEARCH|RL_STATE_NSEARCH|RL_STATE_NUMERICARG)))
+        /* just these cases for now */
+        _rl_abort_internal ();
+#endif
     }
 }
 
@@ -645,7 +958,7 @@ _rl_read_mbchar (char *mbchar, int size)
 {
   int mb_len, c;
   size_t mbchar_bytes_length;
-  wchar_t wc;
+  WCHAR_T wc;
   mbstate_t ps, ps_back;
 
   memset(&ps, 0, sizeof (mbstate_t));
@@ -661,7 +974,7 @@ _rl_read_mbchar (char *mbchar, int size)
 
       mbchar[mb_len++] = c;
 
-      mbchar_bytes_length = mbrtowc (&wc, mbchar, mb_len, &ps);
+      mbchar_bytes_length = MBRTOWC (&wc, mbchar, mb_len, &ps);
       if (mbchar_bytes_length == (size_t)(-1))
 	break;		/* invalid byte sequence for the current locale */
       else if (mbchar_bytes_length == (size_t)(-2))
diff --git a/readline/readline/isearch.c b/readline/readline/isearch.c
index 941078f790e33696b97fed672f575cb65412bc34..c445c12a64f0237e55ff79877906e58a76656e1c 100644
--- a/readline/readline/isearch.c
+++ b/readline/readline/isearch.c
@@ -6,7 +6,7 @@
 /*								    */
 /* **************************************************************** */
 
-/* Copyright (C) 1987-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -59,13 +59,10 @@ char *_rl_isearch_terminators = (char *)NULL;
 
 _rl_search_cxt *_rl_iscxt = 0;
 
-/* Variables imported from other files in the readline library. */
-extern HIST_ENTRY *_rl_saved_line_for_history;
+static int rl_search_history (int, int);
 
-static int rl_search_history PARAMS((int, int));
-
-static _rl_search_cxt *_rl_isearch_init PARAMS((int));
-static void _rl_isearch_fini PARAMS((_rl_search_cxt *));
+static _rl_search_cxt *_rl_isearch_init (int);
+static void _rl_isearch_fini (_rl_search_cxt *);
 
 /* Last line found by the current incremental search, so we don't `find'
    identical lines many times in a row.  Now part of isearch context. */
@@ -197,7 +194,10 @@ rl_display_search (char *search_string, int flags, int where)
 
   rl_message ("%s", message);
   xfree (message);
+#if 0
+  /* rl_message calls this */
   (*rl_redisplay_function) ();
+#endif
 }
 
 static _rl_search_cxt *
@@ -276,6 +276,8 @@ _rl_isearch_fini (_rl_search_cxt *cxt)
   last_isearch_string = cxt->search_string;
   last_isearch_string_len = cxt->search_string_index;
   cxt->search_string = 0;
+  cxt->search_string_size = 0;
+  cxt->search_string_index = 0;
 
   if (cxt->last_found_line < cxt->save_line)
     rl_get_previous_history (cxt->save_line - cxt->last_found_line, 0);
@@ -321,7 +323,7 @@ _rl_search_getchar (_rl_search_cxt *cxt)
 #if defined (HANDLE_MULTIBYTE)
   /* This ends up with C (and LASTC) being set to the last byte of the
      multibyte character.  In most cases c == lastc == mb[0] */
-  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
+  if (c >= 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)
     c = cxt->lastc = _rl_read_mbstring (cxt->lastc, cxt->mb, MB_LEN_MAX);
 #endif
 
@@ -426,7 +428,11 @@ add_character:
 	{
 	  f = cxt->keymap[c].function;
 	  if (f == rl_do_lowercase_version)
-	    f = cxt->keymap[_rl_to_lower (c)].function;
+	    {
+	      f = cxt->keymap[_rl_to_lower (c)].function;
+	      if (f == rl_do_lowercase_version)
+		f = rl_insert;
+	    }
 	}
 
       if (f == rl_reverse_search_history)
@@ -680,7 +686,7 @@ opcode_dispatch:
       paste = _rl_bracketed_text (&pastelen);
       if (paste == 0 || *paste == 0)
 	{
-	  free (paste);
+	  xfree (paste);
 	  break;
 	}
       if (_rl_enable_active_region)
@@ -690,9 +696,10 @@ opcode_dispatch:
 	  cxt->search_string_size += pastelen + 2;
 	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
 	}
-      strcpy (cxt->search_string + cxt->search_string_index, paste);
+      memcpy (cxt->search_string + cxt->search_string_index, paste, pastelen);
       cxt->search_string_index += pastelen;
-      free (paste);
+      cxt->search_string[cxt->search_string_index] = '\0';
+      xfree (paste);
       break;
 
     /* Add character to search string and continue search. */
diff --git a/readline/readline/keymaps.h b/readline/readline/keymaps.h
index 1fa853d8c1e6a68a9e06d79c880e7d246759ced6..2903814838620ffaa72cc4bbbb93e4a9c63ab172 100644
--- a/readline/readline/keymaps.h
+++ b/readline/readline/keymaps.h
@@ -1,6 +1,6 @@
 /* keymaps.h -- Manipulation of readline keymaps. */
 
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+/* Copyright (C) 1987, 1989, 1992-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -65,33 +65,33 @@ extern KEYMAP_ENTRY_ARRAY vi_insertion_keymap, vi_movement_keymap;
 
 /* Return a new, empty keymap.
    Free it with free() when you are done. */
-extern Keymap rl_make_bare_keymap PARAMS((void));
+extern Keymap rl_make_bare_keymap (void);
 
 /* Return a new keymap which is a copy of MAP. */
-extern Keymap rl_copy_keymap PARAMS((Keymap));
+extern Keymap rl_copy_keymap (Keymap);
 
 /* Return a new keymap with the printing characters bound to rl_insert,
    the lowercase Meta characters bound to run their equivalents, and
    the Meta digits bound to produce numeric arguments. */
-extern Keymap rl_make_keymap PARAMS((void));
+extern Keymap rl_make_keymap (void);
 
 /* Free the storage associated with a keymap. */
-extern void rl_discard_keymap PARAMS((Keymap));
+extern void rl_discard_keymap (Keymap);
 
 /* These functions actually appear in bind.c */
 
 /* Return the keymap corresponding to a given name.  Names look like
    `emacs' or `emacs-meta' or `vi-insert'.  */
-extern Keymap rl_get_keymap_by_name PARAMS((const char *));
+extern Keymap rl_get_keymap_by_name (const char *);
 
 /* Return the current keymap. */
-extern Keymap rl_get_keymap PARAMS((void));
+extern Keymap rl_get_keymap (void);
 
 /* Set the current keymap to MAP. */
-extern void rl_set_keymap PARAMS((Keymap));
+extern void rl_set_keymap (Keymap);
 
 /* Set the name of MAP to NAME */
-extern int rl_set_keymap_name PARAMS((const char *, Keymap));
+extern int rl_set_keymap_name (const char *, Keymap);
 
 #ifdef __cplusplus
 }
diff --git a/readline/readline/kill.c b/readline/readline/kill.c
index 50c3fdead765bc71b0e3e2d1ef81e4155982aa8a..4cf933b20096ec0ceafa573fa3f06d43f4a178af 100644
--- a/readline/readline/kill.c
+++ b/readline/readline/kill.c
@@ -1,6 +1,6 @@
 /* kill.c -- kill ring management. */
 
-/* Copyright (C) 1994-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1994-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -70,10 +70,10 @@ static int rl_kill_index;
 /* How many slots we have in the kill ring. */
 static int rl_kill_ring_length;
 
-static int _rl_copy_to_kill_ring PARAMS((char *, int));
-static int region_kill_internal PARAMS((int));
-static int _rl_copy_word_as_kill PARAMS((int, int));
-static int rl_yank_nth_arg_internal PARAMS((int, int, int));
+static int _rl_copy_to_kill_ring (char *, int);
+static int region_kill_internal (int);
+static int _rl_copy_word_as_kill (int, int);
+static int rl_yank_nth_arg_internal (int, int, int);
 
 /* How to say that you only want to save a certain amount
    of kill material. */
@@ -351,6 +351,30 @@ rl_unix_filename_rubout (int count, int key)
       while (count--)
 	{
 	  c = rl_line_buffer[rl_point - 1];
+
+	  /* First move backwards through whitespace */
+	  while (rl_point && whitespace (c))
+	    {
+	      rl_point--;
+	      c = rl_line_buffer[rl_point - 1];
+	    }
+
+	  /* Consume one or more slashes. */
+	  if (c == '/')
+	    {
+	      int i;
+
+	      i = rl_point - 1;
+	      while (i > 0 && c == '/')
+		c = rl_line_buffer[--i];
+	      if (i == 0 || whitespace (c))
+		{
+		  rl_point = i + whitespace (c);
+		  continue;	/* slashes only */
+		}
+	      c = '/';
+	    }
+
 	  while (rl_point && (whitespace (c) || c == '/'))
 	    {
 	      rl_point--;
@@ -535,7 +559,7 @@ rl_yank_pop (int count, int key)
 int
 rl_vi_yank_pop (int count, int key)
 {
-  int l, n;
+  int l, n, origpoint;
 
   if (((rl_last_func != rl_vi_yank_pop) && (rl_last_func != rl_vi_put)) ||
       !rl_kill_ring)
@@ -545,11 +569,21 @@ rl_vi_yank_pop (int count, int key)
     }
 
   l = strlen (rl_kill_ring[rl_kill_index]);
+#if 0 /* TAG:readline-8.3 8/29/2022 matteopaolini1995@gmail.com */
+  origpoint = rl_point;
+  n = rl_point - l + 1;
+#else
   n = rl_point - l;
+#endif
   if (n >= 0 && STREQN (rl_line_buffer + n, rl_kill_ring[rl_kill_index], l))
     {
+#if 0 /* TAG:readline-8.3 */
+      rl_delete_text (n, n + l);		/* remember vi cursor positioning */
+      rl_point = origpoint - l;
+#else
       rl_delete_text (n, rl_point);
       rl_point = n;
+#endif
       rl_kill_index--;
       if (rl_kill_index < 0)
 	rl_kill_index = rl_kill_ring_length - 1;
diff --git a/readline/readline/m4/codeset.m4 b/readline/readline/m4/codeset.m4
new file mode 100644
index 0000000000000000000000000000000000000000..280f556fe83dfb4ac832f8533cfc5610feb57275
--- /dev/null
+++ b/readline/readline/m4/codeset.m4
@@ -0,0 +1,24 @@
+# codeset.m4 serial 5 (gettext-0.18.2)
+dnl Copyright (C) 2000-2002, 2006, 2008-2014, 2016, 2019 Free Software
+dnl Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_LANGINFO_CODESET],
+[
+  AC_CACHE_CHECK([for nl_langinfo and CODESET], [am_cv_langinfo_codeset],
+    [AC_LINK_IFELSE(
+       [AC_LANG_PROGRAM(
+          [[#include <langinfo.h>]],
+          [[char* cs = nl_langinfo(CODESET); return !cs;]])],
+       [am_cv_langinfo_codeset=yes],
+       [am_cv_langinfo_codeset=no])
+    ])
+  if test $am_cv_langinfo_codeset = yes; then
+    AC_DEFINE([HAVE_LANGINFO_CODESET], [1],
+      [Define if you have <langinfo.h> and nl_langinfo(CODESET).])
+  fi
+])
diff --git a/readline/readline/macro.c b/readline/readline/macro.c
index 92cc55c36dc001e78ddddd1e488dee0b1d42ab8a..231a24bcda3d2a865f7c4890010cfd0e8dcd5ca5 100644
--- a/readline/readline/macro.c
+++ b/readline/readline/macro.c
@@ -276,6 +276,8 @@ rl_end_kbd_macro (int count, int ignore)
     }
 
   current_macro_index -= rl_key_sequence_length;
+  if (current_macro_index < 0)
+    current_macro_index = 0;
   current_macro[current_macro_index] = '\0';
 
   RL_UNSETSTATE(RL_STATE_MACRODEF);
diff --git a/readline/readline/mbutil.c b/readline/readline/mbutil.c
index 7da3ff17bb53d86085b22ec94b21cb673054c62b..f0f28ce747ffd6eb983c05c46cea69e1a17bd4b7 100644
--- a/readline/readline/mbutil.c
+++ b/readline/readline/mbutil.c
@@ -1,6 +1,6 @@
 /* mbutil.c -- readline multibyte character utility functions */
 
-/* Copyright (C) 2001-2020 Free Software Foundation, Inc.
+/* Copyright (C) 2001-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -153,7 +153,7 @@ _rl_find_next_mbchar_internal (char *string, int seed, int count, int find_non_z
   size_t tmp, len;
   mbstate_t ps;
   int point;
-  wchar_t wc;
+  WCHAR_T wc;
 
   tmp = 0;
 
@@ -183,11 +183,11 @@ _rl_find_next_mbchar_internal (char *string, int seed, int count, int find_non_z
       if (_rl_utf8locale && UTF8_SINGLEBYTE(string[point]))
 	{
 	  tmp = 1;
-	  wc = (wchar_t) string[point];
+	  wc = (WCHAR_T) string[point];
 	  memset(&ps, 0, sizeof(mbstate_t));
 	}
       else
-	tmp = mbrtowc (&wc, string+point, len, &ps);
+	tmp = MBRTOWC (&wc, string+point, len, &ps);
       if (MB_INVALIDCH ((size_t)tmp))
 	{
 	  /* invalid bytes. assume a byte represents a character */
@@ -216,11 +216,11 @@ _rl_find_next_mbchar_internal (char *string, int seed, int count, int find_non_z
 
   if (find_non_zero)
     {
-      tmp = mbrtowc (&wc, string + point, strlen (string + point), &ps);
+      tmp = MBRTOWC (&wc, string + point, strlen (string + point), &ps);
       while (MB_NULLWCH (tmp) == 0 && MB_INVALIDCH (tmp) == 0 && WCWIDTH (wc) == 0)
 	{
 	  point += tmp;
-	  tmp = mbrtowc (&wc, string + point, strlen (string + point), &ps);
+	  tmp = MBRTOWC (&wc, string + point, strlen (string + point), &ps);
 	}
     }
 
@@ -231,11 +231,11 @@ static inline int
 _rl_test_nonzero (char *string, int ind, int len)
 {
   size_t tmp;
-  wchar_t wc;
+  WCHAR_T wc;
   mbstate_t ps;
 
   memset (&ps, 0, sizeof (mbstate_t));
-  tmp = mbrtowc (&wc, string + ind, len - ind, &ps);
+  tmp = MBRTOWC (&wc, string + ind, len - ind, &ps);
   /* treat invalid multibyte sequences as non-zero-width */
   return (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp) || WCWIDTH (wc) > 0);
 }
@@ -293,7 +293,7 @@ _rl_find_prev_mbchar_internal (char *string, int seed, int find_non_zero)
   mbstate_t ps;
   int prev, non_zero_prev, point, length;
   size_t tmp;
-  wchar_t wc;
+  WCHAR_T wc;
 
   if (_rl_utf8locale)
     return (_rl_find_prev_utf8char (string, seed, find_non_zero));
@@ -312,11 +312,11 @@ _rl_find_prev_mbchar_internal (char *string, int seed, int find_non_zero)
       if (_rl_utf8locale && UTF8_SINGLEBYTE(string[point]))
 	{
 	  tmp = 1;
-	  wc = (wchar_t) string[point];
+	  wc = (WCHAR_T) string[point];
 	  memset(&ps, 0, sizeof(mbstate_t));
 	}
       else
-	tmp = mbrtowc (&wc, string + point, length - point, &ps);
+	tmp = MBRTOWC (&wc, string + point, length - point, &ps);
       if (MB_INVALIDCH ((size_t)tmp))
 	{
 	  /* in this case, bytes are invalid or too short to compose
@@ -470,27 +470,27 @@ _rl_is_mbchar_matched (char *string, int seed, int end, char *mbchar, int length
   return 1;
 }
 
-wchar_t
+WCHAR_T
 _rl_char_value (char *buf, int ind)
 {
   size_t tmp;
-  wchar_t wc;
+  WCHAR_T wc;
   mbstate_t ps;
   int l;
 
   if (MB_LEN_MAX == 1 || rl_byte_oriented)
-    return ((wchar_t) buf[ind]);
+    return ((WCHAR_T) buf[ind]);
   if (_rl_utf8locale && UTF8_SINGLEBYTE(buf[ind]))
-    return ((wchar_t) buf[ind]);
+    return ((WCHAR_T) buf[ind]);
   l = strlen (buf);
   if (ind >= l - 1)
-    return ((wchar_t) buf[ind]);
+    return ((WCHAR_T) buf[ind]);
   if (l < ind)			/* Sanity check */
     l = strlen (buf+ind);
   memset (&ps, 0, sizeof (mbstate_t));
-  tmp = mbrtowc (&wc, buf + ind, l - ind, &ps);
+  tmp = MBRTOWC (&wc, buf + ind, l - ind, &ps);
   if (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp))  
-    return ((wchar_t) buf[ind]);
+    return ((WCHAR_T) buf[ind]);
   return wc;
 }
 #endif /* HANDLE_MULTIBYTE */
diff --git a/readline/readline/misc.c b/readline/readline/misc.c
index 3d9a674ca59d9a4de961ac846cd66fe221c4f2c6..4bca9c586101954061d5ccae5ac2153ac6526186 100644
--- a/readline/readline/misc.c
+++ b/readline/readline/misc.c
@@ -1,6 +1,6 @@
 /* misc.c -- miscellaneous bindable readline functions. */
 
-/* Copyright (C) 1987-2019 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2022 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -50,14 +50,12 @@
 #include "history.h"
 
 #include "rlprivate.h"
+#include "histlib.h"
 #include "rlshell.h"
 #include "xmalloc.h"
 
-static int rl_digit_loop PARAMS((void));
-static void _rl_history_set_point PARAMS((void));
-
-/* Forward declarations used in this file */
-void _rl_free_history_entry PARAMS((HIST_ENTRY *));
+static int rl_digit_loop (void);
+static void _rl_history_set_point (void);
 
 /* If non-zero, rl_get_previous_history and rl_get_next_history attempt
    to preserve the value of rl_point from line to line. */
@@ -309,9 +307,9 @@ _rl_start_using_history (void)
 {
   using_history ();
   if (_rl_saved_line_for_history)
-    _rl_free_history_entry (_rl_saved_line_for_history);
-
+    _rl_free_saved_history_line ();
   _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
+  _rl_history_search_pos = -99;		/* some random invalid history position */
 }
 
 /* Free the contents (and containing structure) of a HIST_ENTRY. */
@@ -355,6 +353,8 @@ rl_maybe_unsave_line (void)
 	 list from a history entry, as in rl_replace_from_history() below. */
       rl_replace_line (_rl_saved_line_for_history->line, 0);
       rl_undo_list = (UNDO_LIST *)_rl_saved_line_for_history->data;
+
+      /* Doesn't free `data'. */
       _rl_free_history_entry (_rl_saved_line_for_history);
       _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
       rl_point = rl_end;	/* rl_replace_line sets rl_end */
@@ -382,8 +382,18 @@ rl_maybe_save_line (void)
 int
 _rl_free_saved_history_line (void)
 {
+  UNDO_LIST *orig;
+
   if (_rl_saved_line_for_history)
     {
+      if (rl_undo_list && rl_undo_list == (UNDO_LIST *)_rl_saved_line_for_history->data)
+	rl_undo_list = 0;
+      /* Have to free this separately because _rl_free_history entry can't:
+	 it doesn't know whether or not this has application data. Only the
+	 callers that know this is _rl_saved_line_for_history can know that
+	 it's an undo list. */
+      if (_rl_saved_line_for_history->data)
+	_rl_free_undo_list ((UNDO_LIST *)_rl_saved_line_for_history->data);
       _rl_free_history_entry (_rl_saved_line_for_history);
       _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
     }
@@ -625,7 +635,7 @@ rl_get_previous_history (int count, int key)
   if (temp == 0)
     {
       if (had_saved_line == 0)
-        _rl_free_saved_history_line ();
+	_rl_free_saved_history_line ();
       rl_ding ();
     }
   else
@@ -637,6 +647,42 @@ rl_get_previous_history (int count, int key)
   return 0;
 }
 
+/* With an argument, move back that many history lines, else move to the
+   beginning of history. */
+int
+rl_fetch_history (int count, int c)
+{
+  int wanted, nhist;
+
+  /* Giving an argument of n means we want the nth command in the history
+     file.  The command number is interpreted the same way that the bash
+     `history' command does it -- that is, giving an argument count of 450
+     to this command would get the command listed as number 450 in the
+     output of `history'. */
+  if (rl_explicit_arg)
+    {
+      nhist = history_base + where_history ();
+      /* Negative arguments count back from the end of the history list. */
+      wanted = (count >= 0) ? nhist - count : -count;
+
+      if (wanted <= 0 || wanted >= nhist)
+	{
+	  /* In vi mode, we don't change the line with an out-of-range
+	     argument, as for the `G' command. */
+	  if (rl_editing_mode == vi_mode)
+	    rl_ding ();
+	  else
+	    rl_beginning_of_history (0, 0);
+	}
+      else
+        rl_get_previous_history (wanted, c);
+    }
+  else
+    rl_beginning_of_history (count, 0);
+
+  return (0);
+}
+
 /* The equivalent of the Korn shell C-o operate-and-get-next-history-line
    editing command. */
 
@@ -664,15 +710,13 @@ set_saved_history ()
 }
 
 int
-rl_operate_and_get_next (count, c)
-     int count, c;
+rl_operate_and_get_next (int count, int c)
 {
   /* Accept the current line. */
   rl_newline (1, c);
 
   saved_history_logical_offset = rl_explicit_arg ? count : where_history () + history_base + 1;
 
-
   _rl_saved_internal_startup_hook = _rl_internal_startup_hook;
   _rl_internal_startup_hook = set_saved_history;
 
diff --git a/readline/readline/nls.c b/readline/readline/nls.c
index d2f67e0d3e1ac1a9f085d3e10fbc7af0c129d8e0..8c027d6be500d06d90a7549e70127c3ba16093a6 100644
--- a/readline/readline/nls.c
+++ b/readline/readline/nls.c
@@ -1,6 +1,6 @@
 /* nls.c -- skeletal internationalization code. */
 
-/* Copyright (C) 1996-2017 Free Software Foundation, Inc.
+/* Copyright (C) 1996-2022 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -53,8 +53,12 @@
 #include "readline.h"
 #include "rlshell.h"
 #include "rlprivate.h"
+#include "xmalloc.h"
 
-static int utf8locale PARAMS((char *));
+static int utf8locale (char *);
+
+#define RL_DEFAULT_LOCALE "C"
+static char *_rl_current_locale = 0;
 
 #if !defined (HAVE_SETLOCALE)    
 /* A list of legal values for the LANG or LC_CTYPE environment variables.
@@ -78,12 +82,12 @@ static char *legal_lang_values[] =
   0
 };
 
-static char *normalize_codeset PARAMS((char *));
+static char *normalize_codeset (char *);
 #endif /* !HAVE_SETLOCALE */
 
-static char *find_codeset PARAMS((char *, size_t *));
+static char *find_codeset (char *, size_t *);
 
-static char *_rl_get_locale_var PARAMS((const char *));
+static char *_rl_get_locale_var (const char *);
 
 static char *
 _rl_get_locale_var (const char *v)
@@ -131,50 +135,65 @@ _rl_init_locale (void)
      that doesn't return anything, we set lspec to the empty string to
      force the subsequent call to setlocale() to define the `native'
      environment. */
+#if defined (HAVE_SETLOCALE)
   if (lspec == 0 || *lspec == 0)
     lspec = setlocale (LC_CTYPE, (char *)NULL);
   if (lspec == 0)
     lspec = "";
   ret = setlocale (LC_CTYPE, lspec);	/* ok, since it does not change locale */
+  if (ret == 0 || *ret == 0)
+    ret = setlocale (LC_CTYPE, (char *)NULL);
+  if (ret == 0 || *ret == 0)
+    ret = RL_DEFAULT_LOCALE;
+#else
+  ret = (lspec == 0 || *lspec == 0) ? RL_DEFAULT_LOCALE : lspec;
+#endif
 
   _rl_utf8locale = (ret && *ret) ? utf8locale (ret) : 0;
 
+  _rl_current_locale = savestring (ret);
   return ret;
 }
 
-/* Check for LC_ALL, LC_CTYPE, and LANG and use the first with a value
-   to decide the defaults for 8-bit character input and output.  Returns
-   1 if we set eight-bit mode. */
-int
-_rl_init_eightbit (void)
-{
 /* If we have setlocale(3), just check the current LC_CTYPE category
-   value, and go into eight-bit mode if it's not C or POSIX. */
+   value (passed as LOCALESTR), and go into eight-bit mode if it's not "C"
+   or "POSIX". If FORCE is non-zero, we reset the locale variables to values
+   appropriate for the C locale if the locale is "C" or "POSIX". FORCE is 0
+   when this is called from _rl_init_eightbit, since we're modifying the
+   default initial values and don't need to change anything else. If we
+   don't have setlocale(3), we check the codeset portion of LOCALESTR against
+   a set of known values and go into eight-bit mode if it matches one of those.
+   Returns 1 if we set eight-bit (multibyte) mode. */
+static int
+_rl_set_localevars (char *localestr, int force)
+{
 #if defined (HAVE_SETLOCALE)
-  char *lspec, *t;
-
-  t = _rl_init_locale ();	/* returns static pointer */
-
-  if (t && *t && (t[0] != 'C' || t[1]) && (STREQ (t, "POSIX") == 0))
+  if (localestr && *localestr && (localestr[0] != 'C' || localestr[1]) && (STREQ (localestr, "POSIX") == 0))
     {
       _rl_meta_flag = 1;
       _rl_convert_meta_chars_to_ascii = 0;
       _rl_output_meta_chars = 1;
       return (1);
     }
+  else if (force)
+    {
+      /* Default "C" locale settings. */
+      _rl_meta_flag = 0;
+      _rl_convert_meta_chars_to_ascii = 1;
+      _rl_output_meta_chars = 0;
+      return (0);
+    }
   else
     return (0);
 
 #else /* !HAVE_SETLOCALE */
-  char *lspec, *t;
+  char *t;
   int i;
 
   /* We don't have setlocale.  Finesse it.  Check the environment for the
      appropriate variables and set eight-bit mode if they have the right
      values. */
-  lspec = _rl_get_locale_var ("LC_CTYPE");
-
-  if (lspec == 0 || (t = normalize_codeset (lspec)) == 0)
+  if (localestr == 0 || (t = normalize_codeset (localestr)) == 0)
     return (0);
   for (i = 0; t && legal_lang_values[i]; i++)
     if (STREQ (t, legal_lang_values[i]))
@@ -185,6 +204,14 @@ _rl_init_eightbit (void)
 	break;
       }
 
+  if (force && legal_lang_values[i] == 0)	/* didn't find it */
+    {
+      /* Default "C" locale settings. */
+      _rl_meta_flag = 0;
+      _rl_convert_meta_chars_to_ascii = 1;
+      _rl_output_meta_chars = 0;
+    }
+
   _rl_utf8locale = *t ? STREQ (t, "utf8") : 0;
 
   xfree (t);
@@ -192,6 +219,21 @@ _rl_init_eightbit (void)
 #endif /* !HAVE_SETLOCALE */
 }
 
+/* Check for LC_ALL, LC_CTYPE, and LANG and use the first with a value
+   to decide the defaults for 8-bit character input and output.  Returns
+   1 if we set eight-bit mode. */
+int
+_rl_init_eightbit (void)
+{
+  char *t, *ol;
+
+  ol = _rl_current_locale;
+  t = _rl_init_locale ();	/* resets _rl_current_locale, returns static pointer */
+  xfree (ol);
+
+  return (_rl_set_localevars (t, 0));
+}
+
 #if !defined (HAVE_SETLOCALE)
 static char *
 normalize_codeset (char *codeset)
@@ -288,3 +330,19 @@ find_codeset (char *name, size_t *lenp)
 
   return result;
 }
+
+void
+_rl_reset_locale (void)
+{
+  char *ol, *nl;
+
+  /* This should not be NULL; _rl_init_eightbit sets it on the first call to
+     readline() or rl_initialize(). */
+  ol = _rl_current_locale;
+  nl = _rl_init_locale ();		/* resets _rl_current_locale */
+
+  if ((ol == 0 && nl) || (ol && nl && (STREQ (ol, nl) == 0)))
+    (void)_rl_set_localevars (nl, 1);
+
+  xfree (ol);
+}
diff --git a/readline/readline/parens.c b/readline/readline/parens.c
index af4797736293d4cefa2d9c57784a1c83a03b434c..57ce70458dad86f8532d009a5d2a1a9643067470 100644
--- a/readline/readline/parens.c
+++ b/readline/readline/parens.c
@@ -1,6 +1,6 @@
 /* parens.c -- implementation of matching parentheses feature. */
 
-/* Copyright (C) 1987, 1989, 1992-2015, 2017 Free Software Foundation, Inc.
+/* Copyright (C) 1987, 1989, 1992-2015, 2017, 2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -53,7 +53,7 @@ extern char *strchr (), *strrchr ();
 #include "readline.h"
 #include "rlprivate.h"
 
-static int find_matching_open PARAMS((char *, int, int));
+static int find_matching_open (char *, int, int);
 
 /* Non-zero means try to blink the matching open parenthesis when the
    close parenthesis is inserted. */
@@ -135,7 +135,11 @@ rl_insert_close (int count, int invoking_key)
       orig_point = rl_point;
       rl_point = match_point;
       (*rl_redisplay_function) ();
+#  if defined (RL_TIMEOUT_USE_SELECT)
+      ready = _rl_timeout_select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer, NULL);
+#  else
       ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
+#  endif
       rl_point = orig_point;
 #else /* !HAVE_SELECT */
       _rl_insert_char (count, invoking_key);
diff --git a/readline/readline/patchlevel b/readline/readline/patchlevel
index d8c9df7e6bb19b63a7c7f1c4f192a91529e40699..fa58ba54d82a04548ac0deea07d8e7b1500daf11 100644
--- a/readline/readline/patchlevel
+++ b/readline/readline/patchlevel
@@ -1,3 +1,3 @@
 # Do not edit -- exists only for use by patch
 
-0
+13
diff --git a/readline/readline/posixdir.h b/readline/readline/posixdir.h
index af5be8012b347eee3b62ba0e78f36109619999e0..b737bd7d1ce1e9a06fccc1bbf369119d772f85ee 100644
--- a/readline/readline/posixdir.h
+++ b/readline/readline/posixdir.h
@@ -1,6 +1,6 @@
 /* posixdir.h -- Posix directory reading includes and defines. */
 
-/* Copyright (C) 1987,1991,2012 Free Software Foundation, Inc.
+/* Copyright (C) 1987,1991,2012,2019,2021 Free Software Foundation, Inc.
 
    This file is part of GNU Bash, the Bourne Again SHell.
 
diff --git a/readline/readline/posixtime.h b/readline/readline/posixtime.h
new file mode 100644
index 0000000000000000000000000000000000000000..e70ebec67cf08e756b0f32af79234ff11de103d8
--- /dev/null
+++ b/readline/readline/posixtime.h
@@ -0,0 +1,84 @@
+/* posixtime.h -- wrapper for time.h, sys/times.h mess. */
+
+/* Copyright (C) 1999-2021 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   Bash is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _POSIXTIME_H_
+#define _POSIXTIME_H_
+
+/* include this after config.h */
+/* Some systems require this, mostly for the definition of `struct timezone'.
+   For example, Dynix/ptx has that definition in <time.h> rather than
+      sys/time.h */
+#if defined (HAVE_SYS_TIME_H)
+#  include <sys/time.h>
+#endif
+#include <time.h>
+
+#if !defined (HAVE_SYSCONF) || !defined (_SC_CLK_TCK)
+#  if !defined (CLK_TCK)
+#    if defined (HZ)
+#      define CLK_TCK	HZ
+#    else
+#      define CLK_TCK	60			/* 60HZ */
+#    endif
+#  endif /* !CLK_TCK */
+#endif /* !HAVE_SYSCONF && !_SC_CLK_TCK */
+
+#if !HAVE_TIMEVAL
+struct timeval
+{
+  time_t tv_sec;
+  long int tv_usec;
+};
+#endif
+
+#if !HAVE_GETTIMEOFDAY
+extern int gettimeofday PARAMS((struct timeval *, void *));
+#endif
+
+/* These exist on BSD systems, at least. */
+#if !defined (timerclear)
+#  define timerclear(tvp)	do { (tvp)->tv_sec = 0; (tvp)->tv_usec = 0; } while (0)
+#endif
+#if !defined (timerisset)
+#  define timerisset(tvp)	((tvp)->tv_sec || (tvp)->tv_usec)
+#endif
+#if !defined (timercmp)
+#  define timercmp(a, b, CMP) \
+	(((a)->tv_sec == (b)->tv_sec) ? ((a)->tv_usec CMP (b)->tv_usec) \
+				      : ((a)->tv_sec CMP (b)->tv_sec))
+#endif
+
+/* These are non-standard. */
+#if !defined (timerisunset)
+#  define timerisunset(tvp)	((tvp)->tv_sec == 0 && (tvp)->tv_usec == 0)
+#endif
+#if !defined (timerset)
+#  define timerset(tvp, s, u)	do { tvp->tv_sec = s; tvp->tv_usec = u; } while (0)
+#endif
+
+#ifndef TIMEVAL_TO_TIMESPEC
+#  define TIMEVAL_TO_TIMESPEC(tv, ts) \
+  do { \
+    (ts)->tv_sec = (tv)->tv_sec; \
+    (ts)->tv_nsec = (tv)->tv_usec * 1000; \
+  } while (0)
+#endif
+
+#endif /* _POSIXTIME_H_ */
diff --git a/readline/readline/readline.c b/readline/readline/readline.c
index 0e33587f23409157a784635f0c85f721dbbecbeb..d649af541e8889901d5533199a2fc327cbb29914 100644
--- a/readline/readline/readline.c
+++ b/readline/readline/readline.c
@@ -72,35 +72,34 @@ extern int errno;
 #include "rlshell.h"
 #include "xmalloc.h"
 
-#ifndef RL_LIBRARY_VERSION
-#  define RL_LIBRARY_VERSION "8.0"
+#if defined (COLOR_SUPPORT)
+#  include "parse-colors.h"
 #endif
 
-#ifndef RL_READLINE_VERSION
-#  define RL_READLINE_VERSION	0x0800
+#ifndef RL_LIBRARY_VERSION
+#  define RL_LIBRARY_VERSION "8.1"
 #endif
 
-extern void _rl_free_history_entry PARAMS((HIST_ENTRY *));
-
-#if defined (COLOR_SUPPORT)
-extern void _rl_parse_colors PARAMS((void));		/* XXX */
+#ifndef RL_READLINE_VERSION
+#  define RL_READLINE_VERSION	0x0801
 #endif
 
-
 /* Forward declarations used in this file. */
-static char *readline_internal PARAMS((void));
-static void readline_initialize_everything PARAMS((void));
+static char *readline_internal (void);
+static void readline_initialize_everything (void);
+
+static void run_startup_hooks (void);
 
-static void bind_arrow_keys_internal PARAMS((Keymap));
-static void bind_arrow_keys PARAMS((void));
+static void bind_arrow_keys_internal (Keymap);
+static void bind_arrow_keys (void);
 
-static void bind_bracketed_paste_prefix PARAMS((void));
+static void bind_bracketed_paste_prefix (void);
 
-static void readline_default_bindings PARAMS((void));
-static void reset_default_bindings PARAMS((void));
+static void readline_default_bindings (void);
+static void reset_default_bindings (void);
 
-static int _rl_subseq_result PARAMS((int, Keymap, int, int));
-static int _rl_subseq_getchar PARAMS((int));
+static int _rl_subseq_result (int, Keymap, int, int);
+static int _rl_subseq_getchar (int);
 
 /* **************************************************************** */
 /*								    */
@@ -241,6 +240,9 @@ char *_rl_comment_begin;
 /* Keymap holding the function currently being executed. */
 Keymap rl_executing_keymap;
 
+/* The function currently being executed. */
+rl_command_func_t *_rl_executing_func;
+
 /* Keymap we're currently using to dispatch. */
 Keymap _rl_dispatching_keymap;
 
@@ -403,6 +405,16 @@ readline (const char *prompt)
   return (value);
 }
 
+static void
+run_startup_hooks (void)
+{
+  if (rl_startup_hook)
+    (*rl_startup_hook) ();
+
+  if (_rl_internal_startup_hook)
+    (*_rl_internal_startup_hook) ();
+}
+
 #if defined (READLINE_CALLBACKS)
 #  define STATIC_CALLBACK
 #else
@@ -422,11 +434,7 @@ readline_internal_setup (void)
   if (_rl_enable_meta & RL_ISSTATE (RL_STATE_TERMPREPPED))
     _rl_enable_meta_key ();
 
-  if (rl_startup_hook)
-    (*rl_startup_hook) ();
-
-  if (_rl_internal_startup_hook)
-    (*_rl_internal_startup_hook) ();
+  run_startup_hooks ();
 
   rl_deactivate_mark ();
 
@@ -481,8 +489,11 @@ readline_internal_teardown (int eof)
      are editing was originally in the history, AND the line has changed. */
   entry = current_history ();
 
+  /* We don't want to do this if we executed functions that call
+     history_set_pos to set the history offset to the line containing the
+     non-incremental search string. */
   if (entry && rl_undo_list)
-    {
+   {
       temp = savestring (the_line);
       rl_revert_line (1, 0);
       entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
@@ -514,6 +525,11 @@ readline_internal_teardown (int eof)
 void
 _rl_internal_char_cleanup (void)
 {
+  if (_rl_keep_mark_active)
+    _rl_keep_mark_active = 0;
+  else if (rl_mark_active_p ())
+    rl_deactivate_mark ();
+
 #if defined (VI_MODE)
   /* In vi mode, when you exit insert mode, the cursor moves back
      over the previous character.  We explicitly check for that here. */
@@ -570,6 +586,15 @@ readline_internal_charloop (void)
 	{
 	  (*rl_redisplay_function) ();
 	  _rl_want_redisplay = 0;
+
+	  /* If we longjmped because of a timeout, handle it here. */
+	  if (RL_ISSTATE (RL_STATE_TIMEOUT))
+	    {
+	      RL_SETSTATE (RL_STATE_DONE);
+	      rl_done = 1;
+	      return 1;
+	    }
+
 	  /* If we get here, we're not being called from something dispatched
 	     from _rl_callback_read_char(), which sets up its own value of
 	     _rl_top_level (saving and restoring the old, of course), so
@@ -657,6 +682,8 @@ readline_internal_charloop (void)
 	  rl_executing_keymap = _rl_command_to_execute->map;
 	  rl_executing_key = _rl_command_to_execute->key;
 
+	  _rl_executing_func = _rl_command_to_execute->func;
+
 	  rl_dispatching = 1;
 	  RL_SETSTATE(RL_STATE_DISPATCHING);
 	  r = (*(_rl_command_to_execute->func)) (_rl_command_to_execute->count, _rl_command_to_execute->key);
@@ -673,11 +700,6 @@ readline_internal_charloop (void)
       if (rl_pending_input == 0 && lk == _rl_last_command_was_kill)
 	_rl_last_command_was_kill = 0;
 
-      if (_rl_keep_mark_active)
-        _rl_keep_mark_active = 0;
-      else if (rl_mark_active_p ())
-        rl_deactivate_mark ();
-
       _rl_internal_char_cleanup ();
 
 #if defined (READLINE_CALLBACKS)
@@ -877,12 +899,23 @@ _rl_dispatch_subseq (register int key, Keymap map, int got_subseq)
 	{
 	  /* Special case rl_do_lowercase_version (). */
 	  if (func == rl_do_lowercase_version)
-	    /* Should we do anything special if key == ANYOTHERKEY? */
-	    return (_rl_dispatch (_rl_to_lower ((unsigned char)key), map));
+	    {
+	      /* Should we do anything special if key == ANYOTHERKEY? */
+	      newkey = _rl_to_lower ((unsigned char)key);
+	      if (newkey != key)
+		return (_rl_dispatch (newkey, map));
+	      else
+		{
+		  rl_ding ();		/* gentle failure */
+		  return 0;
+		}
+	    }
 
 	  rl_executing_keymap = map;
 	  rl_executing_key = key;
 
+	  _rl_executing_func = func;
+
 	  RESIZE_KEYSEQ_BUFFER();
 	  rl_executing_keyseq[rl_key_sequence_length++] = key;
 	  rl_executing_keyseq[rl_key_sequence_length] = '\0';
@@ -1085,7 +1118,11 @@ _rl_subseq_result (int r, Keymap map, int key, int got_subseq)
       type = m[ANYOTHERKEY].type;
       func = m[ANYOTHERKEY].function;
       if (type == ISFUNC && func == rl_do_lowercase_version)
-	r = _rl_dispatch (_rl_to_lower ((unsigned char)key), map);
+	{
+	  int newkey = _rl_to_lower ((unsigned char)key);
+	  /* check that there is actually a lowercase version to avoid infinite recursion */
+	  r = (newkey != key) ? _rl_dispatch (newkey, map) : 1;
+	}
       else if (type == ISFUNC)
 	{
 	  /* If we shadowed a function, whatever it is, we somehow need a
@@ -1148,6 +1185,9 @@ _rl_subseq_result (int r, Keymap map, int key, int got_subseq)
 int
 rl_initialize (void)
 {
+  /* Initialize the timeout first to get the precise start time. */
+  _rl_timeout_init ();
+
   /* If we have never been called before, initialize the
      terminal and data structures. */
   if (rl_initialized == 0)
@@ -1159,14 +1199,14 @@ rl_initialize (void)
       RL_SETSTATE(RL_STATE_INITIALIZED);
     }
   else
-    (void)_rl_init_locale ();	/* check current locale */
+    _rl_reset_locale ();	/* check current locale and set locale variables */
 
   /* Initialize the current line information. */
   _rl_init_line_state ();
 
   /* We aren't done yet.  We haven't even gotten started yet! */
   rl_done = 0;
-  RL_UNSETSTATE(RL_STATE_DONE|RL_STATE_EOF);
+  RL_UNSETSTATE(RL_STATE_DONE|RL_STATE_TIMEOUT|RL_STATE_EOF);
 
   /* Tell the history routines what is going on. */
   _rl_start_using_history ();
@@ -1287,8 +1327,8 @@ readline_initialize_everything (void)
 
   /* If the completion parser's default word break characters haven't
      been set yet, then do so now. */
-  if (rl_completer_word_break_characters == (char *)NULL)
-    rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;
+  if (rl_completer_word_break_characters == 0)
+    rl_completer_word_break_characters = rl_basic_word_break_characters;
 
 #if defined (COLOR_SUPPORT)
   if (_rl_colored_stats || _rl_colored_completion_prefix)
@@ -1537,3 +1577,12 @@ _rl_add_executing_keyseq (int key)
   RESIZE_KEYSEQ_BUFFER ();
  rl_executing_keyseq[rl_key_sequence_length++] = key;
 }
+
+/* `delete' the last character added to the executing key sequence. Use this
+   before calling rl_execute_next to avoid keys being added twice. */
+void
+_rl_del_executing_keyseq (void)
+{
+  if (rl_key_sequence_length > 0)
+    rl_key_sequence_length--;
+}
diff --git a/readline/readline/readline.h b/readline/readline/readline.h
index 9f79810f290a6651177d2433417f8e0c2bedd74f..cac269f0b433ca795a929e0c4c4ebde42446f7de 100644
--- a/readline/readline/readline.h
+++ b/readline/readline/readline.h
@@ -39,9 +39,9 @@ extern "C" {
 #endif
 
 /* Hex-encoded Readline version number. */
-#define RL_READLINE_VERSION	0x0801		/* Readline 8.0 */
+#define RL_READLINE_VERSION	0x0802		/* Readline 8.2 */
 #define RL_VERSION_MAJOR	8
-#define RL_VERSION_MINOR	1
+#define RL_VERSION_MINOR	2
 
 /* Readline data structures. */
 
@@ -79,211 +79,212 @@ extern FUNMAP **funmap;
 /* **************************************************************** */
 
 /* Bindable commands for numeric arguments. */
-extern int rl_digit_argument PARAMS((int, int));
-extern int rl_universal_argument PARAMS((int, int));
+extern int rl_digit_argument (int, int);
+extern int rl_universal_argument (int, int);
 
 /* Bindable commands for moving the cursor. */
-extern int rl_forward_byte PARAMS((int, int));
-extern int rl_forward_char PARAMS((int, int));
-extern int rl_forward PARAMS((int, int));
-extern int rl_backward_byte PARAMS((int, int));
-extern int rl_backward_char PARAMS((int, int));
-extern int rl_backward PARAMS((int, int));
-extern int rl_beg_of_line PARAMS((int, int));
-extern int rl_end_of_line PARAMS((int, int));
-extern int rl_forward_word PARAMS((int, int));
-extern int rl_backward_word PARAMS((int, int));
-extern int rl_refresh_line PARAMS((int, int));
-extern int rl_clear_screen PARAMS((int, int));
-extern int rl_clear_display PARAMS((int, int));
-extern int rl_skip_csi_sequence PARAMS((int, int));
-extern int rl_arrow_keys PARAMS((int, int));
-
-extern int rl_previous_screen_line PARAMS((int, int));
-extern int rl_next_screen_line PARAMS((int, int));
+extern int rl_forward_byte (int, int);
+extern int rl_forward_char (int, int);
+extern int rl_forward (int, int);
+extern int rl_backward_byte (int, int);
+extern int rl_backward_char (int, int);
+extern int rl_backward (int, int);
+extern int rl_beg_of_line (int, int);
+extern int rl_end_of_line (int, int);
+extern int rl_forward_word (int, int);
+extern int rl_backward_word (int, int);
+extern int rl_refresh_line (int, int);
+extern int rl_clear_screen (int, int);
+extern int rl_clear_display (int, int);
+extern int rl_skip_csi_sequence (int, int);
+extern int rl_arrow_keys (int, int);
+
+extern int rl_previous_screen_line (int, int);
+extern int rl_next_screen_line (int, int);
 
 /* Bindable commands for inserting and deleting text. */
-extern int rl_insert PARAMS((int, int));
-extern int rl_quoted_insert PARAMS((int, int));
-extern int rl_tab_insert PARAMS((int, int));
-extern int rl_newline PARAMS((int, int));
-extern int rl_do_lowercase_version PARAMS((int, int));
-extern int rl_rubout PARAMS((int, int));
-extern int rl_delete PARAMS((int, int));
-extern int rl_rubout_or_delete PARAMS((int, int));
-extern int rl_delete_horizontal_space PARAMS((int, int));
-extern int rl_delete_or_show_completions PARAMS((int, int));
-extern int rl_insert_comment PARAMS((int, int));
+extern int rl_insert (int, int);
+extern int rl_quoted_insert (int, int);
+extern int rl_tab_insert (int, int);
+extern int rl_newline (int, int);
+extern int rl_do_lowercase_version (int, int);
+extern int rl_rubout (int, int);
+extern int rl_delete (int, int);
+extern int rl_rubout_or_delete (int, int);
+extern int rl_delete_horizontal_space (int, int);
+extern int rl_delete_or_show_completions (int, int);
+extern int rl_insert_comment (int, int);
 
 /* Bindable commands for changing case. */
-extern int rl_upcase_word PARAMS((int, int));
-extern int rl_downcase_word PARAMS((int, int));
-extern int rl_capitalize_word PARAMS((int, int));
+extern int rl_upcase_word (int, int);
+extern int rl_downcase_word (int, int);
+extern int rl_capitalize_word (int, int);
 
 /* Bindable commands for transposing characters and words. */
-extern int rl_transpose_words PARAMS((int, int));
-extern int rl_transpose_chars PARAMS((int, int));
+extern int rl_transpose_words (int, int);
+extern int rl_transpose_chars (int, int);
 
 /* Bindable commands for searching within a line. */
-extern int rl_char_search PARAMS((int, int));
-extern int rl_backward_char_search PARAMS((int, int));
+extern int rl_char_search (int, int);
+extern int rl_backward_char_search (int, int);
 
 /* Bindable commands for readline's interface to the command history. */
-extern int rl_beginning_of_history PARAMS((int, int));
-extern int rl_end_of_history PARAMS((int, int));
-extern int rl_get_next_history PARAMS((int, int));
-extern int rl_get_previous_history PARAMS((int, int));
-extern int rl_operate_and_get_next PARAMS((int, int));
+extern int rl_beginning_of_history (int, int);
+extern int rl_end_of_history (int, int);
+extern int rl_get_next_history (int, int);
+extern int rl_get_previous_history (int, int);
+extern int rl_operate_and_get_next (int, int);
+extern int rl_fetch_history (int, int);
 
 /* Bindable commands for managing the mark and region. */
-extern int rl_set_mark PARAMS((int, int));
-extern int rl_exchange_point_and_mark PARAMS((int, int));
+extern int rl_set_mark (int, int);
+extern int rl_exchange_point_and_mark (int, int);
 
 /* Bindable commands to set the editing mode (emacs or vi). */
-extern int rl_vi_editing_mode PARAMS((int, int));
-extern int rl_emacs_editing_mode PARAMS((int, int));
+extern int rl_vi_editing_mode (int, int);
+extern int rl_emacs_editing_mode (int, int);
 
 /* Bindable commands to change the insert mode (insert or overwrite) */
-extern int rl_overwrite_mode PARAMS((int, int));
+extern int rl_overwrite_mode (int, int);
 
 /* Bindable commands for managing key bindings. */
-extern int rl_re_read_init_file PARAMS((int, int));
-extern int rl_dump_functions PARAMS((int, int));
-extern int rl_dump_macros PARAMS((int, int));
-extern int rl_dump_variables PARAMS((int, int));
+extern int rl_re_read_init_file (int, int);
+extern int rl_dump_functions (int, int);
+extern int rl_dump_macros (int, int);
+extern int rl_dump_variables (int, int);
 
 /* Bindable commands for word completion. */
-extern int rl_complete PARAMS((int, int));
-extern int rl_possible_completions PARAMS((int, int));
-extern int rl_insert_completions PARAMS((int, int));
-extern int rl_old_menu_complete PARAMS((int, int));
-extern int rl_menu_complete PARAMS((int, int));
-extern int rl_backward_menu_complete PARAMS((int, int));
+extern int rl_complete (int, int);
+extern int rl_possible_completions (int, int);
+extern int rl_insert_completions (int, int);
+extern int rl_old_menu_complete (int, int);
+extern int rl_menu_complete (int, int);
+extern int rl_backward_menu_complete (int, int);
 
 /* Bindable commands for killing and yanking text, and managing the kill ring. */
-extern int rl_kill_word PARAMS((int, int));
-extern int rl_backward_kill_word PARAMS((int, int));
-extern int rl_kill_line PARAMS((int, int));
-extern int rl_backward_kill_line PARAMS((int, int));
-extern int rl_kill_full_line PARAMS((int, int));
-extern int rl_unix_word_rubout PARAMS((int, int));
-extern int rl_unix_filename_rubout PARAMS((int, int));
-extern int rl_unix_line_discard PARAMS((int, int));
-extern int rl_copy_region_to_kill PARAMS((int, int));
-extern int rl_kill_region PARAMS((int, int));
-extern int rl_copy_forward_word PARAMS((int, int));
-extern int rl_copy_backward_word PARAMS((int, int));
-extern int rl_yank PARAMS((int, int));
-extern int rl_yank_pop PARAMS((int, int));
-extern int rl_yank_nth_arg PARAMS((int, int));
-extern int rl_yank_last_arg PARAMS((int, int));
-extern int rl_bracketed_paste_begin PARAMS((int, int));
+extern int rl_kill_word (int, int);
+extern int rl_backward_kill_word (int, int);
+extern int rl_kill_line (int, int);
+extern int rl_backward_kill_line (int, int);
+extern int rl_kill_full_line (int, int);
+extern int rl_unix_word_rubout (int, int);
+extern int rl_unix_filename_rubout (int, int);
+extern int rl_unix_line_discard (int, int);
+extern int rl_copy_region_to_kill (int, int);
+extern int rl_kill_region (int, int);
+extern int rl_copy_forward_word (int, int);
+extern int rl_copy_backward_word (int, int);
+extern int rl_yank (int, int);
+extern int rl_yank_pop (int, int);
+extern int rl_yank_nth_arg (int, int);
+extern int rl_yank_last_arg (int, int);
+extern int rl_bracketed_paste_begin (int, int);
 /* Not available unless _WIN32 is defined. */
 #if defined (_WIN32)
-extern int rl_paste_from_clipboard PARAMS((int, int));
+extern int rl_paste_from_clipboard (int, int);
 #endif
 
 /* Bindable commands for incremental searching. */
-extern int rl_reverse_search_history PARAMS((int, int));
-extern int rl_forward_search_history PARAMS((int, int));
+extern int rl_reverse_search_history (int, int);
+extern int rl_forward_search_history (int, int);
 
 /* Bindable keyboard macro commands. */
-extern int rl_start_kbd_macro PARAMS((int, int));
-extern int rl_end_kbd_macro PARAMS((int, int));
-extern int rl_call_last_kbd_macro PARAMS((int, int));
-extern int rl_print_last_kbd_macro PARAMS((int, int));
+extern int rl_start_kbd_macro (int, int);
+extern int rl_end_kbd_macro (int, int);
+extern int rl_call_last_kbd_macro (int, int);
+extern int rl_print_last_kbd_macro (int, int);
 
 /* Bindable undo commands. */
-extern int rl_revert_line PARAMS((int, int));
-extern int rl_undo_command PARAMS((int, int));
+extern int rl_revert_line (int, int);
+extern int rl_undo_command (int, int);
 
 /* Bindable tilde expansion commands. */
-extern int rl_tilde_expand PARAMS((int, int));
+extern int rl_tilde_expand (int, int);
 
 /* Bindable terminal control commands. */
-extern int rl_restart_output PARAMS((int, int));
-extern int rl_stop_output PARAMS((int, int));
+extern int rl_restart_output (int, int);
+extern int rl_stop_output (int, int);
 
 /* Miscellaneous bindable commands. */
-extern int rl_abort PARAMS((int, int));
-extern int rl_tty_status PARAMS((int, int));
+extern int rl_abort (int, int);
+extern int rl_tty_status (int, int);
 
 /* Bindable commands for incremental and non-incremental history searching. */
-extern int rl_history_search_forward PARAMS((int, int));
-extern int rl_history_search_backward PARAMS((int, int));
-extern int rl_history_substr_search_forward PARAMS((int, int));
-extern int rl_history_substr_search_backward PARAMS((int, int));
-extern int rl_noninc_forward_search PARAMS((int, int));
-extern int rl_noninc_reverse_search PARAMS((int, int));
-extern int rl_noninc_forward_search_again PARAMS((int, int));
-extern int rl_noninc_reverse_search_again PARAMS((int, int));
+extern int rl_history_search_forward (int, int);
+extern int rl_history_search_backward (int, int);
+extern int rl_history_substr_search_forward (int, int);
+extern int rl_history_substr_search_backward (int, int);
+extern int rl_noninc_forward_search (int, int);
+extern int rl_noninc_reverse_search (int, int);
+extern int rl_noninc_forward_search_again (int, int);
+extern int rl_noninc_reverse_search_again (int, int);
 
 /* Bindable command used when inserting a matching close character. */
-extern int rl_insert_close PARAMS((int, int));
+extern int rl_insert_close (int, int);
 
 /* Not available unless READLINE_CALLBACKS is defined. */
-extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));
-extern void rl_callback_read_char PARAMS((void));
-extern void rl_callback_handler_remove PARAMS((void));
-extern void rl_callback_sigcleanup PARAMS((void));
+extern void rl_callback_handler_install (const char *, rl_vcpfunc_t *);
+extern void rl_callback_read_char (void);
+extern void rl_callback_handler_remove (void);
+extern void rl_callback_sigcleanup (void);
 
 /* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
 /* VI-mode bindable commands. */
-extern int rl_vi_redo PARAMS((int, int));
-extern int rl_vi_undo PARAMS((int, int));
-extern int rl_vi_yank_arg PARAMS((int, int));
-extern int rl_vi_fetch_history PARAMS((int, int));
-extern int rl_vi_search_again PARAMS((int, int));
-extern int rl_vi_search PARAMS((int, int));
-extern int rl_vi_complete PARAMS((int, int));
-extern int rl_vi_tilde_expand PARAMS((int, int));
-extern int rl_vi_prev_word PARAMS((int, int));
-extern int rl_vi_next_word PARAMS((int, int));
-extern int rl_vi_end_word PARAMS((int, int));
-extern int rl_vi_insert_beg PARAMS((int, int));
-extern int rl_vi_append_mode PARAMS((int, int));
-extern int rl_vi_append_eol PARAMS((int, int));
-extern int rl_vi_eof_maybe PARAMS((int, int));
-extern int rl_vi_insertion_mode PARAMS((int, int));
-extern int rl_vi_insert_mode PARAMS((int, int));
-extern int rl_vi_movement_mode PARAMS((int, int));
-extern int rl_vi_arg_digit PARAMS((int, int));
-extern int rl_vi_change_case PARAMS((int, int));
-extern int rl_vi_put PARAMS((int, int));
-extern int rl_vi_column PARAMS((int, int));
-extern int rl_vi_delete_to PARAMS((int, int));
-extern int rl_vi_change_to PARAMS((int, int));
-extern int rl_vi_yank_to PARAMS((int, int));
-extern int rl_vi_yank_pop PARAMS((int, int));
-extern int rl_vi_rubout PARAMS((int, int));
-extern int rl_vi_delete PARAMS((int, int));
-extern int rl_vi_back_to_indent PARAMS((int, int));
-extern int rl_vi_unix_word_rubout PARAMS((int, int));
-extern int rl_vi_first_print PARAMS((int, int));
-extern int rl_vi_char_search PARAMS((int, int));
-extern int rl_vi_match PARAMS((int, int));
-extern int rl_vi_change_char PARAMS((int, int));
-extern int rl_vi_subst PARAMS((int, int));
-extern int rl_vi_overstrike PARAMS((int, int));
-extern int rl_vi_overstrike_delete PARAMS((int, int));
-extern int rl_vi_replace PARAMS((int, int));
-extern int rl_vi_set_mark PARAMS((int, int));
-extern int rl_vi_goto_mark PARAMS((int, int));
+extern int rl_vi_redo (int, int);
+extern int rl_vi_undo (int, int);
+extern int rl_vi_yank_arg (int, int);
+extern int rl_vi_fetch_history (int, int);
+extern int rl_vi_search_again (int, int);
+extern int rl_vi_search (int, int);
+extern int rl_vi_complete (int, int);
+extern int rl_vi_tilde_expand (int, int);
+extern int rl_vi_prev_word (int, int);
+extern int rl_vi_next_word (int, int);
+extern int rl_vi_end_word (int, int);
+extern int rl_vi_insert_beg (int, int);
+extern int rl_vi_append_mode (int, int);
+extern int rl_vi_append_eol (int, int);
+extern int rl_vi_eof_maybe (int, int);
+extern int rl_vi_insertion_mode (int, int);
+extern int rl_vi_insert_mode (int, int);
+extern int rl_vi_movement_mode (int, int);
+extern int rl_vi_arg_digit (int, int);
+extern int rl_vi_change_case (int, int);
+extern int rl_vi_put (int, int);
+extern int rl_vi_column (int, int);
+extern int rl_vi_delete_to (int, int);
+extern int rl_vi_change_to (int, int);
+extern int rl_vi_yank_to (int, int);
+extern int rl_vi_yank_pop (int, int);
+extern int rl_vi_rubout (int, int);
+extern int rl_vi_delete (int, int);
+extern int rl_vi_back_to_indent (int, int);
+extern int rl_vi_unix_word_rubout (int, int);
+extern int rl_vi_first_print (int, int);
+extern int rl_vi_char_search (int, int);
+extern int rl_vi_match (int, int);
+extern int rl_vi_change_char (int, int);
+extern int rl_vi_subst (int, int);
+extern int rl_vi_overstrike (int, int);
+extern int rl_vi_overstrike_delete (int, int);
+extern int rl_vi_replace (int, int);
+extern int rl_vi_set_mark (int, int);
+extern int rl_vi_goto_mark (int, int);
 
 /* VI-mode utility functions. */
-extern int rl_vi_check PARAMS((void));
-extern int rl_vi_domove PARAMS((int, int *));
-extern int rl_vi_bracktype PARAMS((int));
+extern int rl_vi_check (void);
+extern int rl_vi_domove (int, int *);
+extern int rl_vi_bracktype (int);
 
-extern void rl_vi_start_inserting PARAMS((int, int, int));
+extern void rl_vi_start_inserting (int, int, int);
 
 /* VI-mode pseudo-bindable commands, used as utility functions. */
-extern int rl_vi_fWord PARAMS((int, int));
-extern int rl_vi_bWord PARAMS((int, int));
-extern int rl_vi_eWord PARAMS((int, int));
-extern int rl_vi_fword PARAMS((int, int));
-extern int rl_vi_bword PARAMS((int, int));
-extern int rl_vi_eword PARAMS((int, int));
+extern int rl_vi_fWord (int, int);
+extern int rl_vi_bWord (int, int);
+extern int rl_vi_eWord (int, int);
+extern int rl_vi_fword (int, int);
+extern int rl_vi_bword (int, int);
+extern int rl_vi_eword (int, int);
 
 /* **************************************************************** */
 /*								    */
@@ -293,114 +294,115 @@ extern int rl_vi_eword PARAMS((int, int));
 
 /* Readline functions. */
 /* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
-extern char *readline PARAMS((const char *));
+extern char *readline (const char *);
 
-extern int rl_set_prompt PARAMS((const char *));
-extern int rl_expand_prompt PARAMS((char *));
+extern int rl_set_prompt (const char *);
+extern int rl_expand_prompt (char *);
 
-extern int rl_initialize PARAMS((void));
+extern int rl_initialize (void);
 
 /* Undocumented; unused by readline */
-extern int rl_discard_argument PARAMS((void));
+extern int rl_discard_argument (void);
 
 /* Utility functions to bind keys to readline commands. */
-extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));
-extern int rl_bind_key PARAMS((int, rl_command_func_t *));
-extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));
-extern int rl_unbind_key PARAMS((int));
-extern int rl_unbind_key_in_map PARAMS((int, Keymap));
-extern int rl_bind_key_if_unbound PARAMS((int, rl_command_func_t *));
-extern int rl_bind_key_if_unbound_in_map PARAMS((int, rl_command_func_t *, Keymap));
-extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));
-extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));
-extern int rl_bind_keyseq PARAMS((const char *, rl_command_func_t *));
-extern int rl_bind_keyseq_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
-extern int rl_bind_keyseq_if_unbound PARAMS((const char *, rl_command_func_t *));
-extern int rl_bind_keyseq_if_unbound_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
-extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));
-
-extern char *rl_variable_value PARAMS((const char *));
-extern int rl_variable_bind PARAMS((const char *, const char *));
+extern int rl_add_defun (const char *, rl_command_func_t *, int);
+extern int rl_bind_key (int, rl_command_func_t *);
+extern int rl_bind_key_in_map (int, rl_command_func_t *, Keymap);
+extern int rl_unbind_key (int);
+extern int rl_unbind_key_in_map (int, Keymap);
+extern int rl_bind_key_if_unbound (int, rl_command_func_t *);
+extern int rl_bind_key_if_unbound_in_map (int, rl_command_func_t *, Keymap);
+extern int rl_unbind_function_in_map (rl_command_func_t *, Keymap);
+extern int rl_unbind_command_in_map (const char *, Keymap);
+extern int rl_bind_keyseq (const char *, rl_command_func_t *);
+extern int rl_bind_keyseq_in_map (const char *, rl_command_func_t *, Keymap);
+extern int rl_bind_keyseq_if_unbound (const char *, rl_command_func_t *);
+extern int rl_bind_keyseq_if_unbound_in_map (const char *, rl_command_func_t *, Keymap);
+extern int rl_generic_bind (int, const char *, char *, Keymap);
+
+extern char *rl_variable_value (const char *);
+extern int rl_variable_bind (const char *, const char *);
 
 /* Backwards compatibility, use rl_bind_keyseq_in_map instead. */
-extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));
+extern int rl_set_key (const char *, rl_command_func_t *, Keymap);
 
 /* Backwards compatibility, use rl_generic_bind instead. */
-extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));
+extern int rl_macro_bind (const char *, const char *, Keymap);
 
 /* Undocumented in the texinfo manual; not really useful to programs. */
-extern int rl_translate_keyseq PARAMS((const char *, char *, int *));
-extern char *rl_untranslate_keyseq PARAMS((int));
+extern int rl_translate_keyseq (const char *, char *, int *);
+extern char *rl_untranslate_keyseq (int);
 
-extern rl_command_func_t *rl_named_function PARAMS((const char *));
-extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));
-extern rl_command_func_t *rl_function_of_keyseq_len PARAMS((const char *, size_t, Keymap, int *));
+extern rl_command_func_t *rl_named_function (const char *);
+extern rl_command_func_t *rl_function_of_keyseq (const char *, Keymap, int *);
+extern rl_command_func_t *rl_function_of_keyseq_len (const char *, size_t, Keymap, int *);
+extern int rl_trim_arg_from_keyseq (const char *, size_t, Keymap);
 
-extern void rl_list_funmap_names PARAMS((void));
-extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));
-extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));
+extern void rl_list_funmap_names (void);
+extern char **rl_invoking_keyseqs_in_map (rl_command_func_t *, Keymap);
+extern char **rl_invoking_keyseqs (rl_command_func_t *);
  
-extern void rl_function_dumper PARAMS((int));
-extern void rl_macro_dumper PARAMS((int));
-extern void rl_variable_dumper PARAMS((int));
+extern void rl_function_dumper (int);
+extern void rl_macro_dumper (int);
+extern void rl_variable_dumper (int);
 
-extern int rl_read_init_file PARAMS((const char *));
-extern int rl_parse_and_bind PARAMS((char *));
+extern int rl_read_init_file (const char *);
+extern int rl_parse_and_bind (char *);
 
 /* Functions for manipulating keymaps. */
-extern Keymap rl_make_bare_keymap PARAMS((void));
-extern int rl_empty_keymap PARAMS((Keymap));
-extern Keymap rl_copy_keymap PARAMS((Keymap));
-extern Keymap rl_make_keymap PARAMS((void));
-extern void rl_discard_keymap PARAMS((Keymap));
-extern void rl_free_keymap PARAMS((Keymap));
+extern Keymap rl_make_bare_keymap (void);
+extern int rl_empty_keymap (Keymap);
+extern Keymap rl_copy_keymap (Keymap);
+extern Keymap rl_make_keymap (void);
+extern void rl_discard_keymap (Keymap);
+extern void rl_free_keymap (Keymap);
 
-extern Keymap rl_get_keymap_by_name PARAMS((const char *));
-extern char *rl_get_keymap_name PARAMS((Keymap));
-extern void rl_set_keymap PARAMS((Keymap));
-extern Keymap rl_get_keymap PARAMS((void));
+extern Keymap rl_get_keymap_by_name (const char *);
+extern char *rl_get_keymap_name (Keymap);
+extern void rl_set_keymap (Keymap);
+extern Keymap rl_get_keymap (void);
 
-extern int rl_set_keymap_name PARAMS((const char *, Keymap));
+extern int rl_set_keymap_name (const char *, Keymap);
 
 /* Undocumented; used internally only. */
-extern void rl_set_keymap_from_edit_mode PARAMS((void));
-extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));
+extern void rl_set_keymap_from_edit_mode (void);
+extern char *rl_get_keymap_name_from_edit_mode (void);
 
 /* Functions for manipulating the funmap, which maps command names to functions. */
-extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));
-extern const char **rl_funmap_names PARAMS((void));
+extern int rl_add_funmap_entry (const char *, rl_command_func_t *);
+extern const char **rl_funmap_names (void);
 /* Undocumented, only used internally -- there is only one funmap, and this
    function may be called only once. */
-extern void rl_initialize_funmap PARAMS((void));
+extern void rl_initialize_funmap (void);
 
 /* Utility functions for managing keyboard macros. */
-extern void rl_push_macro_input PARAMS((char *));
+extern void rl_push_macro_input (char *);
 
 /* Functions for undoing, from undo.c */
-extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));
-extern void rl_free_undo_list PARAMS((void));
-extern int rl_do_undo PARAMS((void));
-extern int rl_begin_undo_group PARAMS((void));
-extern int rl_end_undo_group PARAMS((void));
-extern int rl_modifying PARAMS((int, int));
+extern void rl_add_undo (enum undo_code, int, int, char *);
+extern void rl_free_undo_list (void);
+extern int rl_do_undo (void);
+extern int rl_begin_undo_group (void);
+extern int rl_end_undo_group (void);
+extern int rl_modifying (int, int);
 
 /* Functions for redisplay. */
-extern void rl_redisplay PARAMS((void));
-extern int rl_on_new_line PARAMS((void));
-extern int rl_on_new_line_with_prompt PARAMS((void));
-extern int rl_forced_update_display PARAMS((void));
-extern int rl_clear_visible_line PARAMS((void));
-extern int rl_clear_message PARAMS((void));
-extern int rl_reset_line_state PARAMS((void));
-extern int rl_crlf PARAMS((void));
+extern void rl_redisplay (void);
+extern int rl_on_new_line (void);
+extern int rl_on_new_line_with_prompt (void);
+extern int rl_forced_update_display (void);
+extern int rl_clear_visible_line (void);
+extern int rl_clear_message (void);
+extern int rl_reset_line_state (void);
+extern int rl_crlf (void);
 
 /* Functions to manage the mark and region, especially the notion of an
    active mark and an active region. */
-extern void rl_keep_mark_active PARAMS((void));
+extern void rl_keep_mark_active (void);
 
-extern void rl_activate_mark PARAMS((void));
-extern void rl_deactivate_mark PARAMS((void));
-extern int rl_mark_active_p PARAMS((void));
+extern void rl_activate_mark (void);
+extern void rl_deactivate_mark (void);
+extern int rl_mark_active_p (void);
 
 #if defined (USE_VARARGS) && defined (PREFER_STDARG)
 extern int rl_message (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));
@@ -408,99 +410,106 @@ extern int rl_message (const char *, ...)  __attribute__((__format__ (printf, 1,
 extern int rl_message ();
 #endif
 
-extern int rl_show_char PARAMS((int));
+extern int rl_show_char (int);
 
 /* Undocumented in texinfo manual. */
-extern int rl_character_len PARAMS((int, int));
-extern void rl_redraw_prompt_last_line PARAMS((void));
+extern int rl_character_len (int, int);
+extern void rl_redraw_prompt_last_line (void);
 
 /* Save and restore internal prompt redisplay information. */
-extern void rl_save_prompt PARAMS((void));
-extern void rl_restore_prompt PARAMS((void));
+extern void rl_save_prompt (void);
+extern void rl_restore_prompt (void);
 
 /* Modifying text. */
-extern void rl_replace_line PARAMS((const char *, int));
-extern int rl_insert_text PARAMS((const char *));
-extern int rl_delete_text PARAMS((int, int));
-extern int rl_kill_text PARAMS((int, int));
-extern char *rl_copy_text PARAMS((int, int));
+extern void rl_replace_line (const char *, int);
+extern int rl_insert_text (const char *);
+extern int rl_delete_text (int, int);
+extern int rl_kill_text (int, int);
+extern char *rl_copy_text (int, int);
 
 /* Terminal and tty mode management. */
-extern void rl_prep_terminal PARAMS((int));
-extern void rl_deprep_terminal PARAMS((void));
-extern void rl_tty_set_default_bindings PARAMS((Keymap));
-extern void rl_tty_unset_default_bindings PARAMS((Keymap));
+extern void rl_prep_terminal (int);
+extern void rl_deprep_terminal (void);
+extern void rl_tty_set_default_bindings (Keymap);
+extern void rl_tty_unset_default_bindings (Keymap);
 
-extern int rl_tty_set_echoing PARAMS((int));
-extern int rl_reset_terminal PARAMS((const char *));
-extern void rl_resize_terminal PARAMS((void));
-extern void rl_set_screen_size PARAMS((int, int));
-extern void rl_get_screen_size PARAMS((int *, int *));
-extern void rl_reset_screen_size PARAMS((void));
+extern int rl_tty_set_echoing (int);
+extern int rl_reset_terminal (const char *);
+extern void rl_resize_terminal (void);
+extern void rl_set_screen_size (int, int);
+extern void rl_get_screen_size (int *, int *);
+extern void rl_reset_screen_size (void);
 
-extern char *rl_get_termcap PARAMS((const char *));
+extern char *rl_get_termcap (const char *);
 
 /* Functions for character input. */
-extern int rl_stuff_char PARAMS((int));
-extern int rl_execute_next PARAMS((int));
-extern int rl_clear_pending_input PARAMS((void));
-extern int rl_read_key PARAMS((void));
-extern int rl_getc PARAMS((FILE *));
-extern int rl_set_keyboard_input_timeout PARAMS((int));
+extern int rl_stuff_char (int);
+extern int rl_execute_next (int);
+extern int rl_clear_pending_input (void);
+extern int rl_read_key (void);
+extern int rl_getc (FILE *);
+extern int rl_set_keyboard_input_timeout (int);
+
+/* Functions to set and reset timeouts. */
+extern int rl_set_timeout (unsigned int, unsigned int);
+extern int rl_timeout_remaining (unsigned int *, unsigned int *);
+
+#undef rl_clear_timeout
+#define rl_clear_timeout() rl_set_timeout (0, 0)
 
 /* `Public' utility functions . */
-extern void rl_extend_line_buffer PARAMS((int));
-extern int rl_ding PARAMS((void));
-extern int rl_alphabetic PARAMS((int));
-extern void rl_free PARAMS((void *));
+extern void rl_extend_line_buffer (int);
+extern int rl_ding (void);
+extern int rl_alphabetic (int);
+extern void rl_free (void *);
 
 /* Readline signal handling, from signals.c */
-extern int rl_set_signals PARAMS((void));
-extern int rl_clear_signals PARAMS((void));
-extern void rl_cleanup_after_signal PARAMS((void));
-extern void rl_reset_after_signal PARAMS((void));
-extern void rl_free_line_state PARAMS((void));
+extern int rl_set_signals (void);
+extern int rl_clear_signals (void);
+extern void rl_cleanup_after_signal (void);
+extern void rl_reset_after_signal (void);
+extern void rl_free_line_state (void);
 
-extern int rl_pending_signal PARAMS((void));
-extern void rl_check_signals PARAMS((void));
+extern int rl_pending_signal (void);
+extern void rl_check_signals (void);
 
-extern void rl_echo_signal_char PARAMS((int)); 
+extern void rl_echo_signal_char (int); 
 
-extern int rl_set_paren_blink_timeout PARAMS((int));
+extern int rl_set_paren_blink_timeout (int);
 
 /* History management functions. */
 
-extern void rl_clear_history PARAMS((void));
+extern void rl_clear_history (void);
 
 /* Undocumented. */
-extern int rl_maybe_save_line PARAMS((void));
-extern int rl_maybe_unsave_line PARAMS((void));
-extern int rl_maybe_replace_line PARAMS((void));
+extern int rl_maybe_save_line (void);
+extern int rl_maybe_unsave_line (void);
+extern int rl_maybe_replace_line (void);
 
 /* Completion functions. */
-extern int rl_complete_internal PARAMS((int));
-extern void rl_display_match_list PARAMS((char **, int, int));
+extern int rl_complete_internal (int);
+extern void rl_display_match_list (char **, int, int);
 
-extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
-extern char *rl_username_completion_function PARAMS((const char *, int));
-extern char *rl_filename_completion_function PARAMS((const char *, int));
+extern char **rl_completion_matches (const char *, rl_compentry_func_t *);
+extern char *rl_username_completion_function (const char *, int);
+extern char *rl_filename_completion_function (const char *, int);
 
-extern int rl_completion_mode PARAMS((rl_command_func_t *));
+extern int rl_completion_mode (rl_command_func_t *);
 
 #if 0
 /* Backwards compatibility (compat.c).  These will go away sometime. */
-extern void free_undo_list PARAMS((void));
-extern int maybe_save_line PARAMS((void));
-extern int maybe_unsave_line PARAMS((void));
-extern int maybe_replace_line PARAMS((void));
-
-extern int ding PARAMS((void));
-extern int alphabetic PARAMS((int));
-extern int crlf PARAMS((void));
-
-extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));
-extern char *username_completion_function PARAMS((const char *, int));
-extern char *filename_completion_function PARAMS((const char *, int));
+extern void free_undo_list (void);
+extern int maybe_save_line (void);
+extern int maybe_unsave_line (void);
+extern int maybe_replace_line (void);
+
+extern int ding (void);
+extern int alphabetic (int);
+extern int crlf (void);
+
+extern char **completion_matches (char *, rl_compentry_func_t *);
+extern char *username_completion_function (const char *, int);
+extern char *filename_completion_function (const char *, int);
 #endif
 
 /* **************************************************************** */
@@ -603,6 +612,8 @@ extern rl_hook_func_t *rl_event_hook;
 /* The address of a function to call if a read is interrupted by a signal. */
 extern rl_hook_func_t *rl_signal_event_hook;
 
+extern rl_hook_func_t *rl_timeout_event_hook;
+
 /* The address of a function to call if Readline needs to know whether or not
    there is data available from the current input source. */
 extern rl_hook_func_t *rl_input_available_hook;
@@ -693,7 +704,7 @@ extern const char *rl_basic_word_break_characters;
 /* The list of characters that signal a break between words for
    rl_complete_internal.  The default list is the contents of
    rl_basic_word_break_characters.  */
-extern /*const*/ char *rl_completer_word_break_characters;
+extern const char *rl_completer_word_break_characters;
 
 /* Hook function to allow an application to set the completion word
    break characters before readline breaks up the line.  Allows
@@ -910,9 +921,9 @@ extern int rl_persistent_signal_handlers;
 #define RL_STATE_REDISPLAYING	0x1000000	/* updating terminal display */
 
 #define RL_STATE_DONE		0x2000000	/* done; accepted line */
+#define RL_STATE_TIMEOUT	0x4000000	/* done; timed out */
 #define RL_STATE_EOF		0x8000000	/* done; got eof on read */
 
-
 #define RL_SETSTATE(x)		(rl_readline_state |= (x))
 #define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
 #define RL_ISSTATE(x)		(rl_readline_state & (x))
@@ -955,7 +966,7 @@ struct readline_state {
   rl_compentry_func_t *menuentryfunc;
   rl_compignore_func_t *ignorefunc;
   rl_completion_func_t *attemptfunc;
-  char *wordbreakchars;
+  const char *wordbreakchars;
 
   /* options state */
 
@@ -965,8 +976,8 @@ struct readline_state {
   char reserved[64];
 };
 
-extern int rl_save_state PARAMS((struct readline_state *));
-extern int rl_restore_state PARAMS((struct readline_state *));
+extern int rl_save_state (struct readline_state *);
+extern int rl_restore_state (struct readline_state *);
 
 #ifdef __cplusplus
 }
diff --git a/readline/readline/rldefs.h b/readline/readline/rldefs.h
index dab1beba1d72fbc6288f361b8c59fe2e3c78582e..98577a64b98d6c5997775874d7e1d75835862439 100644
--- a/readline/readline/rldefs.h
+++ b/readline/readline/rldefs.h
@@ -2,7 +2,7 @@
    for readline.  This should be included after any files that define
    system-specific constants like _POSIX_VERSION or USG. */
 
-/* Copyright (C) 1987-2011 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -79,14 +79,14 @@ extern char *strchr (), *strrchr ();
 #define _rl_stricmp strcasecmp
 #define _rl_strnicmp strncasecmp
 #else
-extern int _rl_stricmp PARAMS((const char *, const char *));
-extern int _rl_strnicmp PARAMS((const char *, const char *, int));
+extern int _rl_stricmp (const char *, const char *);
+extern int _rl_strnicmp (const char *, const char *, int);
 #endif
 
 #if defined (HAVE_STRPBRK) && !defined (HAVE_MULTIBYTE)
 #  define _rl_strpbrk(a,b)	strpbrk((a),(b))
 #else
-extern char *_rl_strpbrk PARAMS((const char *, const char *));
+extern char *_rl_strpbrk (const char *, const char *);
 #endif
 
 #if !defined (emacs_mode)
diff --git a/readline/readline/rlmbutil.h b/readline/readline/rlmbutil.h
index 4d3e90706a2534e3d8cb524b99ff78ebe9cf96aa..d9060572e5821f6811d1482b741b8490357c85cb 100644
--- a/readline/readline/rlmbutil.h
+++ b/readline/readline/rlmbutil.h
@@ -1,6 +1,6 @@
 /* rlmbutil.h -- utility functions for multibyte characters. */
 
-/* Copyright (C) 2001-2015 Free Software Foundation, Inc.
+/* Copyright (C) 2001-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -81,6 +81,19 @@
 /* end of multibyte capability checks for I18N  */
 /************************************************/
 
+/*
+ * wchar_t doesn't work for 32-bit values on Windows using MSVC
+ */
+#ifdef WCHAR_T_BROKEN
+#  define WCHAR_T char32_t
+#  define MBRTOWC mbrtoc32
+#  define WCRTOMB c32rtomb
+#else	/* normal systems */
+#  define WCHAR_T wchar_t
+#  define MBRTOWC mbrtowc
+#  define WCRTOMB wcrtomb
+#endif
+
 /*
  * Flags for _rl_find_prev_mbchar and _rl_find_next_mbchar:
  *
@@ -91,22 +104,22 @@
 #define MB_FIND_ANY	0x00
 #define MB_FIND_NONZERO	0x01
 
-extern int _rl_find_prev_mbchar PARAMS((char *, int, int));
-extern int _rl_find_next_mbchar PARAMS((char *, int, int, int));
+extern int _rl_find_prev_mbchar (char *, int, int);
+extern int _rl_find_next_mbchar (char *, int, int, int);
 
 #ifdef HANDLE_MULTIBYTE
 
-extern int _rl_compare_chars PARAMS((char *, int, mbstate_t *, char *, int, mbstate_t *));
-extern int _rl_get_char_len PARAMS((char *, mbstate_t *));
-extern int _rl_adjust_point PARAMS((char *, int, mbstate_t *));
+extern int _rl_compare_chars (char *, int, mbstate_t *, char *, int, mbstate_t *);
+extern int _rl_get_char_len (char *, mbstate_t *);
+extern int _rl_adjust_point (char *, int, mbstate_t *);
 
-extern int _rl_read_mbchar PARAMS((char *, int));
-extern int _rl_read_mbstring PARAMS((int, char *, int));
+extern int _rl_read_mbchar (char *, int);
+extern int _rl_read_mbstring (int, char *, int);
 
-extern int _rl_is_mbchar_matched PARAMS((char *, int, int, char *, int));
+extern int _rl_is_mbchar_matched (char *, int, int, char *, int);
 
-extern wchar_t _rl_char_value PARAMS((char *, int));
-extern int _rl_walphabetic PARAMS((wchar_t));
+extern WCHAR_T _rl_char_value (char *, int);
+extern int _rl_walphabetic (WCHAR_T);
 
 #define _rl_to_wupper(wc)	(iswlower (wc) ? towupper (wc) : (wc))
 #define _rl_to_wlower(wc)	(iswupper (wc) ? towlower (wc) : (wc))
@@ -126,8 +139,7 @@ extern int _rl_walphabetic PARAMS((wchar_t));
 /* Try and shortcut the printable ascii characters to cut down the number of
    calls to a libc wcwidth() */
 static inline int
-_rl_wcwidth (wc)
-     wchar_t wc;
+_rl_wcwidth (WCHAR_T wc)
 {
   switch (wc)
     {
diff --git a/readline/readline/rlprivate.h b/readline/readline/rlprivate.h
index 02838ae21ae704c2c6e0ba0db07fbd55357c419d..d87d07a72ee19c06b24338ac2f7c4ab80eb83870 100644
--- a/readline/readline/rlprivate.h
+++ b/readline/readline/rlprivate.h
@@ -1,10 +1,10 @@
 /* rlprivate.h -- functions and variables global to the readline library,
 		  but not intended for use by applications. */
 
-/* Copyright (C) 1999-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1999-2022 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
-   for reading lines of text with interactive input and history editing.      
+   for reading lines of text with interactive input and history editing.
 
    Readline is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@ typedef struct  __rl_search_context
   int search_string_size;
 
   char **lines;
-  char *allocated_line;    
+  char *allocated_line;
   int hlen;
   int hindex;
 
@@ -169,16 +169,16 @@ typedef struct __rl_vimotion_context
 
 /* fill in more as needed */
 /* `Generic' callback data and functions */
-typedef struct __rl_callback_generic_arg 
+typedef struct __rl_callback_generic_arg
 {
   int count;
   int i1, i2;
   /* add here as needed */
 } _rl_callback_generic_arg;
 
-typedef int _rl_callback_func_t PARAMS((_rl_callback_generic_arg *));
+typedef int _rl_callback_func_t (_rl_callback_generic_arg *);
 
-typedef void _rl_sigcleanup_func_t PARAMS((int, void *));
+typedef void _rl_sigcleanup_func_t (int, void *);
 
 /*************************************************************************
  *									 *
@@ -221,16 +221,16 @@ extern int rl_blink_matching_paren;
  *************************************************************************/
 
 /* kill.c */
-extern int rl_set_retained_kills PARAMS((int));
+extern int rl_set_retained_kills (int);
 
 /* terminal.c */
-extern void _rl_set_screen_size PARAMS((int, int));
+extern void _rl_set_screen_size (int, int);
 
 /* undo.c */
-extern int _rl_fix_last_undo_of_type PARAMS((int, int, int));
+extern int _rl_fix_last_undo_of_type (int, int, int);
 
 /* util.c */
-extern char *_rl_savestring PARAMS((const char *));
+extern char *_rl_savestring (const char *);
 
 /*************************************************************************
  *									 *
@@ -250,66 +250,73 @@ extern char *_rl_savestring PARAMS((const char *));
 #if defined(READLINE_CALLBACKS)
 
 /* readline.c */
-extern void readline_internal_setup PARAMS((void));
-extern char *readline_internal_teardown PARAMS((int));
-extern int readline_internal_char PARAMS((void));
+extern void readline_internal_setup (void);
+extern char *readline_internal_teardown (int);
+extern int readline_internal_char (void);
 
-extern _rl_keyseq_cxt *_rl_keyseq_cxt_alloc PARAMS((void));
-extern void _rl_keyseq_cxt_dispose PARAMS((_rl_keyseq_cxt *));
-extern void _rl_keyseq_chain_dispose PARAMS((void));
+extern _rl_keyseq_cxt *_rl_keyseq_cxt_alloc (void);
+extern void _rl_keyseq_cxt_dispose (_rl_keyseq_cxt *);
+extern void _rl_keyseq_chain_dispose (void);
+
+extern int _rl_dispatch_callback (_rl_keyseq_cxt *);
 
-extern int _rl_dispatch_callback PARAMS((_rl_keyseq_cxt *));
-     
 /* callback.c */
-extern _rl_callback_generic_arg *_rl_callback_data_alloc PARAMS((int));
-extern void _rl_callback_data_dispose PARAMS((_rl_callback_generic_arg *));
+extern _rl_callback_generic_arg *_rl_callback_data_alloc (int);
+extern void _rl_callback_data_dispose (_rl_callback_generic_arg *);
 
 #endif /* READLINE_CALLBACKS */
 
 /* bind.c */
-extern char *_rl_untranslate_macro_value PARAMS((char *, int));
+extern char *_rl_untranslate_macro_value (char *, int);
 
 /* complete.c */
-extern void _rl_reset_completion_state PARAMS((void));
-extern char _rl_find_completion_word PARAMS((int *, int *));
-extern void _rl_free_match_list PARAMS((char **));
+extern void _rl_reset_completion_state (void);
+extern char _rl_find_completion_word (int *, int *);
+extern void _rl_free_match_list (char **);
 
 /* display.c */
-extern char *_rl_strip_prompt PARAMS((char *));
-extern void _rl_reset_prompt PARAMS((void));
-extern void _rl_move_vert PARAMS((int));
-extern void _rl_save_prompt PARAMS((void));
-extern void _rl_restore_prompt PARAMS((void));
-extern char *_rl_make_prompt_for_search PARAMS((int));
-extern void _rl_erase_at_end_of_line PARAMS((int));
-extern void _rl_clear_to_eol PARAMS((int));
-extern void _rl_clear_screen PARAMS((int));
-extern void _rl_update_final PARAMS((void));
-extern void _rl_optimize_redisplay PARAMS((void));
-extern void _rl_redisplay_after_sigwinch PARAMS((void));
-extern void _rl_clean_up_for_exit PARAMS((void));
-extern void _rl_erase_entire_line PARAMS((void));
-extern int _rl_current_display_line PARAMS((void));
-extern void _rl_refresh_line PARAMS((void));
+extern char *_rl_strip_prompt (char *);
+extern void _rl_reset_prompt (void);
+extern void _rl_move_vert (int);
+extern void _rl_save_prompt (void);
+extern void _rl_restore_prompt (void);
+extern char *_rl_make_prompt_for_search (int);
+extern void _rl_erase_at_end_of_line (int);
+extern void _rl_clear_to_eol (int);
+extern void _rl_clear_screen (int);
+extern void _rl_update_final (void);
+extern void _rl_optimize_redisplay (void);
+extern void _rl_redisplay_after_sigwinch (void);
+extern void _rl_clean_up_for_exit (void);
+extern void _rl_erase_entire_line (void);
+extern int _rl_current_display_line (void);
+extern void _rl_refresh_line (void);
 
 /* input.c */
-extern int _rl_any_typein PARAMS((void));
-extern int _rl_input_available PARAMS((void));
-extern int _rl_nchars_available PARAMS((void));
-extern int _rl_input_queued PARAMS((int));
-extern void _rl_insert_typein PARAMS((int));
-extern int _rl_unget_char PARAMS((int));
-extern int _rl_pushed_input_available PARAMS((void));
+extern int _rl_any_typein (void);
+extern int _rl_input_available (void);
+extern int _rl_nchars_available (void);
+extern int _rl_input_queued (int);
+extern void _rl_insert_typein (int);
+extern int _rl_unget_char (int);
+extern int _rl_pushed_input_available (void);
+
+extern int _rl_timeout_init (void);
+extern int _rl_timeout_handle_sigalrm (void);
+#if defined (_POSIXSELECT_H_)
+/* use as a sentinel for fd_set, struct timeval,  and sigset_t definitions */
+extern int _rl_timeout_select (int, fd_set *, fd_set *, fd_set *, const struct timeval *, const sigset_t *);
+#endif
 
 /* isearch.c */
-extern _rl_search_cxt *_rl_scxt_alloc PARAMS((int, int));
-extern void _rl_scxt_dispose PARAMS((_rl_search_cxt *, int));
+extern _rl_search_cxt *_rl_scxt_alloc (int, int);
+extern void _rl_scxt_dispose (_rl_search_cxt *, int);
 
-extern int _rl_isearch_dispatch PARAMS((_rl_search_cxt *, int));
-extern int _rl_isearch_callback PARAMS((_rl_search_cxt *));
-extern int _rl_isearch_cleanup PARAMS((_rl_search_cxt *, int));
+extern int _rl_isearch_dispatch (_rl_search_cxt *, int);
+extern int _rl_isearch_callback (_rl_search_cxt *);
+extern int _rl_isearch_cleanup (_rl_search_cxt *, int);
 
-extern int _rl_search_getchar PARAMS((_rl_search_cxt *));
+extern int _rl_search_getchar (_rl_search_cxt *);
 
 /* kill.c */
 #ifndef BRACKETED_PASTE_DEFAULT
@@ -325,110 +332,117 @@ extern int _rl_search_getchar PARAMS((_rl_search_cxt *));
 #define BRACK_PASTE_INIT	"\033[?2004h"
 #define BRACK_PASTE_FINI	"\033[?2004l\r"
 
-extern int _rl_read_bracketed_paste_prefix PARAMS((int));
-extern char *_rl_bracketed_text PARAMS((size_t *));
-extern int _rl_bracketed_read_key PARAMS((void));
-extern int _rl_bracketed_read_mbstring PARAMS((char *, int));
+extern int _rl_read_bracketed_paste_prefix (int);
+extern char *_rl_bracketed_text (size_t *);
+extern int _rl_bracketed_read_key (void);
+extern int _rl_bracketed_read_mbstring (char *, int);
 
 /* macro.c */
-extern void _rl_with_macro_input PARAMS((char *));
-extern int _rl_peek_macro_key PARAMS((void));
-extern int _rl_next_macro_key PARAMS((void));
-extern int _rl_prev_macro_key PARAMS((void));
-extern void _rl_push_executing_macro PARAMS((void));
-extern void _rl_pop_executing_macro PARAMS((void));
-extern void _rl_add_macro_char PARAMS((int));
-extern void _rl_kill_kbd_macro PARAMS((void));
+extern void _rl_with_macro_input (char *);
+extern int _rl_peek_macro_key (void);
+extern int _rl_next_macro_key (void);
+extern int _rl_prev_macro_key (void);
+extern void _rl_push_executing_macro (void);
+extern void _rl_pop_executing_macro (void);
+extern void _rl_add_macro_char (int);
+extern void _rl_kill_kbd_macro (void);
 
 /* misc.c */
-extern int _rl_arg_overflow PARAMS((void));
-extern void _rl_arg_init PARAMS((void));
-extern int _rl_arg_getchar PARAMS((void));
-extern int _rl_arg_callback PARAMS((_rl_arg_cxt));
-extern void _rl_reset_argument PARAMS((void));
+extern int _rl_arg_overflow (void);
+extern void _rl_arg_init (void);
+extern int _rl_arg_getchar (void);
+extern int _rl_arg_callback (_rl_arg_cxt);
+extern void _rl_reset_argument (void);
 
-extern void _rl_start_using_history PARAMS((void));
-extern int _rl_free_saved_history_line PARAMS((void));
-extern void _rl_set_insert_mode PARAMS((int, int));
+extern void _rl_start_using_history (void);
+extern int _rl_free_saved_history_line (void);
+extern void _rl_set_insert_mode (int, int);
 
-extern void _rl_revert_previous_lines PARAMS((void));
-extern void _rl_revert_all_lines PARAMS((void));
+extern void _rl_revert_previous_lines (void);
+extern void _rl_revert_all_lines (void);
 
 /* nls.c */
-extern char *_rl_init_locale PARAMS((void));
-extern int _rl_init_eightbit PARAMS((void));
+extern char *_rl_init_locale (void);
+extern int _rl_init_eightbit (void);
+extern void _rl_reset_locale (void);
 
 /* parens.c */
-extern void _rl_enable_paren_matching PARAMS((int));
+extern void _rl_enable_paren_matching (int);
 
 /* readline.c */
-extern void _rl_init_line_state PARAMS((void));
-extern void _rl_set_the_line PARAMS((void));
-extern int _rl_dispatch PARAMS((int, Keymap));
-extern int _rl_dispatch_subseq PARAMS((int, Keymap, int));
-extern void _rl_internal_char_cleanup PARAMS((void));
+extern void _rl_init_line_state (void);
+extern void _rl_set_the_line (void);
+extern int _rl_dispatch (int, Keymap);
+extern int _rl_dispatch_subseq (int, Keymap, int);
+extern void _rl_internal_char_cleanup (void);
+
+extern void _rl_init_executing_keyseq (void);
+extern void _rl_term_executing_keyseq (void);
+extern void _rl_end_executing_keyseq (void);
+extern void _rl_add_executing_keyseq (int);
+extern void _rl_del_executing_keyseq (void);
 
-extern void _rl_init_executing_keyseq PARAMS((void));
-extern void _rl_term_executing_keyseq PARAMS((void));
-extern void _rl_end_executing_keyseq PARAMS((void));
-extern void _rl_add_executing_keyseq PARAMS((int)); 
+extern rl_command_func_t *_rl_executing_func;
 
 /* rltty.c */
-extern int _rl_disable_tty_signals PARAMS((void));
-extern int _rl_restore_tty_signals PARAMS((void));
+extern int _rl_disable_tty_signals (void);
+extern int _rl_restore_tty_signals (void);
 
 /* search.c */
-extern int _rl_nsearch_callback PARAMS((_rl_search_cxt *));
-extern int _rl_nsearch_cleanup PARAMS((_rl_search_cxt *, int));
+extern int _rl_nsearch_callback (_rl_search_cxt *);
+extern int _rl_nsearch_cleanup (_rl_search_cxt *, int);
 
 /* signals.c */
-extern void _rl_signal_handler PARAMS((int));
+extern void _rl_signal_handler (int);
 
-extern void _rl_block_sigint PARAMS((void));
-extern void _rl_release_sigint PARAMS((void));
-extern void _rl_block_sigwinch PARAMS((void));
-extern void _rl_release_sigwinch PARAMS((void));
+extern void _rl_block_sigint (void);
+extern void _rl_release_sigint (void);
+extern void _rl_block_sigwinch (void);
+extern void _rl_release_sigwinch (void);
 
 /* terminal.c */
-extern void _rl_get_screen_size PARAMS((int, int));
-extern void _rl_sigwinch_resize_terminal PARAMS((void));
-extern int _rl_init_terminal_io PARAMS((const char *));
+extern void _rl_get_screen_size (int, int);
+extern void _rl_sigwinch_resize_terminal (void);
+extern int _rl_init_terminal_io (const char *);
 #ifdef _MINIX
-extern void _rl_output_character_function PARAMS((int));
+extern void _rl_output_character_function (int);
 #else
-extern int _rl_output_character_function PARAMS((int));
+extern int _rl_output_character_function (int);
 #endif
-extern void _rl_cr PARAMS((void));
-extern void _rl_output_some_chars PARAMS((const char *, int));
-extern int _rl_backspace PARAMS((int));
-extern void _rl_enable_meta_key PARAMS((void));
-extern void _rl_disable_meta_key PARAMS((void));
-extern void _rl_control_keypad PARAMS((int));
-extern void _rl_set_cursor PARAMS((int, int));
-extern void _rl_standout_on PARAMS((void));
-extern void _rl_standout_off PARAMS((void));
+extern void _rl_cr (void);
+extern void _rl_output_some_chars (const char *, int);
+extern int _rl_backspace (int);
+extern void _rl_enable_meta_key (void);
+extern void _rl_disable_meta_key (void);
+extern void _rl_control_keypad (int);
+extern void _rl_set_cursor (int, int);
+extern void _rl_standout_on (void);
+extern void _rl_standout_off (void);
+extern int _rl_reset_region_color (int, const char *);
+extern void _rl_region_color_on (void);
+extern void _rl_region_color_off (void);
 
 /* text.c */
-extern void _rl_fix_point PARAMS((int));
-extern void _rl_fix_mark PARAMS((void));
-extern int _rl_replace_text PARAMS((const char *, int, int));
-extern int _rl_forward_char_internal PARAMS((int));
-extern int _rl_backward_char_internal PARAMS((int));
-extern int _rl_insert_char PARAMS((int, int));
-extern int _rl_overwrite_char PARAMS((int, int));
-extern int _rl_overwrite_rubout PARAMS((int, int));
-extern int _rl_rubout_char PARAMS((int, int));
+extern void _rl_fix_point (int);
+extern void _rl_fix_mark (void);
+extern int _rl_replace_text (const char *, int, int);
+extern int _rl_forward_char_internal (int);
+extern int _rl_backward_char_internal (int);
+extern int _rl_insert_char (int, int);
+extern int _rl_overwrite_char (int, int);
+extern int _rl_overwrite_rubout (int, int);
+extern int _rl_rubout_char (int, int);
 #if defined (HANDLE_MULTIBYTE)
-extern int _rl_char_search_internal PARAMS((int, int, char *, int));
+extern int _rl_char_search_internal (int, int, char *, int);
 #else
-extern int _rl_char_search_internal PARAMS((int, int, int));
+extern int _rl_char_search_internal (int, int, int);
 #endif
-extern int _rl_set_mark_at_pos PARAMS((int));
+extern int _rl_set_mark_at_pos (int);
 
 /* undo.c */
-extern UNDO_LIST *_rl_copy_undo_entry PARAMS((UNDO_LIST *));
-extern UNDO_LIST *_rl_copy_undo_list PARAMS((UNDO_LIST *));
-extern void _rl_free_undo_list PARAMS((UNDO_LIST *));
+extern UNDO_LIST *_rl_copy_undo_entry (UNDO_LIST *);
+extern UNDO_LIST *_rl_copy_undo_list (UNDO_LIST *);
+extern void _rl_free_undo_list (UNDO_LIST *);
 
 /* util.c */
 #if defined (USE_VARARGS) && defined (PREFER_STDARG)
@@ -440,31 +454,37 @@ extern void _rl_ttymsg ();
 extern void _rl_errmsg ();
 extern void _rl_trace ();
 #endif
-extern void _rl_audit_tty PARAMS((char *));
-
-extern int _rl_tropen PARAMS((void));
-
-extern int _rl_abort_internal PARAMS((void));
-extern int _rl_null_function PARAMS((int, int));
-extern char *_rl_strindex PARAMS((const char *, const char *));
-extern int _rl_qsort_string_compare PARAMS((char **, char **));
-extern int (_rl_uppercase_p) PARAMS((int));
-extern int (_rl_lowercase_p) PARAMS((int));
-extern int (_rl_pure_alphabetic) PARAMS((int));
-extern int (_rl_digit_p) PARAMS((int));
-extern int (_rl_to_lower) PARAMS((int));
-extern int (_rl_to_upper) PARAMS((int));
-extern int (_rl_digit_value) PARAMS((int));
+extern void _rl_audit_tty (char *);
+
+extern int _rl_tropen (void);
+
+extern int _rl_abort_internal (void);
+extern int _rl_null_function (int, int);
+extern char *_rl_strindex (const char *, const char *);
+extern int _rl_qsort_string_compare (char **, char **);
+extern int (_rl_uppercase_p) (int);
+extern int (_rl_lowercase_p) (int);
+extern int (_rl_pure_alphabetic) (int);
+extern int (_rl_digit_p) (int);
+extern int (_rl_to_lower) (int);
+extern int (_rl_to_upper) (int);
+extern int (_rl_digit_value) (int);
 
 /* vi_mode.c */
-extern void _rl_vi_initialize_line PARAMS((void));
-extern void _rl_vi_reset_last PARAMS((void));
-extern void _rl_vi_set_last PARAMS((int, int, int));
-extern int _rl_vi_textmod_command PARAMS((int));
-extern int _rl_vi_motion_command PARAMS((int));
-extern void _rl_vi_done_inserting PARAMS((void));
-extern int _rl_vi_domove_callback PARAMS((_rl_vimotion_cxt *));
-extern int _rl_vi_domove_motion_cleanup PARAMS((int, _rl_vimotion_cxt *));
+extern void _rl_vi_initialize_line (void);
+extern void _rl_vi_reset_last (void);
+extern void _rl_vi_set_last (int, int, int);
+extern int _rl_vi_textmod_command (int);
+extern int _rl_vi_motion_command (int);
+extern void _rl_vi_done_inserting (void);
+extern int _rl_vi_domove_callback (_rl_vimotion_cxt *);
+extern int _rl_vi_domove_motion_cleanup (int, _rl_vimotion_cxt *);
+
+/* Use HS_HISTORY_VERSION as the sentinel to see if we've included history.h
+   and so can use HIST_ENTRY */
+#if defined (HS_HISTORY_VERSION)
+extern void _rl_free_history_entry (HIST_ENTRY *);
+#endif
 
 /*************************************************************************
  * Undocumented private variables					 *
@@ -537,6 +557,8 @@ extern int _rl_echo_control_chars;
 extern int _rl_show_mode_in_prompt;
 extern int _rl_enable_bracketed_paste;
 extern int _rl_enable_active_region;
+extern char *_rl_active_region_start_color;
+extern char *_rl_active_region_end_color;
 extern char *_rl_comment_begin;
 extern unsigned char _rl_parsing_conditionalized_out;
 extern Keymap _rl_keymap;
@@ -554,6 +576,7 @@ extern rl_hook_func_t *_rl_internal_startup_hook;
 
 /* search.c */
 extern _rl_search_cxt *_rl_nscxt;
+extern int _rl_history_search_pos;
 
 /* signals.c */
 extern int volatile _rl_caught_signal;
@@ -601,4 +624,10 @@ extern int _rl_vi_last_command;
 extern int _rl_vi_redoing;
 extern _rl_vimotion_cxt *_rl_vimvcxt;
 
+/* Use HS_HISTORY_VERSION as the sentinel to see if we've included history.h
+   and so can use HIST_ENTRY */
+#if defined (HS_HISTORY_VERSION)
+extern HIST_ENTRY *_rl_saved_line_for_history;
+#endif
+
 #endif /* _RL_PRIVATE_H_ */
diff --git a/readline/readline/rlshell.h b/readline/readline/rlshell.h
index 3e17d8bc7f1ff78494979eb77fd1772a881bfc1e..6055b1442ff9a1712c8501784c1df30ad067cf0f 100644
--- a/readline/readline/rlshell.h
+++ b/readline/readline/rlshell.h
@@ -1,6 +1,6 @@
 /* rlshell.h -- utility functions normally provided by bash. */
 
-/* Copyright (C) 1999-2009 Free Software Foundation, Inc.
+/* Copyright (C) 1999-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -24,10 +24,10 @@
 
 #include "rlstdc.h"
 
-extern char *sh_single_quote PARAMS((char *));
-extern void sh_set_lines_and_columns PARAMS((int, int));
-extern char *sh_get_env_value PARAMS((const char *));
-extern char *sh_get_home_dir PARAMS((void));
-extern int sh_unset_nodelay_mode PARAMS((int));
+extern char *sh_single_quote (char *);
+extern void sh_set_lines_and_columns (int, int);
+extern char *sh_get_env_value (const char *);
+extern char *sh_get_home_dir (void);
+extern int sh_unset_nodelay_mode (int);
 
 #endif /* _RL_SHELL_H_ */
diff --git a/readline/readline/rltty.c b/readline/readline/rltty.c
index 11997b7c9d816ce48fa5feff7ab87301e18785c8..a4863acb31efa7c1f9a2d509209e647894bb6908 100644
--- a/readline/readline/rltty.c
+++ b/readline/readline/rltty.c
@@ -52,7 +52,7 @@ extern int errno;
 rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
 rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;
 
-static void set_winsize PARAMS((int));
+static void set_winsize (int);
 
 /* **************************************************************** */
 /*								    */
@@ -80,8 +80,7 @@ static int ksrflow;
 /* Dummy call to force a backgrounded readline to stop before it tries
    to get the tty settings. */
 static void
-set_winsize (tty)
-     int tty;
+set_winsize (int tty)
 {
 #if defined (TIOCGWINSZ)
   struct winsize w;
@@ -119,15 +118,15 @@ struct bsdtty {
 
 static TIOTYPE otio;
 
-static void save_tty_chars PARAMS((TIOTYPE *));
-static int _get_tty_settings PARAMS((int, TIOTYPE *));
-static int get_tty_settings PARAMS((int, TIOTYPE *));
-static int _set_tty_settings PARAMS((int, TIOTYPE *));
-static int set_tty_settings PARAMS((int, TIOTYPE *));
+static void save_tty_chars (TIOTYPE *);
+static int _get_tty_settings (int, TIOTYPE *);
+static int get_tty_settings (int, TIOTYPE *);
+static int _set_tty_settings (int, TIOTYPE *);
+static int set_tty_settings (int, TIOTYPE *);
 
-static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));
+static void prepare_terminal_settings (int, TIOTYPE, TIOTYPE *);
 
-static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t *));
+static void set_special_char (Keymap, TIOTYPE *, int, rl_command_func_t *);
 
 static void
 save_tty_chars (TIOTYPE *tiop)
@@ -332,16 +331,16 @@ prepare_terminal_settings (int meta_flag, TIOTYPE oldtio, TIOTYPE *tiop)
 
 static TIOTYPE otio;
 
-static void save_tty_chars PARAMS((TIOTYPE *));
-static int _get_tty_settings PARAMS((int, TIOTYPE *));
-static int get_tty_settings PARAMS((int, TIOTYPE *));
-static int _set_tty_settings PARAMS((int, TIOTYPE *));
-static int set_tty_settings PARAMS((int, TIOTYPE *));
+static void save_tty_chars (TIOTYPE *);
+static int _get_tty_settings (int, TIOTYPE *);
+static int get_tty_settings (int, TIOTYPE *);
+static int _set_tty_settings (int, TIOTYPE *);
+static int set_tty_settings (int, TIOTYPE *);
 
-static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));
+static void prepare_terminal_settings (int, TIOTYPE, TIOTYPE *);
 
-static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t *));
-static void _rl_bind_tty_special_chars PARAMS((Keymap, TIOTYPE));
+static void set_special_char (Keymap, TIOTYPE *, int, rl_command_func_t *);
+static void _rl_bind_tty_special_chars (Keymap, TIOTYPE);
 
 #if defined (FLUSHO)
 #  define OUTPUT_BEING_FLUSHED(tp)  (tp->c_lflag & FLUSHO)
@@ -692,7 +691,11 @@ rl_deprep_terminal (void)
   if (terminal_prepped & TPX_BRACKPASTE)
     {
       fprintf (rl_outstream, BRACK_PASTE_FINI);
-      if (rl_eof_found)
+      /* Since the last character in BRACK_PASTE_FINI is \r */
+      _rl_last_c_pos = 0;
+      if (rl_eof_found && (RL_ISSTATE (RL_STATE_TIMEOUT) == 0))
+ 	fprintf (rl_outstream, "\n");
+      else if (_rl_echoing_p == 0)
  	fprintf (rl_outstream, "\n");
     }
 
diff --git a/readline/readline/rltypedefs.h b/readline/readline/rltypedefs.h
index f9f5cd3a5b64d8b1a64c6eeaf6c17ddba1f7e6ff..163654921e61e1f8c16b864e3fcab4ea177c153e 100644
--- a/readline/readline/rltypedefs.h
+++ b/readline/readline/rltypedefs.h
@@ -1,6 +1,6 @@
 /* rltypedefs.h -- Type declarations for readline functions. */
 
-/* Copyright (C) 2000-2011 Free Software Foundation, Inc.
+/* Copyright (C) 2000-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -32,10 +32,10 @@ extern "C" {
 #  define _FUNCTION_DEF
 
 #if defined(__GNUC__) || defined(__clang__)
-typedef int Function () __attribute__ ((deprecated));
-typedef void VFunction () __attribute__ ((deprecated));
-typedef char *CPFunction () __attribute__ ((deprecated));
-typedef char **CPPFunction () __attribute__ ((deprecated));
+typedef int Function () __attribute__((deprecated));
+typedef void VFunction () __attribute__((deprecated));
+typedef char *CPFunction () __attribute__((deprecated));
+typedef char **CPPFunction () __attribute__((deprecated));
 #else
 typedef int Function ();
 typedef void VFunction ();
@@ -51,45 +51,45 @@ typedef char **CPPFunction ();
 #  define _RL_FUNCTION_TYPEDEF
 
 /* Bindable functions */
-typedef int rl_command_func_t PARAMS((int, int));
+typedef int rl_command_func_t (int, int);
 
 /* Typedefs for the completion system */
-typedef char *rl_compentry_func_t PARAMS((const char *, int));
-typedef char **rl_completion_func_t PARAMS((const char *, int, int));
+typedef char *rl_compentry_func_t (const char *, int);
+typedef char **rl_completion_func_t (const char *, int, int);
 
-typedef char *rl_quote_func_t PARAMS((char *, int, char *));
-typedef char *rl_dequote_func_t PARAMS((char *, int));
+typedef char *rl_quote_func_t (char *, int, char *);
+typedef char *rl_dequote_func_t (char *, int);
 
-typedef int rl_compignore_func_t PARAMS((char **));
+typedef int rl_compignore_func_t (char **);
 
-typedef void rl_compdisp_func_t PARAMS((char **, int, int));
+typedef void rl_compdisp_func_t (char **, int, int);
 
 /* Type for input and pre-read hook functions like rl_event_hook */
-typedef int rl_hook_func_t PARAMS((void));
+typedef int rl_hook_func_t (void);
 
 /* Input function type */
-typedef int rl_getc_func_t PARAMS((FILE *));
+typedef int rl_getc_func_t (FILE *);
 
 /* Generic function that takes a character buffer (which could be the readline
    line buffer) and an index into it (which could be rl_point) and returns
    an int. */
-typedef int rl_linebuf_func_t PARAMS((char *, int));
+typedef int rl_linebuf_func_t (char *, int);
 
 /* `Generic' function pointer typedefs */
-typedef int rl_intfunc_t PARAMS((int));
+typedef int rl_intfunc_t (int);
 #define rl_ivoidfunc_t rl_hook_func_t
-typedef int rl_icpfunc_t PARAMS((char *));
-typedef int rl_icppfunc_t PARAMS((char **));
-
-typedef void rl_voidfunc_t PARAMS((void));
-typedef void rl_vintfunc_t PARAMS((int));
-typedef void rl_vcpfunc_t PARAMS((char *));
-typedef void rl_vcppfunc_t PARAMS((char **));
-
-typedef char *rl_cpvfunc_t PARAMS((void));
-typedef char *rl_cpifunc_t PARAMS((int));
-typedef char *rl_cpcpfunc_t PARAMS((char  *));
-typedef char *rl_cpcppfunc_t PARAMS((char  **));
+typedef int rl_icpfunc_t (char *);
+typedef int rl_icppfunc_t (char **);
+
+typedef void rl_voidfunc_t (void);
+typedef void rl_vintfunc_t (int);
+typedef void rl_vcpfunc_t (char *);
+typedef void rl_vcppfunc_t (char **);
+
+typedef char *rl_cpvfunc_t (void);
+typedef char *rl_cpifunc_t (int);
+typedef char *rl_cpcpfunc_t (char  *);
+typedef char *rl_cpcppfunc_t (char  **);
 
 #endif /* _RL_FUNCTION_TYPEDEF */
 
diff --git a/readline/readline/search.c b/readline/readline/search.c
index 38a29361d7020897ebbc7cea7d7eeb4559223359..eea2301115ef6b9e757b50db93b98c20cab7215a 100644
--- a/readline/readline/search.c
+++ b/readline/readline/search.c
@@ -1,6 +1,6 @@
 /* search.c - code for non-incremental searching in emacs and vi modes. */
 
-/* Copyright (C) 1992-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1992-2022 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -55,33 +55,28 @@
 
 _rl_search_cxt *_rl_nscxt = 0;
 
-extern HIST_ENTRY *_rl_saved_line_for_history;
-
-/* Functions imported from the rest of the library. */
-extern void _rl_free_history_entry PARAMS((HIST_ENTRY *));
-
 static char *noninc_search_string = (char *) NULL;
 static int noninc_history_pos;
 
 static char *prev_line_found = (char *) NULL;
 
-static int rl_history_search_len;
-static int rl_history_search_pos;
-static int rl_history_search_flags;
+static int _rl_history_search_len;
+/*static*/ int _rl_history_search_pos;
+static int _rl_history_search_flags;
 
 static char *history_search_string;
 static int history_string_size;
 
-static void make_history_line_current PARAMS((HIST_ENTRY *));
-static int noninc_search_from_pos PARAMS((char *, int, int, int, int *));
-static int noninc_dosearch PARAMS((char *, int, int));
-static int noninc_search PARAMS((int, int));
-static int rl_history_search_internal PARAMS((int, int));
-static void rl_history_search_reinit PARAMS((int));
+static void make_history_line_current (HIST_ENTRY *);
+static int noninc_search_from_pos (char *, int, int, int, int *);
+static int noninc_dosearch (char *, int, int);
+static int noninc_search (int, int);
+static int rl_history_search_internal (int, int);
+static void rl_history_search_reinit (int);
 
-static _rl_search_cxt *_rl_nsearch_init PARAMS((int, int));
-static void _rl_nsearch_abort PARAMS((_rl_search_cxt *));
-static int _rl_nsearch_dispatch PARAMS((_rl_search_cxt *, int));
+static _rl_search_cxt *_rl_nsearch_init (int, int);
+static void _rl_nsearch_abort (_rl_search_cxt *);
+static int _rl_nsearch_dispatch (_rl_search_cxt *, int);
 
 /* Make the data from the history entry ENTRY be the contents of the
    current line.  This doesn't do anything with rl_point; the caller
@@ -89,6 +84,15 @@ static int _rl_nsearch_dispatch PARAMS((_rl_search_cxt *, int));
 static void
 make_history_line_current (HIST_ENTRY *entry)
 {
+  UNDO_LIST *xlist;
+
+  xlist = _rl_saved_line_for_history ? (UNDO_LIST *)_rl_saved_line_for_history->data : 0;
+  /* At this point, rl_undo_list points to a private search string list. */
+  if (rl_undo_list && rl_undo_list != (UNDO_LIST *)entry->data && rl_undo_list != xlist)
+    rl_free_undo_list ();
+
+  /* Now we create a new undo list with a single insert for this text.
+     WE DON'T CHANGE THE ORIGINAL HISTORY ENTRY UNDO LIST */
   _rl_replace_text (entry->line, 0, rl_end);
   _rl_fix_point (1);
 #if defined (VI_MODE)
@@ -100,6 +104,11 @@ make_history_line_current (HIST_ENTRY *entry)
     rl_free_undo_list ();
 #endif
 
+  /* This will need to free the saved undo list associated with the original
+     (pre-search) line buffer.
+     XXX - look at _rl_free_saved_history_line and consider calling it if
+     rl_undo_list != xlist (or calling rl_free_undo list directly on
+     _rl_saved_line_for_history->data) */
   if (_rl_saved_line_for_history)
     _rl_free_history_entry (_rl_saved_line_for_history);
   _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
@@ -264,11 +273,11 @@ static void
 _rl_nsearch_abort (_rl_search_cxt *cxt)
 {
   rl_maybe_unsave_line ();
-  rl_clear_message ();
   rl_point = cxt->save_point;
   rl_mark = cxt->save_mark;
-  _rl_fix_point (1);
   rl_restore_prompt ();
+  rl_clear_message ();
+  _rl_fix_point (1);
 
   RL_UNSETSTATE (RL_STATE_NSEARCH);
 }
@@ -521,8 +530,10 @@ rl_history_search_internal (int count, int dir)
 {
   HIST_ENTRY *temp;
   int ret, oldpos, newcol;
+  int had_saved_line;
   char *t;
 
+  had_saved_line = _rl_saved_line_for_history != 0;
   rl_maybe_save_line ();
   temp = (HIST_ENTRY *)NULL;
 
@@ -534,14 +545,14 @@ rl_history_search_internal (int count, int dir)
   while (count)
     {
       RL_CHECK_SIGNALS ();
-      ret = noninc_search_from_pos (history_search_string, rl_history_search_pos + dir, dir, 0, &newcol);
+      ret = noninc_search_from_pos (history_search_string, _rl_history_search_pos + dir, dir, 0, &newcol);
       if (ret == -1)
 	break;
 
       /* Get the history entry we found. */
-      rl_history_search_pos = ret;
+      _rl_history_search_pos = ret;
       oldpos = where_history ();
-      history_set_pos (rl_history_search_pos);
+      history_set_pos (_rl_history_search_pos);
       temp = current_history ();	/* will never be NULL after successful search */
       history_set_pos (oldpos);
 
@@ -555,20 +566,21 @@ rl_history_search_internal (int count, int dir)
   /* If we didn't find anything at all, return. */
   if (temp == 0)
     {
+      /* XXX - check had_saved_line here? */
       rl_maybe_unsave_line ();
       rl_ding ();
       /* If you don't want the saved history line (last match) to show up
          in the line buffer after the search fails, change the #if 0 to
          #if 1 */
 #if 0
-      if (rl_point > rl_history_search_len)
+      if (rl_point > _rl_history_search_len)
         {
-          rl_point = rl_end = rl_history_search_len;
+          rl_point = rl_end = _rl_history_search_len;
           rl_line_buffer[rl_end] = '\0';
           rl_mark = 0;
         }
 #else
-      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
+      rl_point = _rl_history_search_len;	/* rl_maybe_unsave_line changes it */
       rl_mark = rl_end;
 #endif
       return 1;
@@ -578,13 +590,13 @@ rl_history_search_internal (int count, int dir)
   make_history_line_current (temp);
 
   /* decide where to put rl_point -- need to change this for pattern search */
-  if (rl_history_search_flags & ANCHORED_SEARCH)
-    rl_point = rl_history_search_len;	/* easy case */
+  if (_rl_history_search_flags & ANCHORED_SEARCH)
+    rl_point = _rl_history_search_len;	/* easy case */
   else
     {
 #if 0
       t = strstr (rl_line_buffer, history_search_string);	/* XXX */
-      rl_point = t ? (int)(t - rl_line_buffer) + rl_history_search_len : rl_end;
+      rl_point = t ? (int)(t - rl_line_buffer) + _rl_history_search_len : rl_end;
 #else
       rl_point = (newcol >= 0) ? newcol : rl_end;
 #endif
@@ -599,17 +611,17 @@ rl_history_search_reinit (int flags)
 {
   int sind;
 
-  rl_history_search_pos = where_history ();
-  rl_history_search_len = rl_point;
-  rl_history_search_flags = flags;
+  _rl_history_search_pos = where_history ();
+  _rl_history_search_len = rl_point;
+  _rl_history_search_flags = flags;
 
   prev_line_found = (char *)NULL;
   if (rl_point)
     {
       /* Allocate enough space for anchored and non-anchored searches */
-      if (rl_history_search_len >= history_string_size - 2)
+      if (_rl_history_search_len >= history_string_size - 2)
 	{
-	  history_string_size = rl_history_search_len + 2;
+	  history_string_size = _rl_history_search_len + 2;
 	  history_search_string = (char *)xrealloc (history_search_string, history_string_size);
 	}
       sind = 0;
@@ -618,7 +630,7 @@ rl_history_search_reinit (int flags)
       strncpy (history_search_string + sind, rl_line_buffer, rl_point);
       history_search_string[rl_point + sind] = '\0';
     }
-  _rl_free_saved_history_line ();
+  _rl_free_saved_history_line ();	/* XXX rl_undo_list? */
 }
 
 /* Search forward in the history for the string of characters
@@ -634,7 +646,7 @@ rl_history_search_forward (int count, int ignore)
       rl_last_func != rl_history_search_backward)
     rl_history_search_reinit (ANCHORED_SEARCH);
 
-  if (rl_history_search_len == 0)
+  if (_rl_history_search_len == 0)
     return (rl_get_next_history (count, ignore));
   return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));
 }
@@ -652,7 +664,7 @@ rl_history_search_backward (int count, int ignore)
       rl_last_func != rl_history_search_backward)
     rl_history_search_reinit (ANCHORED_SEARCH);
 
-  if (rl_history_search_len == 0)
+  if (_rl_history_search_len == 0)
     return (rl_get_previous_history (count, ignore));
   return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));
 }
@@ -671,7 +683,7 @@ rl_history_substr_search_forward (int count, int ignore)
       rl_last_func != rl_history_substr_search_backward)
     rl_history_search_reinit (NON_ANCHORED_SEARCH);
 
-  if (rl_history_search_len == 0)
+  if (_rl_history_search_len == 0)
     return (rl_get_next_history (count, ignore));
   return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));
 }
@@ -689,7 +701,7 @@ rl_history_substr_search_backward (int count, int ignore)
       rl_last_func != rl_history_substr_search_backward)
     rl_history_search_reinit (NON_ANCHORED_SEARCH);
 
-  if (rl_history_search_len == 0)
+  if (_rl_history_search_len == 0)
     return (rl_get_previous_history (count, ignore));
   return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));
 }
diff --git a/readline/readline/shell.c b/readline/readline/shell.c
index 7fe2e97c983360641288ca4ecca254932c6bf053..36c91484c94f64dcdb154c829958a3907c363ebd 100644
--- a/readline/readline/shell.c
+++ b/readline/readline/shell.c
@@ -1,7 +1,7 @@
 /* shell.c -- readline utility functions that are normally provided by
 	      bash when readline is linked as part of the shell. */
 
-/* Copyright (C) 1997-2009,2017 Free Software Foundation, Inc.
+/* Copyright (C) 1997-2009,2017,2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -64,7 +64,7 @@
 #include "xmalloc.h"
 
 #if defined (HAVE_GETPWUID) && !defined (HAVE_GETPW_DECLS)
-extern struct passwd *getpwuid PARAMS((uid_t));
+extern struct passwd *getpwuid (uid_t);
 #endif /* HAVE_GETPWUID && !HAVE_GETPW_DECLS */
 
 #ifndef NULL
diff --git a/readline/readline/signals.c b/readline/readline/signals.c
index 8fedc370a1ae05890b7b128a6515f0dfa3b5885a..9df365e48e4cd5b0602668e579f1274a43c647d8 100644
--- a/readline/readline/signals.c
+++ b/readline/readline/signals.c
@@ -1,6 +1,6 @@
 /* signals.c -- signal handling support for readline. */
 
-/* Copyright (C) 1987-2017 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -48,23 +48,11 @@
 
 #if defined (HANDLE_SIGNALS)
 
-#if !defined (RETSIGTYPE)
-#  if defined (VOID_SIGHANDLER)
-#    define RETSIGTYPE void
-#  else
-#    define RETSIGTYPE int
-#  endif /* !VOID_SIGHANDLER */
-#endif /* !RETSIGTYPE */
-
-#if defined (VOID_SIGHANDLER)
-#  define SIGHANDLER_RETURN return
-#else
-#  define SIGHANDLER_RETURN return (0)
-#endif
+#define SIGHANDLER_RETURN return
 
 /* This typedef is equivalent to the one for Function; it allows us
    to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
-typedef RETSIGTYPE SigHandler ();
+typedef void SigHandler (int);
 
 #if defined (HAVE_POSIX_SIGNALS)
 typedef struct sigaction sighandler_cxt;
@@ -78,12 +66,12 @@ typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags; } sighandler_cxt
 #  define SA_RESTART 0
 #endif
 
-static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));
-static void rl_maybe_restore_sighandler PARAMS((int, sighandler_cxt *));
+static SigHandler *rl_set_sighandler (int, SigHandler *, sighandler_cxt *);
+static void rl_maybe_set_sighandler (int, SigHandler *, sighandler_cxt *);
+static void rl_maybe_restore_sighandler (int, sighandler_cxt *);
 
-static RETSIGTYPE rl_signal_handler PARAMS((int));
-static RETSIGTYPE _rl_handle_signal PARAMS((int));
+static void rl_signal_handler (int);
+static void _rl_handle_signal (int);
      
 /* Exported variables for use by applications. */
 
@@ -136,7 +124,7 @@ void *_rl_sigcleanarg;
 /* Readline signal handler functions. */
 
 /* Called from RL_CHECK_SIGNALS() macro to run signal handling code. */
-RETSIGTYPE
+void
 _rl_signal_handler (int sig)
 {
   _rl_caught_signal = 0;	/* XXX */
@@ -163,7 +151,7 @@ _rl_signal_handler (int sig)
   SIGHANDLER_RETURN;
 }
 
-static RETSIGTYPE
+static void
 rl_signal_handler (int sig)
 {
   _rl_caught_signal = sig;
@@ -173,7 +161,7 @@ rl_signal_handler (int sig)
 /* This is called to handle a signal when it is safe to do so (out of the
    signal handler execution path). Called by _rl_signal_handler for all the
    signals readline catches except SIGWINCH. */
-static RETSIGTYPE
+static void
 _rl_handle_signal (int sig)
 {
   int block_sig;
@@ -222,6 +210,9 @@ _rl_handle_signal (int sig)
   switch (sig)
     {
     case SIGINT:
+      /* We will end up blocking SIGTTOU while we are resetting the tty, so
+	 watch out for this if it causes problems. We could prevent this by
+	 setting block_sig to 1 without modifying SET. */
       _rl_reset_completion_state ();
       rl_free_line_state ();
 #if defined (READLINE_CALLBACKS)
@@ -242,8 +233,11 @@ _rl_handle_signal (int sig)
 	 this even if we've been stopped on SIGTTOU, since we handle signals
 	 when we have returned from the signal handler and the signal is no
 	 longer blocked. */
-      sigaddset (&set, SIGTTOU);
-      block_sig = 1;
+      if (block_sig == 0)
+	{
+	  sigaddset (&set, SIGTTOU);
+	  block_sig = 1;
+	}
 #  endif
 #endif /* SIGTSTP */
    /* Any signals that should be blocked during cleanup should go here. */
@@ -261,6 +255,8 @@ _rl_handle_signal (int sig)
     case SIGTERM:
 #if defined (SIGALRM)
     case SIGALRM:
+      if (sig == SIGALRM)
+	_rl_timeout_handle_sigalrm ();
 #endif
 #if defined (SIGQUIT)
     case SIGQUIT:
@@ -285,19 +281,6 @@ _rl_handle_signal (int sig)
 
       /* We don't have to bother unblocking the signal because we are not
 	 running in a signal handler context. */
-#if 0
-#if defined (HAVE_POSIX_SIGNALS)
-      /* Make sure this signal is not blocked when we resend it to the
-	 calling application. */
-      sigemptyset (&set);
-      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);
-      sigdelset (&set, sig);
-#else /* !HAVE_POSIX_SIGNALS */
-#  if defined (HAVE_BSD_SIGNALS)
-      omask = sigblock (0);
-#  endif /* HAVE_BSD_SIGNALS */
-#endif /* !HAVE_POSIX_SIGNALS */
-#endif
 
 #if defined (__EMX__)
       signal (sig, SIG_ACK);
@@ -311,16 +294,6 @@ _rl_handle_signal (int sig)
 
       /* We don't need to modify the signal mask now that this is not run in
 	 a signal handler context. */
-#if 0
-      /* Let the signal that we just sent through if it is blocked.  */
-#if defined (HAVE_POSIX_SIGNALS)
-      sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);
-#else /* !HAVE_POSIX_SIGNALS */
-#  if defined (HAVE_BSD_SIGNALS)
-      sigsetmask (omask & ~(sigmask (sig)));
-#  endif /* HAVE_BSD_SIGNALS */
-#endif /* !HAVE_POSIX_SIGNALS */
-#endif
 
       rl_reset_after_signal ();      
     }
@@ -330,7 +303,7 @@ _rl_handle_signal (int sig)
 }
 
 #if defined (SIGWINCH)
-static RETSIGTYPE
+static void
 rl_sigwinch_handler (int sig)
 {
   SigHandler *oh;
diff --git a/readline/readline/support/config.guess b/readline/readline/support/config.guess
old mode 100755
new mode 100644
index cc7a81070119c7500643623fb70626b7adf31261..b66eb09d6150b196c2fbd8534f0d03b337a116e9
--- a/readline/readline/support/config.guess
+++ b/readline/readline/support/config.guess
@@ -1,12 +1,14 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2021 Free Software Foundation, Inc.
+#   Copyright 1992-2022 Free Software Foundation, Inc.
 
-timestamp='2021-04-21'
+# shellcheck disable=SC2006,SC2268 # see below for rationale
+
+timestamp='2024-11-16'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License, or
+# the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -32,7 +34,15 @@ timestamp='2021-04-21'
 # Please send patches to <config-patches@gnu.org>.
 
 
-me=$(echo "$0" | sed -e 's,.*/,,')
+# The "shellcheck disable" line above the timestamp inhibits complaints
+# about features and limitations of the classic Bourne shell that were
+# superseded or lifted in POSIX.  However, this script identifies a wide
+# variety of pre-POSIX systems that do not have POSIX shells at all, and
+# even some reasonably current systems (Solaris 10 as case-in-point) still
+# have a pre-POSIX /bin/sh.
+
+
+me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
 Usage: $0 [OPTION]
@@ -50,7 +60,7 @@ version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2021 Free Software Foundation, Inc.
+Copyright 1992-2022 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -84,6 +94,9 @@ if test $# != 0; then
   exit 1
 fi
 
+# Just in case it came from the environment.
+GUESS=
+
 # CC_FOR_BUILD -- compiler used by this script. Note that the use of a
 # compiler to aid in system detection is discouraged as it requires
 # temporary files to be created and, as you can see below, it is a
@@ -102,8 +115,8 @@ set_cc_for_build() {
     # prevent multiple calls if $tmp is already set
     test "$tmp" && return 0
     : "${TMPDIR=/tmp}"
-    # shellcheck disable=SC2039
-    { tmp=$( (umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null) && test -n "$tmp" && test -d "$tmp" ; } ||
+    # shellcheck disable=SC2039,SC3028
+    { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
 	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
 	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
 	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }
@@ -112,7 +125,7 @@ set_cc_for_build() {
 	,,)    echo "int x;" > "$dummy.c"
 	       for driver in cc gcc c89 c99 ; do
 		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
-		       CC_FOR_BUILD="$driver"
+		       CC_FOR_BUILD=$driver
 		       break
 		   fi
 	       done
@@ -131,12 +144,12 @@ if test -f /.attbin/uname ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
-UNAME_MACHINE=$( (uname -m) 2>/dev/null) || UNAME_MACHINE=unknown
-UNAME_RELEASE=$( (uname -r) 2>/dev/null) || UNAME_RELEASE=unknown
-UNAME_SYSTEM=$( (uname -s) 2>/dev/null) || UNAME_SYSTEM=unknown
-UNAME_VERSION=$( (uname -v) 2>/dev/null) || UNAME_VERSION=unknown
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
-case "$UNAME_SYSTEM" in
+case $UNAME_SYSTEM in
 Linux|GNU|GNU/*)
 	LIBC=unknown
 
@@ -157,7 +170,8 @@ Linux|GNU|GNU/*)
 	#endif
 	#endif
 	EOF
-	eval "$($CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g')"
+	cc_set_libc=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	eval "$cc_set_libc"
 
 	# Second heuristic to detect musl libc.
 	if [ "$LIBC" = unknown ] &&
@@ -176,7 +190,7 @@ esac
 
 # Note: order is significant - the case branches are not exclusive.
 
-case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+case $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in
     *:NetBSD:*:*)
 	# NetBSD (nbsd) targets should (where applicable) match one or
 	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
@@ -188,11 +202,11 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	#
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
-	UNAME_MACHINE_ARCH=$( (uname -p 2>/dev/null || \
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
 	    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \
 	    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \
-	    echo unknown))
-	case "$UNAME_MACHINE_ARCH" in
+	    echo unknown)`
+	case $UNAME_MACHINE_ARCH in
 	    aarch64eb) machine=aarch64_be-unknown ;;
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
@@ -200,15 +214,15 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
 	    earmv*)
-		arch=$(echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,')
-		endian=$(echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p')
-		machine="${arch}${endian}"-unknown
+		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine=${arch}${endian}-unknown
 		;;
-	    *) machine="$UNAME_MACHINE_ARCH"-unknown ;;
+	    *) machine=$UNAME_MACHINE_ARCH-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently (or will in the future) and ABI.
-	case "$UNAME_MACHINE_ARCH" in
+	case $UNAME_MACHINE_ARCH in
 	    earm*)
 		os=netbsdelf
 		;;
@@ -229,10 +243,10 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 		;;
 	esac
 	# Determine ABI tags.
-	case "$UNAME_MACHINE_ARCH" in
+	case $UNAME_MACHINE_ARCH in
 	    earm*)
 		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
-		abi=$(echo "$UNAME_MACHINE_ARCH" | sed -e "$expr")
+		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
 		;;
 	esac
 	# The OS release
@@ -240,80 +254,82 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	# thus, need a distinct triplet. However, they do not need
 	# kernel version information, so it can be replaced with a
 	# suitable tag, in the style of linux-gnu.
-	case "$UNAME_VERSION" in
+	case $UNAME_VERSION in
 	    Debian*)
 		release='-gnu'
 		;;
 	    *)
-		release=$(echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2)
+		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "$machine-${os}${release}${abi-}"
-	exit ;;
+	GUESS=$machine-${os}${release}${abi-}
+	;;
     *:Bitrig:*:*)
-	UNAME_MACHINE_ARCH=$(arch | sed 's/Bitrig.//')
-	echo "$UNAME_MACHINE_ARCH"-unknown-bitrig"$UNAME_RELEASE"
-	exit ;;
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-bitrig$UNAME_RELEASE
+	;;
     *:OpenBSD:*:*)
-	UNAME_MACHINE_ARCH=$(arch | sed 's/OpenBSD.//')
-	echo "$UNAME_MACHINE_ARCH"-unknown-openbsd"$UNAME_RELEASE"
-	exit ;;
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-openbsd$UNAME_RELEASE
+	;;
     *:SecBSD:*:*)
-	UNAME_MACHINE_ARCH=$(arch | sed 's/SecBSD.//')
-	echo "$UNAME_MACHINE_ARCH"-unknown-secbsd"$UNAME_RELEASE"
-	exit ;;
+	UNAME_MACHINE_ARCH=`arch | sed 's/SecBSD.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-secbsd$UNAME_RELEASE
+	;;
     *:LibertyBSD:*:*)
-	UNAME_MACHINE_ARCH=$(arch | sed 's/^.*BSD\.//')
-	echo "$UNAME_MACHINE_ARCH"-unknown-libertybsd"$UNAME_RELEASE"
-	exit ;;
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-libertybsd$UNAME_RELEASE
+	;;
     *:MidnightBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-midnightbsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-midnightbsd$UNAME_RELEASE
+	;;
     *:ekkoBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-ekkobsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-ekkobsd$UNAME_RELEASE
+	;;
     *:SolidBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-solidbsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-solidbsd$UNAME_RELEASE
+	;;
     *:OS108:*:*)
-	echo "$UNAME_MACHINE"-unknown-os108_"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-os108_$UNAME_RELEASE
+	;;
     macppc:MirBSD:*:*)
-	echo powerpc-unknown-mirbsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=powerpc-unknown-mirbsd$UNAME_RELEASE
+	;;
     *:MirBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-mirbsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-mirbsd$UNAME_RELEASE
+	;;
     *:Sortix:*:*)
-	echo "$UNAME_MACHINE"-unknown-sortix
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-sortix
+	;;
     *:Twizzler:*:*)
-	echo "$UNAME_MACHINE"-unknown-twizzler
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-twizzler
+	;;
     *:Redox:*:*)
-	echo "$UNAME_MACHINE"-unknown-redox
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-redox
+	;;
     mips:OSF1:*.*)
-	echo mips-dec-osf1
-	exit ;;
+	GUESS=mips-dec-osf1
+	;;
     alpha:OSF1:*:*)
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	trap '' 0
 	case $UNAME_RELEASE in
 	*4.0)
-		UNAME_RELEASE=$(/usr/sbin/sizer -v | awk '{print $3}')
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
 		;;
 	*5.*)
-		UNAME_RELEASE=$(/usr/sbin/sizer -v | awk '{print $4}')
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
 		;;
 	esac
 	# According to Compaq, /usr/sbin/psrinfo has been available on
 	# OSF/1 and Tru64 systems produced since 1995.  I hope that
 	# covers most systems running today.  This code pipes the CPU
 	# types through head -n 1, so we only detect the type of CPU 0.
-	ALPHA_CPU_TYPE=$(/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1)
-	case "$ALPHA_CPU_TYPE" in
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case $ALPHA_CPU_TYPE in
 	    "EV4 (21064)")
 		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
@@ -350,68 +366,69 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo "$UNAME_MACHINE"-dec-osf"$(echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz)"
-	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
-	exitcode=$?
-	trap '' 0
-	exit $exitcode ;;
+	OSF_REL=`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	GUESS=$UNAME_MACHINE-dec-osf$OSF_REL
+	;;
     Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-unknown-sysv4
-	exit ;;
+	GUESS=m68k-unknown-sysv4
+	;;
     *:[Aa]miga[Oo][Ss]:*:*)
-	echo "$UNAME_MACHINE"-unknown-amigaos
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-amigaos
+	;;
     *:[Mm]orph[Oo][Ss]:*:*)
-	echo "$UNAME_MACHINE"-unknown-morphos
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-morphos
+	;;
     *:OS/390:*:*)
-	echo i370-ibm-openedition
-	exit ;;
+	GUESS=i370-ibm-openedition
+	;;
     *:z/VM:*:*)
-	echo s390-ibm-zvmoe
-	exit ;;
+	GUESS=s390-ibm-zvmoe
+	;;
     *:OS400:*:*)
-	echo powerpc-ibm-os400
-	exit ;;
+	GUESS=powerpc-ibm-os400
+	;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix"$UNAME_RELEASE"
-	exit ;;
+	GUESS=arm-acorn-riscix$UNAME_RELEASE
+	;;
     arm*:riscos:*:*|arm*:RISCOS:*:*)
-	echo arm-unknown-riscos
-	exit ;;
+	GUESS=arm-unknown-riscos
+	;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
-	echo hppa1.1-hitachi-hiuxmpp
-	exit ;;
+	GUESS=hppa1.1-hitachi-hiuxmpp
+	;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
-	if test "$( (/bin/universe) 2>/dev/null)" = att ; then
-		echo pyramid-pyramid-sysv3
-	else
-		echo pyramid-pyramid-bsd
-	fi
-	exit ;;
+	case `(/bin/universe) 2>/dev/null` in
+	    att) GUESS=pyramid-pyramid-sysv3 ;;
+	    *)   GUESS=pyramid-pyramid-bsd   ;;
+	esac
+	;;
     NILE*:*:*:dcosx)
-	echo pyramid-pyramid-svr4
-	exit ;;
+	GUESS=pyramid-pyramid-svr4
+	;;
     DRS?6000:unix:4.0:6*)
-	echo sparc-icl-nx6
-	exit ;;
+	GUESS=sparc-icl-nx6
+	;;
     DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
-	case $(/usr/bin/uname -p) in
-	    sparc) echo sparc-icl-nx7; exit ;;
-	esac ;;
+	case `/usr/bin/uname -p` in
+	    sparc) GUESS=sparc-icl-nx7 ;;
+	esac
+	;;
     s390x:SunOS:*:*)
-	echo "$UNAME_MACHINE"-ibm-solaris2"$(echo "$UNAME_RELEASE" | sed -e 's/[^.]*//')"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=$UNAME_MACHINE-ibm-solaris2$SUN_REL
+	;;
     sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-hal-solaris2$SUN_REL
+	;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2"$(echo "$UNAME_RELEASE" | sed -e 's/[^.]*//')"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-sun-solaris2$SUN_REL
+	;;
     i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
-	echo i386-pc-auroraux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=i386-pc-auroraux$UNAME_RELEASE
+	;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	set_cc_for_build
 	SUN_ARCH=i386
@@ -420,47 +437,50 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	# This test works for both compilers.
 	if test "$CC_FOR_BUILD" != no_compiler_found; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		(CCOPTS="" $CC_FOR_BUILD -m64 -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
 		SUN_ARCH=x86_64
 	    fi
 	fi
-	echo "$SUN_ARCH"-pc-solaris2"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=$SUN_ARCH-pc-solaris2$SUN_REL
+	;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-sun-solaris3$SUN_REL
+	;;
     sun4*:SunOS:*:*)
-	case "$(/usr/bin/arch -k)" in
+	case `/usr/bin/arch -k` in
 	    Series*|S4*)
-		UNAME_RELEASE=$(uname -v)
+		UNAME_RELEASE=`uname -v`
 		;;
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos"$(echo "$UNAME_RELEASE"|sed -e 's/-/_/')"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/'`
+	GUESS=sparc-sun-sunos$SUN_REL
+	;;
     sun3*:SunOS:*:*)
-	echo m68k-sun-sunos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-sun-sunos$UNAME_RELEASE
+	;;
     sun*:*:4.2BSD:*)
-	UNAME_RELEASE=$( (sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
 	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
-	case "$(/bin/arch)" in
+	case `/bin/arch` in
 	    sun3)
-		echo m68k-sun-sunos"$UNAME_RELEASE"
+		GUESS=m68k-sun-sunos$UNAME_RELEASE
 		;;
 	    sun4)
-		echo sparc-sun-sunos"$UNAME_RELEASE"
+		GUESS=sparc-sun-sunos$UNAME_RELEASE
 		;;
 	esac
-	exit ;;
+	;;
     aushp:SunOS:*:*)
-	echo sparc-auspex-sunos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sparc-auspex-sunos$UNAME_RELEASE
+	;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
     # "atarist" or "atariste" at least should have a processor
@@ -470,41 +490,41 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-	echo m68k-milan-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-milan-mint$UNAME_RELEASE
+	;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-	echo m68k-hades-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-hades-mint$UNAME_RELEASE
+	;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-	echo m68k-unknown-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-unknown-mint$UNAME_RELEASE
+	;;
     m68k:machten:*:*)
-	echo m68k-apple-machten"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-apple-machten$UNAME_RELEASE
+	;;
     powerpc:machten:*:*)
-	echo powerpc-apple-machten"$UNAME_RELEASE"
-	exit ;;
+	GUESS=powerpc-apple-machten$UNAME_RELEASE
+	;;
     RISC*:Mach:*:*)
-	echo mips-dec-mach_bsd4.3
-	exit ;;
+	GUESS=mips-dec-mach_bsd4.3
+	;;
     RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix"$UNAME_RELEASE"
-	exit ;;
+	GUESS=mips-dec-ultrix$UNAME_RELEASE
+	;;
     VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix"$UNAME_RELEASE"
-	exit ;;
+	GUESS=vax-dec-ultrix$UNAME_RELEASE
+	;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix"$UNAME_RELEASE"
-	exit ;;
+	GUESS=clipper-intergraph-clix$UNAME_RELEASE
+	;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
 	set_cc_for_build
 	sed 's/^	//' << EOF > "$dummy.c"
@@ -529,78 +549,79 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	}
 EOF
 	$CC_FOR_BUILD -o "$dummy" "$dummy.c" &&
-	  dummyarg=$(echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p') &&
-	  SYSTEM_NAME=$("$dummy" "$dummyarg") &&
+	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
 	    { echo "$SYSTEM_NAME"; exit; }
-	echo mips-mips-riscos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=mips-mips-riscos$UNAME_RELEASE
+	;;
     Motorola:PowerMAX_OS:*:*)
-	echo powerpc-motorola-powermax
-	exit ;;
+	GUESS=powerpc-motorola-powermax
+	;;
     Motorola:*:4.3:PL8-*)
-	echo powerpc-harris-powermax
-	exit ;;
+	GUESS=powerpc-harris-powermax
+	;;
     Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
-	echo powerpc-harris-powermax
-	exit ;;
+	GUESS=powerpc-harris-powermax
+	;;
     Night_Hawk:Power_UNIX:*:*)
-	echo powerpc-harris-powerunix
-	exit ;;
+	GUESS=powerpc-harris-powerunix
+	;;
     m88k:CX/UX:7*:*)
-	echo m88k-harris-cxux7
-	exit ;;
+	GUESS=m88k-harris-cxux7
+	;;
     m88k:*:4*:R4*)
-	echo m88k-motorola-sysv4
-	exit ;;
+	GUESS=m88k-motorola-sysv4
+	;;
     m88k:*:3*:R3*)
-	echo m88k-motorola-sysv3
-	exit ;;
+	GUESS=m88k-motorola-sysv3
+	;;
     AViiON:dgux:*:*)
 	# DG/UX returns AViiON for all architectures
-	UNAME_PROCESSOR=$(/usr/bin/uname -p)
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
 	if test "$UNAME_PROCESSOR" = mc88100 || test "$UNAME_PROCESSOR" = mc88110
 	then
 	    if test "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx || \
 	       test "$TARGET_BINARY_INTERFACE"x = x
 	    then
-		echo m88k-dg-dgux"$UNAME_RELEASE"
+		GUESS=m88k-dg-dgux$UNAME_RELEASE
 	    else
-		echo m88k-dg-dguxbcs"$UNAME_RELEASE"
+		GUESS=m88k-dg-dguxbcs$UNAME_RELEASE
 	    fi
 	else
-	    echo i586-dg-dgux"$UNAME_RELEASE"
+	    GUESS=i586-dg-dgux$UNAME_RELEASE
 	fi
-	exit ;;
+	;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
-	echo m88k-dolphin-sysv3
-	exit ;;
+	GUESS=m88k-dolphin-sysv3
+	;;
     M88*:*:R3*:*)
 	# Delta 88k system running SVR3
-	echo m88k-motorola-sysv3
-	exit ;;
+	GUESS=m88k-motorola-sysv3
+	;;
     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
-	echo m88k-tektronix-sysv3
-	exit ;;
+	GUESS=m88k-tektronix-sysv3
+	;;
     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
-	echo m68k-tektronix-bsd
-	exit ;;
+	GUESS=m68k-tektronix-bsd
+	;;
     *:IRIX*:*:*)
-	echo mips-sgi-irix"$(echo "$UNAME_RELEASE"|sed -e 's/-/_/g')"
-	exit ;;
+	IRIX_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/g'`
+	GUESS=mips-sgi-irix$IRIX_REL
+	;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
-	exit ;;               # Note that: echo "'$(uname -s)'" gives 'AIX '
+	GUESS=romp-ibm-aix    # uname -m gives an 8 hex-code CPU id
+	;;                    # Note that: echo "'`uname -s`'" gives 'AIX '
     i*86:AIX:*:*)
-	echo i386-ibm-aix
-	exit ;;
+	GUESS=i386-ibm-aix
+	;;
     ia64:AIX:*:*)
 	if test -x /usr/bin/oslevel ; then
-		IBM_REV=$(/usr/bin/oslevel)
+		IBM_REV=`/usr/bin/oslevel`
 	else
-		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
+		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
 	fi
-	echo "$UNAME_MACHINE"-ibm-aix"$IBM_REV"
-	exit ;;
+	GUESS=$UNAME_MACHINE-ibm-aix$IBM_REV
+	;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
 		set_cc_for_build
@@ -615,68 +636,68 @@ EOF
 			exit(0);
 			}
 EOF
-		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=$("$dummy")
+		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
 		then
-			echo "$SYSTEM_NAME"
+			GUESS=$SYSTEM_NAME
 		else
-			echo rs6000-ibm-aix3.2.5
+			GUESS=rs6000-ibm-aix3.2.5
 		fi
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
-		echo rs6000-ibm-aix3.2.4
+		GUESS=rs6000-ibm-aix3.2.4
 	else
-		echo rs6000-ibm-aix3.2
+		GUESS=rs6000-ibm-aix3.2
 	fi
-	exit ;;
+	;;
     *:AIX:*:[4567])
-	IBM_CPU_ID=$(/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }')
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
 	if test -x /usr/bin/lslpp ; then
-		IBM_REV=$(/usr/bin/lslpp -Lqc bos.rte.libc |
-			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/)
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc | \
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
-		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
+		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
 	fi
-	echo "$IBM_ARCH"-ibm-aix"$IBM_REV"
-	exit ;;
+	GUESS=$IBM_ARCH-ibm-aix$IBM_REV
+	;;
     *:AIX:*:*)
-	echo rs6000-ibm-aix
-	exit ;;
+	GUESS=rs6000-ibm-aix
+	;;
     ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)
-	echo romp-ibm-bsd4.4
-	exit ;;
+	GUESS=romp-ibm-bsd4.4
+	;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
-	echo romp-ibm-bsd"$UNAME_RELEASE"   # 4.3 with uname added to
-	exit ;;                             # report: romp-ibm BSD 4.3
+	GUESS=romp-ibm-bsd$UNAME_RELEASE    # 4.3 with uname added to
+	;;                                  # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
-	echo rs6000-bull-bosx
-	exit ;;
+	GUESS=rs6000-bull-bosx
+	;;
     DPX/2?00:B.O.S.:*:*)
-	echo m68k-bull-sysv3
-	exit ;;
+	GUESS=m68k-bull-sysv3
+	;;
     9000/[34]??:4.3bsd:1.*:*)
-	echo m68k-hp-bsd
-	exit ;;
+	GUESS=m68k-hp-bsd
+	;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
-	echo m68k-hp-bsd4.4
-	exit ;;
+	GUESS=m68k-hp-bsd4.4
+	;;
     9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//')
-	case "$UNAME_MACHINE" in
+	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
+	case $UNAME_MACHINE in
 	    9000/31?)            HP_ARCH=m68000 ;;
 	    9000/[34]??)         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
 		if test -x /usr/bin/getconf; then
-		    sc_cpu_version=$(/usr/bin/getconf SC_CPU_VERSION 2>/dev/null)
-		    sc_kernel_bits=$(/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null)
-		    case "$sc_cpu_version" in
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		    case $sc_cpu_version in
 		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
 		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
 		      532)                      # CPU_PA_RISC2_0
-			case "$sc_kernel_bits" in
+			case $sc_kernel_bits in
 			  32) HP_ARCH=hppa2.0n ;;
 			  64) HP_ARCH=hppa2.0w ;;
 			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
@@ -718,7 +739,7 @@ EOF
 		    exit (0);
 		}
 EOF
-		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=$("$dummy")
+		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=`"$dummy"`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
@@ -743,12 +764,12 @@ EOF
 		HP_ARCH=hppa64
 	    fi
 	fi
-	echo "$HP_ARCH"-hp-hpux"$HPUX_REV"
-	exit ;;
+	GUESS=$HP_ARCH-hp-hpux$HPUX_REV
+	;;
     ia64:HP-UX:*:*)
-	HPUX_REV=$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//')
-	echo ia64-hp-hpux"$HPUX_REV"
-	exit ;;
+	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
+	GUESS=ia64-hp-hpux$HPUX_REV
+	;;
     3050*:HI-UX:*:*)
 	set_cc_for_build
 	sed 's/^	//' << EOF > "$dummy.c"
@@ -776,38 +797,38 @@ EOF
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=$("$dummy") &&
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
 		{ echo "$SYSTEM_NAME"; exit; }
-	echo unknown-hitachi-hiuxwe2
-	exit ;;
+	GUESS=unknown-hitachi-hiuxwe2
+	;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
-	echo hppa1.1-hp-bsd
-	exit ;;
+	GUESS=hppa1.1-hp-bsd
+	;;
     9000/8??:4.3bsd:*:*)
-	echo hppa1.0-hp-bsd
-	exit ;;
+	GUESS=hppa1.0-hp-bsd
+	;;
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
-	echo hppa1.0-hp-mpeix
-	exit ;;
+	GUESS=hppa1.0-hp-mpeix
+	;;
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
-	echo hppa1.1-hp-osf
-	exit ;;
+	GUESS=hppa1.1-hp-osf
+	;;
     hp8??:OSF1:*:*)
-	echo hppa1.0-hp-osf
-	exit ;;
+	GUESS=hppa1.0-hp-osf
+	;;
     i*86:OSF1:*:*)
 	if test -x /usr/sbin/sysversion ; then
-	    echo "$UNAME_MACHINE"-unknown-osf1mk
+	    GUESS=$UNAME_MACHINE-unknown-osf1mk
 	else
-	    echo "$UNAME_MACHINE"-unknown-osf1
+	    GUESS=$UNAME_MACHINE-unknown-osf1
 	fi
-	exit ;;
+	;;
     parisc*:Lites*:*:*)
-	echo hppa1.1-hp-lites
-	exit ;;
+	GUESS=hppa1.1-hp-lites
+	;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
-	echo c1-convex-bsd
-	exit ;;
+	GUESS=c1-convex-bsd
+	;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
@@ -815,17 +836,18 @@ EOF
 	fi
 	exit ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
-	echo c34-convex-bsd
-	exit ;;
+	GUESS=c34-convex-bsd
+	;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
-	echo c38-convex-bsd
-	exit ;;
+	GUESS=c38-convex-bsd
+	;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
-	echo c4-convex-bsd
-	exit ;;
+	GUESS=c4-convex-bsd
+	;;
     CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=ymp-cray-unicos$CRAY_REL
+	;;
     CRAY*[A-Z]90:*:*:*)
 	echo "$UNAME_MACHINE"-cray-unicos"$UNAME_RELEASE" \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
@@ -833,114 +855,129 @@ EOF
 	      -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*TS:*:*:*)
-	echo t90-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=t90-cray-unicos$CRAY_REL
+	;;
     CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=alphaev5-cray-unicosmk$CRAY_REL
+	;;
     CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=sv1-cray-unicos$CRAY_REL
+	;;
     *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=craynv-cray-unicosmp$CRAY_REL
+	;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=$(uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz)
-	FUJITSU_SYS=$(uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///')
-	FUJITSU_REL=$(echo "$UNAME_RELEASE" | sed -e 's/ /_/')
-	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit ;;
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
+	GUESS=${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
+	;;
     5000:UNIX_System_V:4.*:*)
-	FUJITSU_SYS=$(uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///')
-	FUJITSU_REL=$(echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/')
-	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit ;;
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
+	GUESS=sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
+	;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
-	echo "$UNAME_MACHINE"-pc-bsdi"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-bsdi$UNAME_RELEASE
+	;;
     sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sparc-unknown-bsdi$UNAME_RELEASE
+	;;
     *:BSD/OS:*:*)
-	echo "$UNAME_MACHINE"-unknown-bsdi"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-bsdi$UNAME_RELEASE
+	;;
     arm:FreeBSD:*:*)
-	UNAME_PROCESSOR=$(uname -p)
+	UNAME_PROCESSOR=`uname -p`
 	set_cc_for_build
 	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_PCS_VFP
 	then
-	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"$(echo ${UNAME_RELEASE}|sed -e 's/[-(].*//')"-gnueabi
+	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabi
 	else
-	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"$(echo ${UNAME_RELEASE}|sed -e 's/[-(].*//')"-gnueabihf
+	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabihf
 	fi
-	exit ;;
+	;;
     *:FreeBSD:*:*)
-	UNAME_PROCESSOR=$(/usr/bin/uname -p)
-	case "$UNAME_PROCESSOR" in
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	case $UNAME_PROCESSOR in
 	    amd64)
 		UNAME_PROCESSOR=x86_64 ;;
 	    i386)
 		UNAME_PROCESSOR=i586 ;;
 	esac
-	echo "$UNAME_PROCESSOR"-unknown-freebsd"$(echo "$UNAME_RELEASE"|sed -e 's/[-(].*//')"
-	exit ;;
+	FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL
+	;;
     i*:CYGWIN*:*)
-	echo "$UNAME_MACHINE"-pc-cygwin
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-cygwin
+	;;
     *:MINGW64*:*)
-	echo "$UNAME_MACHINE"-pc-mingw64
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-mingw64
+	;;
     *:MINGW*:*)
-	echo "$UNAME_MACHINE"-pc-mingw32
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-mingw32
+	;;
     *:MSYS*:*)
-	echo "$UNAME_MACHINE"-pc-msys
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-msys
+	;;
     i*:PW*:*)
-	echo "$UNAME_MACHINE"-pc-pw32
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-pw32
+	;;
+    *:SerenityOS:*:*)
+        GUESS=$UNAME_MACHINE-pc-serenity
+        ;;
     *:Interix*:*)
-	case "$UNAME_MACHINE" in
+	case $UNAME_MACHINE in
 	    x86)
-		echo i586-pc-interix"$UNAME_RELEASE"
-		exit ;;
+		GUESS=i586-pc-interix$UNAME_RELEASE
+		;;
 	    authenticamd | genuineintel | EM64T)
-		echo x86_64-unknown-interix"$UNAME_RELEASE"
-		exit ;;
+		GUESS=x86_64-unknown-interix$UNAME_RELEASE
+		;;
 	    IA64)
-		echo ia64-unknown-interix"$UNAME_RELEASE"
-		exit ;;
+		GUESS=ia64-unknown-interix$UNAME_RELEASE
+		;;
 	esac ;;
     i*:UWIN*:*)
-	echo "$UNAME_MACHINE"-pc-uwin
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-uwin
+	;;
     amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
-	echo x86_64-pc-cygwin
-	exit ;;
+	GUESS=x86_64-pc-cygwin
+	;;
     prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=powerpcle-unknown-solaris2$SUN_REL
+	;;
     *:GNU:*:*)
 	# the GNU system
-	echo "$(echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,')-unknown-$LIBC$(echo "$UNAME_RELEASE"|sed -e 's,/.*$,,')"
-	exit ;;
+	GNU_ARCH=`echo "$UNAME_MACHINE" | sed -e 's,[-/].*$,,'`
+	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's,/.*$,,'`
+	GUESS=$GNU_ARCH-unknown-$LIBC$GNU_REL
+	;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo "$UNAME_MACHINE-unknown-$(echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]")$(echo "$UNAME_RELEASE"|sed -e 's/[-(].*//')-$LIBC"
-	exit ;;
+	GNU_SYS=`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"`
+	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_MACHINE-unknown-$GNU_SYS$GNU_REL-$LIBC
+	;;
     *:Minix:*:*)
-	echo "$UNAME_MACHINE"-unknown-minix
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-minix
+	;;
     aarch64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     aarch64_be:Linux:*:*)
 	UNAME_MACHINE=aarch64_be
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     alpha:Linux:*:*)
-	case $(sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null) in
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null` in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
 	  EV56)  UNAME_MACHINE=alphaev56 ;;
 	  PCA56) UNAME_MACHINE=alphapca56 ;;
@@ -951,63 +988,63 @@ EOF
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
 	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
-    arc:Linux:*:* | arceb:Linux:*:* | arc64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    arc:Linux:*:* | arceb:Linux:*:* | arc32:Linux:*:* | arc64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     arm*:Linux:*:*)
 	set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	    GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
 	else
 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 		| grep -q __ARM_PCS_VFP
 	    then
-		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabi
+		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabi
 	    else
-		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabihf
+		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabihf
 	    fi
 	fi
-	exit ;;
+	;;
     avr32*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     cris:Linux:*:*)
-	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
+	;;
     crisv32:Linux:*:*)
-	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
+	;;
     e2k:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     frv:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     hexagon:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     i*86:Linux:*:*)
-	echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-linux-$LIBC
+	;;
     ia64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     k1om:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     loongarch32:Linux:*:* | loongarch64:Linux:*:* | loongarchx32:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     m32r*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     m68*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     mips:Linux:*:* | mips64:Linux:*:*)
 	set_cc_for_build
 	IS_GLIBC=0
@@ -1052,65 +1089,66 @@ EOF
 	#endif
 	#endif
 EOF
-	eval "$($CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI')"
+	cc_set_vars=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`
+	eval "$cc_set_vars"
 	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
 	;;
     mips64el:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     openrisc*:Linux:*:*)
-	echo or1k-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=or1k-unknown-linux-$LIBC
+	;;
     or32:Linux:*:* | or1k*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=sparc-unknown-linux-$LIBC
+	;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=hppa64-unknown-linux-$LIBC
+	;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
-	case $(grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2) in
-	  PA7*) echo hppa1.1-unknown-linux-"$LIBC" ;;
-	  PA8*) echo hppa2.0-unknown-linux-"$LIBC" ;;
-	  *)    echo hppa-unknown-linux-"$LIBC" ;;
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) GUESS=hppa1.1-unknown-linux-$LIBC ;;
+	  PA8*) GUESS=hppa2.0-unknown-linux-$LIBC ;;
+	  *)    GUESS=hppa-unknown-linux-$LIBC ;;
 	esac
-	exit ;;
+	;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=powerpc64-unknown-linux-$LIBC
+	;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=powerpc-unknown-linux-$LIBC
+	;;
     ppc64le:Linux:*:*)
-	echo powerpc64le-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=powerpc64le-unknown-linux-$LIBC
+	;;
     ppcle:Linux:*:*)
-	echo powerpcle-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=powerpcle-unknown-linux-$LIBC
+	;;
     riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo "$UNAME_MACHINE"-ibm-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-ibm-linux-$LIBC
+	;;
     sh64*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     sh*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     tile*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     vax:Linux:*:*)
-	echo "$UNAME_MACHINE"-dec-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-dec-linux-$LIBC
+	;;
     x86_64:Linux:*:*)
 	set_cc_for_build
 	LIBCABI=$LIBC
@@ -1119,71 +1157,71 @@ EOF
 		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_X32 >/dev/null
 	    then
-		LIBCABI="$LIBC"x32
+		LIBCABI=${LIBC}x32
 	    fi
 	fi
-	echo "$UNAME_MACHINE"-pc-linux-"$LIBCABI"
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-linux-$LIBCABI
+	;;
     xtensa*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
 	# sysname and nodename.
-	echo i386-sequent-sysv4
-	exit ;;
+	GUESS=i386-sequent-sysv4
+	;;
     i*86:UNIX_SV:4.2MP:2.*)
 	# Unixware is an offshoot of SVR4, but it has its own version
 	# number series starting with 2...
 	# I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
 	# Use sysv4.2uw... so that sysv4* matches it.
-	echo "$UNAME_MACHINE"-pc-sysv4.2uw"$UNAME_VERSION"
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-sysv4.2uw$UNAME_VERSION
+	;;
     i*86:OS/2:*:*)
 	# If we were able to find `uname', then EMX Unix compatibility
 	# is probably installed.
-	echo "$UNAME_MACHINE"-pc-os2-emx
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-os2-emx
+	;;
     i*86:XTS-300:*:STOP)
-	echo "$UNAME_MACHINE"-unknown-stop
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-stop
+	;;
     i*86:atheos:*:*)
-	echo "$UNAME_MACHINE"-unknown-atheos
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-atheos
+	;;
     i*86:syllable:*:*)
-	echo "$UNAME_MACHINE"-pc-syllable
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-syllable
+	;;
     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
-	echo i386-unknown-lynxos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=i386-unknown-lynxos$UNAME_RELEASE
+	;;
     i*86:*DOS:*:*)
-	echo "$UNAME_MACHINE"-pc-msdosdjgpp
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-msdosdjgpp
+	;;
     i*86:*:4.*:*)
-	UNAME_REL=$(echo "$UNAME_RELEASE" | sed 's/\/MP$//')
+	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo "$UNAME_MACHINE"-univel-sysv"$UNAME_REL"
+		GUESS=$UNAME_MACHINE-univel-sysv$UNAME_REL
 	else
-		echo "$UNAME_MACHINE"-pc-sysv"$UNAME_REL"
+		GUESS=$UNAME_MACHINE-pc-sysv$UNAME_REL
 	fi
-	exit ;;
+	;;
     i*86:*:5:[678]*)
 	# UnixWare 7.x, OpenUNIX and OpenServer 6.
-	case $(/bin/uname -X | grep "^Machine") in
+	case `/bin/uname -X | grep "^Machine"` in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
-	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
-		UNAME_REL=$(sed -n 's/.*Version //p' </usr/options/cb.name)
-		echo "$UNAME_MACHINE"-pc-isc"$UNAME_REL"
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		GUESS=$UNAME_MACHINE-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
-		UNAME_REL=$( (/bin/uname -X|grep Release|sed -e 's/.*= //'))
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
 		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
 			&& UNAME_MACHINE=i586
@@ -1191,11 +1229,11 @@ EOF
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
-		echo "$UNAME_MACHINE"-pc-sco"$UNAME_REL"
+		GUESS=$UNAME_MACHINE-pc-sco$UNAME_REL
 	else
-		echo "$UNAME_MACHINE"-pc-sysv32
+		GUESS=$UNAME_MACHINE-pc-sysv32
 	fi
-	exit ;;
+	;;
     pc:*:*:*)
 	# Left here for compatibility:
 	# uname -m prints for DJGPP always 'pc', but it prints nothing about
@@ -1203,37 +1241,37 @@ EOF
 	# Note: whatever this is, it MUST be the same as what config.sub
 	# prints for the "djgpp" host, or else GDB configure will decide that
 	# this is a cross-build.
-	echo i586-pc-msdosdjgpp
-	exit ;;
+	GUESS=i586-pc-msdosdjgpp
+	;;
     Intel:Mach:3*:*)
-	echo i386-pc-mach3
-	exit ;;
+	GUESS=i386-pc-mach3
+	;;
     paragon:*:*:*)
-	echo i860-intel-osf1
-	exit ;;
+	GUESS=i860-intel-osf1
+	;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
-	  echo i860-stardent-sysv"$UNAME_RELEASE" # Stardent Vistra i860-SVR4
+	  GUESS=i860-stardent-sysv$UNAME_RELEASE    # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv"$UNAME_RELEASE"  # Unknown i860-SVR4
+	  GUESS=i860-unknown-sysv$UNAME_RELEASE     # Unknown i860-SVR4
 	fi
-	exit ;;
+	;;
     mini*:CTIX:SYS*5:*)
 	# "miniframe"
-	echo m68010-convergent-sysv
-	exit ;;
+	GUESS=m68010-convergent-sysv
+	;;
     mc68k:UNIX:SYSTEM5:3.51m)
-	echo m68k-convergent-sysv
-	exit ;;
+	GUESS=m68k-convergent-sysv
+	;;
     M680?0:D-NIX:5.3:*)
-	echo m68k-diab-dnix
-	exit ;;
+	GUESS=m68k-diab-dnix
+	;;
     M68*:*:R3V[5678]*:*)
 	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
     3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
-	&& OS_REL=.$(sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid)
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	  && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
@@ -1244,7 +1282,7 @@ EOF
     NCR*:*:4.2:* | MPRAS*:*:4.2:*)
 	OS_REL='.3'
 	test -r /etc/.relid \
-	    && OS_REL=.$(sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid)
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	    && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
@@ -1252,118 +1290,118 @@ EOF
 	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
 	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-unknown-lynxos$UNAME_RELEASE
+	;;
     mc68030:UNIX_System_V:4.*:*)
-	echo m68k-atari-sysv4
-	exit ;;
+	GUESS=m68k-atari-sysv4
+	;;
     TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sparc-unknown-lynxos$UNAME_RELEASE
+	;;
     rs6000:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=rs6000-unknown-lynxos$UNAME_RELEASE
+	;;
     PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
-	echo powerpc-unknown-lynxos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=powerpc-unknown-lynxos$UNAME_RELEASE
+	;;
     SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv"$UNAME_RELEASE"
-	exit ;;
+	GUESS=mips-dde-sysv$UNAME_RELEASE
+	;;
     RM*:ReliantUNIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
+	GUESS=mips-sni-sysv4
+	;;
     RM*:SINIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
+	GUESS=mips-sni-sysv4
+	;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
-		UNAME_MACHINE=$( (uname -p) 2>/dev/null)
-		echo "$UNAME_MACHINE"-sni-sysv4
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		GUESS=$UNAME_MACHINE-sni-sysv4
 	else
-		echo ns32k-sni-sysv
+		GUESS=ns32k-sni-sysv
 	fi
-	exit ;;
+	;;
     PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
 			# says <Richard.M.Bartel@ccMail.Census.GOV>
-	echo i586-unisys-sysv4
-	exit ;;
+	GUESS=i586-unisys-sysv4
+	;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
-	echo hppa1.1-stratus-sysv4
-	exit ;;
+	GUESS=hppa1.1-stratus-sysv4
+	;;
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
-	echo i860-stratus-sysv4
-	exit ;;
+	GUESS=i860-stratus-sysv4
+	;;
     i*86:VOS:*:*)
 	# From Paul.Green@stratus.com.
-	echo "$UNAME_MACHINE"-stratus-vos
-	exit ;;
+	GUESS=$UNAME_MACHINE-stratus-vos
+	;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
-	echo hppa1.1-stratus-vos
-	exit ;;
+	GUESS=hppa1.1-stratus-vos
+	;;
     mc68*:A/UX:*:*)
-	echo m68k-apple-aux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-apple-aux$UNAME_RELEASE
+	;;
     news*:NEWS-OS:6*:*)
-	echo mips-sony-newsos6
-	exit ;;
+	GUESS=mips-sony-newsos6
+	;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if test -d /usr/nec; then
-		echo mips-nec-sysv"$UNAME_RELEASE"
+		GUESS=mips-nec-sysv$UNAME_RELEASE
 	else
-		echo mips-unknown-sysv"$UNAME_RELEASE"
+		GUESS=mips-unknown-sysv$UNAME_RELEASE
 	fi
-	exit ;;
+	;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
-	echo powerpc-be-beos
-	exit ;;
+	GUESS=powerpc-be-beos
+	;;
     BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
-	echo powerpc-apple-beos
-	exit ;;
+	GUESS=powerpc-apple-beos
+	;;
     BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
-	echo i586-pc-beos
-	exit ;;
+	GUESS=i586-pc-beos
+	;;
     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
-	echo i586-pc-haiku
-	exit ;;
+	GUESS=i586-pc-haiku
+	;;
     x86_64:Haiku:*:*)
-	echo x86_64-unknown-haiku
-	exit ;;
+	GUESS=x86_64-unknown-haiku
+	;;
     SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx4-nec-superux$UNAME_RELEASE
+	;;
     SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx5-nec-superux$UNAME_RELEASE
+	;;
     SX-6:SUPER-UX:*:*)
-	echo sx6-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx6-nec-superux$UNAME_RELEASE
+	;;
     SX-7:SUPER-UX:*:*)
-	echo sx7-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx7-nec-superux$UNAME_RELEASE
+	;;
     SX-8:SUPER-UX:*:*)
-	echo sx8-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx8-nec-superux$UNAME_RELEASE
+	;;
     SX-8R:SUPER-UX:*:*)
-	echo sx8r-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx8r-nec-superux$UNAME_RELEASE
+	;;
     SX-ACE:SUPER-UX:*:*)
-	echo sxace-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sxace-nec-superux$UNAME_RELEASE
+	;;
     Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody"$UNAME_RELEASE"
-	exit ;;
+	GUESS=powerpc-apple-rhapsody$UNAME_RELEASE
+	;;
     *:Rhapsody:*:*)
-	echo "$UNAME_MACHINE"-apple-rhapsody"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-apple-rhapsody$UNAME_RELEASE
+	;;
     arm64:Darwin:*:*)
-	echo aarch64-apple-darwin"$UNAME_RELEASE"
-	exit ;;
+	GUESS=aarch64-apple-darwin$UNAME_RELEASE
+	;;
     *:Darwin:*:*)
-	UNAME_PROCESSOR=$(uname -p)
+	UNAME_PROCESSOR=`uname -p`
 	case $UNAME_PROCESSOR in
 	    unknown) UNAME_PROCESSOR=powerpc ;;
 	esac
@@ -1397,109 +1435,119 @@ EOF
 	    # uname -m returns i386 or x86_64
 	    UNAME_PROCESSOR=$UNAME_MACHINE
 	fi
-	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_PROCESSOR-apple-darwin$UNAME_RELEASE
+	;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
-	UNAME_PROCESSOR=$(uname -p)
+	UNAME_PROCESSOR=`uname -p`
 	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
-	echo "$UNAME_PROCESSOR"-"$UNAME_MACHINE"-nto-qnx"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_PROCESSOR-$UNAME_MACHINE-nto-qnx$UNAME_RELEASE
+	;;
     *:QNX:*:4*)
-	echo i386-pc-qnx
-	exit ;;
+	GUESS=i386-pc-qnx
+	;;
     NEO-*:NONSTOP_KERNEL:*:*)
-	echo neo-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
+	GUESS=neo-tandem-nsk$UNAME_RELEASE
+	;;
     NSE-*:NONSTOP_KERNEL:*:*)
-	echo nse-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
+	GUESS=nse-tandem-nsk$UNAME_RELEASE
+	;;
     NSR-*:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
+	GUESS=nsr-tandem-nsk$UNAME_RELEASE
+	;;
     NSV-*:NONSTOP_KERNEL:*:*)
-	echo nsv-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
+	GUESS=nsv-tandem-nsk$UNAME_RELEASE
+	;;
     NSX-*:NONSTOP_KERNEL:*:*)
-	echo nsx-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
+	GUESS=nsx-tandem-nsk$UNAME_RELEASE
+	;;
     *:NonStop-UX:*:*)
-	echo mips-compaq-nonstopux
-	exit ;;
+	GUESS=mips-compaq-nonstopux
+	;;
     BS2000:POSIX*:*:*)
-	echo bs2000-siemens-sysv
-	exit ;;
+	GUESS=bs2000-siemens-sysv
+	;;
     DS/*:UNIX_System_V:*:*)
-	echo "$UNAME_MACHINE"-"$UNAME_SYSTEM"-"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-$UNAME_SYSTEM-$UNAME_RELEASE
+	;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	# shellcheck disable=SC2154
-	if test "$cputype" = 386; then
+	if test "${cputype-}" = 386; then
 	    UNAME_MACHINE=i386
-	else
-	    UNAME_MACHINE="$cputype"
+	elif test "x${cputype-}" != x; then
+	    UNAME_MACHINE=$cputype
 	fi
-	echo "$UNAME_MACHINE"-unknown-plan9
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-plan9
+	;;
     *:TOPS-10:*:*)
-	echo pdp10-unknown-tops10
-	exit ;;
+	GUESS=pdp10-unknown-tops10
+	;;
     *:TENEX:*:*)
-	echo pdp10-unknown-tenex
-	exit ;;
+	GUESS=pdp10-unknown-tenex
+	;;
     KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
-	echo pdp10-dec-tops20
-	exit ;;
+	GUESS=pdp10-dec-tops20
+	;;
     XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
-	echo pdp10-xkl-tops20
-	exit ;;
+	GUESS=pdp10-xkl-tops20
+	;;
     *:TOPS-20:*:*)
-	echo pdp10-unknown-tops20
-	exit ;;
+	GUESS=pdp10-unknown-tops20
+	;;
     *:ITS:*:*)
-	echo pdp10-unknown-its
-	exit ;;
+	GUESS=pdp10-unknown-its
+	;;
     SEI:*:*:SEIUX)
-	echo mips-sei-seiux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=mips-sei-seiux$UNAME_RELEASE
+	;;
     *:DragonFly:*:*)
-	echo "$UNAME_MACHINE"-unknown-dragonfly"$(echo "$UNAME_RELEASE"|sed -e 's/[-(].*//')"
-	exit ;;
+	DRAGONFLY_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_MACHINE-unknown-dragonfly$DRAGONFLY_REL
+	;;
     *:*VMS:*:*)
-	UNAME_MACHINE=$( (uname -p) 2>/dev/null)
-	case "$UNAME_MACHINE" in
-	    A*) echo alpha-dec-vms ; exit ;;
-	    I*) echo ia64-dec-vms ; exit ;;
-	    V*) echo vax-dec-vms ; exit ;;
+	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case $UNAME_MACHINE in
+	    A*) GUESS=alpha-dec-vms ;;
+	    I*) GUESS=ia64-dec-vms ;;
+	    V*) GUESS=vax-dec-vms ;;
 	esac ;;
     *:XENIX:*:SysV)
-	echo i386-pc-xenix
-	exit ;;
+	GUESS=i386-pc-xenix
+	;;
     i*86:skyos:*:*)
-	echo "$UNAME_MACHINE"-pc-skyos"$(echo "$UNAME_RELEASE" | sed -e 's/ .*$//')"
-	exit ;;
+	SKYOS_REL=`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`
+	GUESS=$UNAME_MACHINE-pc-skyos$SKYOS_REL
+	;;
     i*86:rdos:*:*)
-	echo "$UNAME_MACHINE"-pc-rdos
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-rdos
+	;;
+    i*86:Fiwix:*:*)
+	GUESS=$UNAME_MACHINE-pc-fiwix
+	;;
     *:AROS:*:*)
-	echo "$UNAME_MACHINE"-unknown-aros
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-aros
+	;;
     x86_64:VMkernel:*:*)
-	echo "$UNAME_MACHINE"-unknown-esx
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-esx
+	;;
     amd64:Isilon\ OneFS:*:*)
-	echo x86_64-unknown-onefs
-	exit ;;
+	GUESS=x86_64-unknown-onefs
+	;;
     *:Unleashed:*:*)
-	echo "$UNAME_MACHINE"-unknown-unleashed"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-unleashed$UNAME_RELEASE
+	;;
 esac
 
+# Do we have a guess based on uname results?
+if test "x$GUESS" != x; then
+    echo "$GUESS"
+    exit
+fi
+
 # No uname command or uname output not recognized.
 set_cc_for_build
 cat > "$dummy.c" <<EOF
@@ -1539,7 +1587,7 @@ main ()
 #define __ARCHITECTURE__ "m68k"
 #endif
   int version;
-  version=$( (hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null);
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
   if (version < 4)
     printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
   else
@@ -1631,7 +1679,7 @@ main ()
 }
 EOF
 
-$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=$($dummy) &&
+$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`"$dummy"` &&
 	{ echo "$SYSTEM_NAME"; exit; }
 
 # Apollos put the system type in the environment.
@@ -1639,7 +1687,7 @@ test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
 
 echo "$0: unable to guess system type" >&2
 
-case "$UNAME_MACHINE:$UNAME_SYSTEM" in
+case $UNAME_MACHINE:$UNAME_SYSTEM in
     mips:Linux | mips64:Linux)
 	# If we got here on MIPS GNU/Linux, output extra information.
 	cat >&2 <<EOF
@@ -1661,9 +1709,11 @@ and
   https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
 EOF
 
-year=$(echo $timestamp | sed 's,-.*,,')
+our_year=`echo $timestamp | sed 's,-.*,,'`
+thisyear=`date +%Y`
 # shellcheck disable=SC2003
-if test "$(expr "$(date +%Y)" - "$year")" -lt 3 ; then
+script_age=`expr "$thisyear" - "$our_year"`
+if test "$script_age" -lt 3 ; then
    cat >&2 <<EOF
 
 If $0 has already been updated, send the following data and any
@@ -1672,20 +1722,20 @@ provide the necessary information to handle your system.
 
 config.guess timestamp = $timestamp
 
-uname -m = $( (uname -m) 2>/dev/null || echo unknown)
-uname -r = $( (uname -r) 2>/dev/null || echo unknown)
-uname -s = $( (uname -s) 2>/dev/null || echo unknown)
-uname -v = $( (uname -v) 2>/dev/null || echo unknown)
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
 
-/usr/bin/uname -p = $( (/usr/bin/uname -p) 2>/dev/null)
-/bin/uname -X     = $( (/bin/uname -X) 2>/dev/null)
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
 
-hostinfo               = $( (hostinfo) 2>/dev/null)
-/bin/universe          = $( (/bin/universe) 2>/dev/null)
-/usr/bin/arch -k       = $( (/usr/bin/arch -k) 2>/dev/null)
-/bin/arch              = $( (/bin/arch) 2>/dev/null)
-/usr/bin/oslevel       = $( (/usr/bin/oslevel) 2>/dev/null)
-/usr/convex/getsysinfo = $( (/usr/convex/getsysinfo) 2>/dev/null)
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
 
 UNAME_MACHINE = "$UNAME_MACHINE"
 UNAME_RELEASE = "$UNAME_RELEASE"
diff --git a/readline/readline/support/config.rpath b/readline/readline/support/config.rpath
old mode 100755
new mode 100644
diff --git a/readline/readline/support/config.sub b/readline/readline/support/config.sub
old mode 100755
new mode 100644
index 7384e9198b4051ce9e3e079d50d8adb5060b1771..9b62e37c43c6d67efb7a7de7ee1f19e0bc9bc311
--- a/readline/readline/support/config.sub
+++ b/readline/readline/support/config.sub
@@ -2,11 +2,13 @@
 # Configuration validation subroutine script.
 #   Copyright 1992-2021 Free Software Foundation, Inc.
 
-timestamp='2021-04-30'
+# shellcheck disable=SC2006,SC2268 # see below for rationale
+
+timestamp='2021-12-25'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License, or
+# the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -50,7 +52,14 @@ timestamp='2021-04-30'
 #	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
 # It is wrong to echo any other type of specification.
 
-me=$(echo "$0" | sed -e 's,.*/,,')
+# The "shellcheck disable" line above the timestamp inhibits complaints
+# about features and limitations of the classic Bourne shell that were
+# superseded or lifted in POSIX.  However, this script identifies a wide
+# variety of pre-POSIX systems that do not have POSIX shells at all, and
+# even some reasonably current systems (Solaris 10 as case-in-point) still
+# have a pre-POSIX /bin/sh.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
 Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS
@@ -112,9 +121,11 @@ esac
 
 # Split fields of configuration type
 # shellcheck disable=SC2162
+saved_IFS=$IFS
 IFS="-" read field1 field2 field3 field4 <<EOF
 $1
 EOF
+IFS=$saved_IFS
 
 # Separate into logical components for further validation
 case $1 in
@@ -163,6 +174,10 @@ case $1 in
 						basic_machine=$field1
 						basic_os=$field2
 						;;
+					zephyr*)
+						basic_machine=$field1-unknown
+						basic_os=$field2
+						;;
 					# Manufacturers
 					dec* | mips* | sequent* | encore* | pc533* | sgi* | sony* \
 					| att* | 7300* | 3300* | delta* | motorola* | sun[234]* \
@@ -769,22 +784,22 @@ case $basic_machine in
 		vendor=hp
 		;;
 	i*86v32)
-		cpu=$(echo "$1" | sed -e 's/86.*/86/')
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
 		vendor=pc
 		basic_os=sysv32
 		;;
 	i*86v4*)
-		cpu=$(echo "$1" | sed -e 's/86.*/86/')
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
 		vendor=pc
 		basic_os=sysv4
 		;;
 	i*86v)
-		cpu=$(echo "$1" | sed -e 's/86.*/86/')
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
 		vendor=pc
 		basic_os=sysv
 		;;
 	i*86sol2)
-		cpu=$(echo "$1" | sed -e 's/86.*/86/')
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
 		vendor=pc
 		basic_os=solaris2
 		;;
@@ -917,14 +932,16 @@ case $basic_machine in
 		;;
 	leon-*|leon[3-9]-*)
 		cpu=sparc
-		vendor=$(echo "$basic_machine" | sed 's/-.*//')
+		vendor=`echo "$basic_machine" | sed 's/-.*//'`
 		;;
 
 	*-*)
 		# shellcheck disable=SC2162
+		saved_IFS=$IFS
 		IFS="-" read cpu vendor <<EOF
 $basic_machine
 EOF
+		IFS=$saved_IFS
 		;;
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
@@ -1003,6 +1020,11 @@ case $cpu-$vendor in
 		;;
 
 	# Here we normalize CPU types with a missing or matching vendor
+	armh-unknown | armh-alt)
+		cpu=armv7l
+		vendor=alt
+		basic_os=${basic_os:-linux-gnueabihf}
+		;;
 	dpx20-unknown | dpx20-bull)
 		cpu=rs6000
 		vendor=bull
@@ -1084,7 +1106,7 @@ case $cpu-$vendor in
 		cpu=mipsisa64sb1el
 		;;
 	sh5e[lb]-*)
-		cpu=$(echo "$cpu" | sed 's/^\(sh.\)e\(.\)$/\1\2e/')
+		cpu=`echo "$cpu" | sed 's/^\(sh.\)e\(.\)$/\1\2e/'`
 		;;
 	spur-*)
 		cpu=spur
@@ -1102,9 +1124,9 @@ case $cpu-$vendor in
 		cpu=x86_64
 		;;
 	xscale-* | xscalee[bl]-*)
-		cpu=$(echo "$cpu" | sed 's/^xscale/arm/')
+		cpu=`echo "$cpu" | sed 's/^xscale/arm/'`
 		;;
-	arm64-*)
+	arm64-* | aarch64le-*)
 		cpu=aarch64
 		;;
 
@@ -1165,7 +1187,7 @@ case $cpu-$vendor in
 			| alphapca5[67] | alpha64pca5[67] \
 			| am33_2.0 \
 			| amdgcn \
-			| arc | arceb | arc64 \
+			| arc | arceb | arc32 | arc64 \
 			| arm | arm[lb]e | arme[lb] | armv* \
 			| avr | avr32 \
 			| asmjs \
@@ -1287,35 +1309,37 @@ esac
 if test x$basic_os != x
 then
 
-# First recognize some ad-hoc caes, or perhaps split kernel-os, or else just
+# First recognize some ad-hoc cases, or perhaps split kernel-os, or else just
 # set os.
 case $basic_os in
 	gnu/linux*)
 		kernel=linux
-		os=$(echo $basic_os | sed -e 's|gnu/linux|gnu|')
+		os=`echo "$basic_os" | sed -e 's|gnu/linux|gnu|'`
 		;;
 	os2-emx)
 		kernel=os2
-		os=$(echo $basic_os | sed -e 's|os2-emx|emx|')
+		os=`echo "$basic_os" | sed -e 's|os2-emx|emx|'`
 		;;
 	nto-qnx*)
 		kernel=nto
-		os=$(echo $basic_os | sed -e 's|nto-qnx|qnx|')
+		os=`echo "$basic_os" | sed -e 's|nto-qnx|qnx|'`
 		;;
 	*-*)
 		# shellcheck disable=SC2162
+		saved_IFS=$IFS
 		IFS="-" read kernel os <<EOF
 $basic_os
 EOF
+		IFS=$saved_IFS
 		;;
 	# Default OS when just kernel was specified
 	nto*)
 		kernel=nto
-		os=$(echo $basic_os | sed -e 's|nto|qnx|')
+		os=`echo "$basic_os" | sed -e 's|nto|qnx|'`
 		;;
 	linux*)
 		kernel=linux
-		os=$(echo $basic_os | sed -e 's|linux|gnu|')
+		os=`echo "$basic_os" | sed -e 's|linux|gnu|'`
 		;;
 	*)
 		kernel=
@@ -1336,7 +1360,7 @@ case $os in
 		os=cnk
 		;;
 	solaris1 | solaris1.*)
-		os=$(echo $os | sed -e 's|solaris1|sunos4|')
+		os=`echo "$os" | sed -e 's|solaris1|sunos4|'`
 		;;
 	solaris)
 		os=solaris2
@@ -1365,7 +1389,7 @@ case $os in
 		os=sco3.2v4
 		;;
 	sco3.2.[4-9]*)
-		os=$(echo $os | sed -e 's/sco3.2./sco3.2v/')
+		os=`echo "$os" | sed -e 's/sco3.2./sco3.2v/'`
 		;;
 	sco*v* | scout)
 		# Don't match below
@@ -1395,7 +1419,7 @@ case $os in
 		os=lynxos
 		;;
 	mac[0-9]*)
-		os=$(echo "$os" | sed -e 's|mac|macos|')
+		os=`echo "$os" | sed -e 's|mac|macos|'`
 		;;
 	opened*)
 		os=openedition
@@ -1404,10 +1428,10 @@ case $os in
 		os=os400
 		;;
 	sunos5*)
-		os=$(echo "$os" | sed -e 's|sunos5|solaris2|')
+		os=`echo "$os" | sed -e 's|sunos5|solaris2|'`
 		;;
 	sunos6*)
-		os=$(echo "$os" | sed -e 's|sunos6|solaris3|')
+		os=`echo "$os" | sed -e 's|sunos6|solaris3|'`
 		;;
 	wince*)
 		os=wince
@@ -1441,7 +1465,7 @@ case $os in
 		;;
 	# Preserve the version number of sinix5.
 	sinix5.*)
-		os=$(echo $os | sed -e 's|sinix|sysv|')
+		os=`echo "$os" | sed -e 's|sinix|sysv|'`
 		;;
 	sinix*)
 		os=sysv4
@@ -1688,7 +1712,7 @@ fi
 # Now, validate our (potentially fixed-up) OS.
 case $os in
 	# Sometimes we do "kernel-libc", so those need to count as OSes.
-	musl* | newlib* | uclibc*)
+	musl* | newlib* | relibc* | uclibc*)
 		;;
 	# Likewise for "kernel-abi"
 	eabi* | gnueabi*)
@@ -1729,7 +1753,8 @@ case $os in
 	     | skyos* | haiku* | rdos* | toppers* | drops* | es* \
 	     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \
 	     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \
-	     | nsk* | powerunix* | genode* | zvmoe* | qnx* | emx*)
+	     | nsk* | powerunix* | genode* | zvmoe* | qnx* | emx* | zephyr* \
+	     | fiwix* )
 		;;
 	# This one is extra strict with allowed versions
 	sco3.2v2 | sco3.2v[4-9]* | sco5v6*)
@@ -1746,11 +1771,12 @@ esac
 # As a final step for OS-related things, validate the OS-kernel combination
 # (given a valid OS), if there is a kernel.
 case $kernel-$os in
-	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* | linux-musl* | linux-uclibc* )
+	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* \
+		   | linux-musl* | linux-relibc* | linux-uclibc* )
 		;;
 	uclinux-uclibc* )
 		;;
-	-dietlibc* | -newlib* | -musl* | -uclibc* )
+	-dietlibc* | -newlib* | -musl* | -relibc* | -uclibc* )
 		# These are just libc implementations, not actual OSes, and thus
 		# require a kernel.
 		echo "Invalid configuration \`$1': libc \`$os' needs explicit kernel." 1>&2
diff --git a/readline/readline/support/install.sh b/readline/readline/support/install.sh
old mode 100755
new mode 100644
diff --git a/readline/readline/support/mkdirs b/readline/readline/support/mkdirs
old mode 100755
new mode 100644
diff --git a/readline/readline/support/mkdist b/readline/readline/support/mkdist
old mode 100755
new mode 100644
index 282431d4ad319017c5ed9ecb694313b90868fcce..463bdc163fc66a36fe2214e30e81fcff2fa522f5
--- a/readline/readline/support/mkdist
+++ b/readline/readline/support/mkdist
@@ -78,7 +78,7 @@ fi
 dirmode=755
 filmode=644
 
-while read fname type mode
+while read fname type mode rest
 do
 	[ -z "$fname" ] && continue
 
@@ -89,13 +89,24 @@ do
 	case "$type" in
 	d)	mkdir $newdir/$fname ;;
 	f)	cp -p $SRCDIR/$fname $newdir/$fname ;;
+	F)	cp $SRCDIR/$fname $newdir/$fname ;;
 	s)	ln -s $mode $newdir/$fname ; mode= ;;		# symlink
 	l)	ln $mode $newdir/$fname ; mode= ;;		# hard link
+	c)	cp $SRCDIR/$mode $newdir/$fname ; mode=$filmode ;;	# copy to new name
 	*)	echo "unknown file type $type" 1>&2 ;;
 	esac
 
+	# allow trailing comments
+	case "$mode" in
+	\#*)	mode= ;;
+	esac
+
 	if [ -n "$mode" ]; then
 		chmod $mode $newdir/$fname
+	elif [ "$type" = "f" ]; then
+		chmod $filmode $newdir/$fname
+	elif [ "$type" = "d" ]; then
+		chmod $dirmode $newdir/$fname
 	fi
 
 done < $MANIFEST
diff --git a/readline/readline/support/mkinstalldirs b/readline/readline/support/mkinstalldirs
old mode 100755
new mode 100644
diff --git a/readline/readline/support/shlib-install b/readline/readline/support/shlib-install
old mode 100755
new mode 100644
diff --git a/readline/readline/support/shobj-conf b/readline/readline/support/shobj-conf
index 5a3f9776e910ba0bc8e521effca06989bd984903..cd7634dfa6247f021a640e2df74f7ed843ff66ad 100755
--- a/readline/readline/support/shobj-conf
+++ b/readline/readline/support/shobj-conf
@@ -10,7 +10,7 @@
 # Chet Ramey
 # chet@po.cwru.edu
 
-#   Copyright (C) 1996-2019 Free Software Foundation, Inc.
+#   Copyright (C) 1996-2021 Free Software Foundation, Inc.
 #
 #   This file is part of GNU Bash, the Bourne Again SHell.
 #
@@ -123,7 +123,7 @@ sunos5*|solaris2*)
 	;;
 
 # All versions of Linux (including Gentoo/FreeBSD) or the semi-mythical GNU Hurd.
-linux*-*|gnu*-*|k*bsd*-gnu-*|freebsd*|dragonfly*)
+linux*-*|gnu*-*|k*bsd*-gnu-*|midnightbsd*|freebsd*|dragonfly*)
 	SHOBJ_CFLAGS=-fPIC
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
@@ -151,13 +151,13 @@ darwin*)
 	darwin[1-7].*)
 		SHOBJ_STATUS=unsupported
 		SHOBJ_LDFLAGS='-dynamic'
-		SHLIB_XLDFLAGS='-arch_only `/usr/bin/arch` -install_name $(libdir)/`echo $@ | sed "s:\\..*::"`.$(SHLIB_MAJOR).$(SHLIB_LIBSUFF) -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -v'
+		SHLIB_XLDFLAGS='-install_name $(libdir)/`echo $@ | sed "s:\\..*::"`.$(SHLIB_MAJOR).$(SHLIB_LIBSUFF) -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -v'
 		;;
 	# Darwin 8 == Mac OS X 10.4; Mac OS X 10.N == Darwin N+4
 	*)
 		case "${host_os}" in
 		darwin[89]*|darwin1[012]*)
-			SHOBJ_ARCHFLAGS='-arch_only `/usr/bin/arch`'
+			SHOBJ_ARCHFLAGS=
 			;;
 		 *) 	# Mac OS X 10.9 (Mavericks) and later
 			SHOBJ_ARCHFLAGS=
@@ -241,8 +241,8 @@ osf*)
 
 aix4.[2-9]*-*gcc*|aix[5-9].*-*gcc*)		# lightly tested by jik@cisco.com
 	SHOBJ_CFLAGS=-fpic
-	SHOBJ_LD='ld'
-	SHOBJ_LDFLAGS='-bdynamic -bnoentry -bexpall'
+	SHOBJ_LD='${CC}'
+	SHOBJ_LDFLAGS='-Wl,-bdynamic -Wl,-bnoentry -Wl,-bexpall'
 	SHOBJ_XLDFLAGS='-G'
 
 	SHLIB_XLDFLAGS='-bM:SRE'
diff --git a/readline/readline/terminal.c b/readline/readline/terminal.c
index 05415dc42de1dca338d4047b168bc8b5aedd12ae..9997161f818e934875d12fec50e7f1caccfd5ec0 100644
--- a/readline/readline/terminal.c
+++ b/readline/readline/terminal.c
@@ -1,6 +1,6 @@
 /* terminal.c -- controlling the terminal with termcap. */
 
-/* Copyright (C) 1996-2017 Free Software Foundation, Inc.
+/* Copyright (C) 1996-2022 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -73,11 +73,11 @@
 #  include <windows.h>
 #  include <wincon.h>
 
-static void _win_get_screensize PARAMS((int *, int *));
+static void _win_get_screensize (int *, int *);
 #endif
 
 #if defined (__EMX__)
-static void _emx_get_screensize PARAMS((int *, int *));
+static void _emx_get_screensize (int *, int *);
 #endif
 
 /* If the calling application sets this to a non-zero value, readline will
@@ -177,10 +177,19 @@ static char *_rl_term_kD;
 /* Insert key */
 static char *_rl_term_kI;
 
+/* Page up and page down keys */
+static char *_rl_term_kP;
+static char *_rl_term_kN;
+
 /* Cursor control */
 static char *_rl_term_vs;	/* very visible */
 static char *_rl_term_ve;	/* normal */
 
+/* User-settable color sequences to begin and end the active region. Defaults
+   are rl_term_so and rl_term_se on non-dumb terminals. */
+char *_rl_active_region_start_color = NULL;
+char *_rl_active_region_end_color = NULL;
+
 /* It's not clear how HPUX is so broken here. */
 #ifdef TGETENT_BROKEN
 #  define TGETENT_SUCCESS 0
@@ -194,7 +203,7 @@ static char *_rl_term_ve;	/* normal */
 #endif
 #define TGETFLAG(cap)	(tgetflag (cap) == TGETFLAG_SUCCESS)
 
-static void bind_termcap_arrow_keys PARAMS((Keymap));
+static void bind_termcap_arrow_keys (Keymap);
 
 /* Variables that hold the screen dimensions, used by the display code. */
 int _rl_screenwidth, _rl_screenheight, _rl_screenchars;
@@ -382,8 +391,12 @@ _rl_sigwinch_resize_terminal (void)
 void
 rl_resize_terminal (void)
 {
+  int width, height;
+
+  width = _rl_screenwidth;
+  height = _rl_screenheight;
   _rl_get_screen_size (fileno (rl_instream), 1);
-  if (_rl_echoing_p)
+  if (_rl_echoing_p && (width != _rl_screenwidth || height != _rl_screenheight))
     {
       if (CUSTOM_REDISPLAY_FUNC ())
 	rl_forced_update_display ();
@@ -415,6 +428,8 @@ static const struct _tc_string tc_strings[] =
   { "kD", &_rl_term_kD },	/* delete */
   { "kH", &_rl_term_kH },	/* home down ?? */
   { "kI", &_rl_term_kI },	/* insert */
+  { "kN", &_rl_term_kN },	/* page down */
+  { "kP", &_rl_term_kP },	/* page up */
   { "kd", &_rl_term_kd },
   { "ke", &_rl_term_ke },	/* end keypad mode */
   { "kh", &_rl_term_kh },	/* home */
@@ -456,7 +471,7 @@ _rl_init_terminal_io (const char *terminal_name)
 {
   const char *term;
   char *buffer;
-  int tty, tgetent_ret, dumbterm;
+  int tty, tgetent_ret, dumbterm, reset_region_colors;
 
   term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
   _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = _rl_term_clrscroll = (char *)NULL;
@@ -467,6 +482,8 @@ _rl_init_terminal_io (const char *terminal_name)
 
   dumbterm = STREQ (term, "dumb");
 
+  reset_region_colors = 1;
+
 #ifdef __MSDOS__
   _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
   _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
@@ -478,6 +495,7 @@ _rl_init_terminal_io (const char *terminal_name)
   _rl_term_goto = _rl_term_pc = _rl_term_ip = (char *)NULL;
   _rl_term_ks = _rl_term_ke =_rl_term_vs = _rl_term_ve = (char *)NULL;
   _rl_term_kh = _rl_term_kH = _rl_term_at7 = _rl_term_kI = (char *)NULL;
+  _rl_term_kN = _rl_term_kP = (char *)NULL;
   _rl_term_so = _rl_term_se = (char *)NULL;
 #if defined(HACK_TERMCAP_MOTION)
   _rl_term_forward_char = (char *)NULL;
@@ -540,6 +558,7 @@ _rl_init_terminal_io (const char *terminal_name)
       _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
       _rl_term_kh = _rl_term_kH = _rl_term_kI = _rl_term_kD = (char *)NULL;
       _rl_term_ks = _rl_term_ke = _rl_term_at7 = (char *)NULL;
+      _rl_term_kN = _rl_term_kP = (char *)NULL;
       _rl_term_mm = _rl_term_mo = (char *)NULL;
       _rl_term_ve = _rl_term_vs = (char *)NULL;
       _rl_term_forward_char = (char *)NULL;
@@ -550,6 +569,11 @@ _rl_init_terminal_io (const char *terminal_name)
 	 escape sequences */
       _rl_enable_bracketed_paste = 0;
 
+      /* No terminal so/se capabilities. */
+      _rl_enable_active_region = 0;
+      _rl_reset_region_color (0, NULL);
+      _rl_reset_region_color (1, NULL);
+    
       /* Reasonable defaults for tgoto().  Readline currently only uses
          tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
          change that later... */
@@ -604,8 +628,14 @@ _rl_init_terminal_io (const char *terminal_name)
   /* There's no way to determine whether or not a given terminal supports
      bracketed paste mode, so we assume a terminal named "dumb" does not. */
   if (dumbterm)
-    _rl_enable_bracketed_paste = 0;
-    
+    _rl_enable_bracketed_paste = _rl_enable_active_region = 0;
+
+  if (reset_region_colors)
+    {
+      _rl_reset_region_color (0, _rl_term_so);
+      _rl_reset_region_color (1, _rl_term_se);
+    }
+
   return 0;
 }
 
@@ -629,6 +659,9 @@ bind_termcap_arrow_keys (Keymap map)
   rl_bind_keyseq_if_unbound (_rl_term_kD, rl_delete);
   rl_bind_keyseq_if_unbound (_rl_term_kI, rl_overwrite_mode);	/* Insert */
 
+  rl_bind_keyseq_if_unbound (_rl_term_kN, rl_history_search_forward);	/* Page Down */
+  rl_bind_keyseq_if_unbound (_rl_term_kP, rl_history_search_backward);	/* Page Up */
+
   _rl_keymap = xkeymap;
 }
 
@@ -774,6 +807,67 @@ _rl_standout_off (void)
 #endif
 }
 
+/* **************************************************************** */
+/*								    */
+/*	     Controlling color for a portion of the line	    */
+/*								    */
+/* **************************************************************** */
+
+/* Reset the region color variables to VALUE depending on WHICH (0 == start,
+   1 == end). This is where all the memory allocation for the color variable
+   strings is performed. We might want to pass a flag saying whether or not
+   to translate VALUE like a key sequence, but it doesn't really matter. */
+int
+_rl_reset_region_color (int which, const char *value)
+{
+  int len;
+
+  if (which == 0)
+    {
+      xfree (_rl_active_region_start_color);
+      if (value && *value)
+	{
+	  _rl_active_region_start_color = (char *)xmalloc (2 * strlen (value) + 1);
+	  rl_translate_keyseq (value, _rl_active_region_start_color, &len);
+	  _rl_active_region_start_color[len] = '\0';
+	}
+      else
+	_rl_active_region_start_color = NULL;
+    }
+  else
+    {
+      xfree (_rl_active_region_end_color);
+      if (value && *value)
+	{
+	  _rl_active_region_end_color = (char *)xmalloc (2 * strlen (value) + 1);
+	  rl_translate_keyseq (value, _rl_active_region_end_color, &len);
+	  _rl_active_region_end_color[len] = '\0';
+	}
+      else
+	_rl_active_region_end_color = NULL;
+    }
+
+  return 0;
+}
+
+void
+_rl_region_color_on (void)
+{
+#ifndef __MSDOS__
+  if (_rl_active_region_start_color && _rl_active_region_end_color)
+    tputs (_rl_active_region_start_color, 1, _rl_output_character_function);
+#endif
+}
+
+void
+_rl_region_color_off (void)
+{
+#ifndef __MSDOS__
+  if (_rl_active_region_start_color && _rl_active_region_end_color)
+    tputs (_rl_active_region_end_color, 1, _rl_output_character_function);
+#endif
+}
+
 /* **************************************************************** */
 /*								    */
 /*	 	Controlling the Meta Key and Keypad		    */
diff --git a/readline/readline/text.c b/readline/readline/text.c
index 2567dea268ae2412dda65d9c9fbd898e1ac11e86..a01143fc7bf95f62da937455b84981e0e671b0f5 100644
--- a/readline/readline/text.c
+++ b/readline/readline/text.c
@@ -1,6 +1,6 @@
 /* text.c -- text handling commands for readline. */
 
-/* Copyright (C) 1987-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -59,12 +59,12 @@
 #include "xmalloc.h"
 
 /* Forward declarations. */
-static int rl_change_case PARAMS((int, int));
-static int _rl_char_search PARAMS((int, int, int));
+static int rl_change_case (int, int);
+static int _rl_char_search (int, int, int);
 
 #if defined (READLINE_CALLBACKS)
-static int _rl_insert_next_callback PARAMS((_rl_callback_generic_arg *));
-static int _rl_char_search_callback PARAMS((_rl_callback_generic_arg *));
+static int _rl_insert_next_callback (_rl_callback_generic_arg *);
+static int _rl_char_search_callback (_rl_callback_generic_arg *);
 #endif
 
 /* The largest chunk of text that can be inserted in one call to
@@ -85,7 +85,8 @@ int _rl_optimize_typeahead = 1;	/* rl_insert tries to read typeahead */
 int
 rl_insert_text (const char *string)
 {
-  register int i, l;
+  register int i;
+  size_t l;
 
   l = (string && *string) ? strlen (string) : 0;
   if (l == 0)
@@ -96,6 +97,7 @@ rl_insert_text (const char *string)
 
   for (i = rl_end; i >= rl_point; i--)
     rl_line_buffer[i + l] = rl_line_buffer[i];
+
   strncpy (rl_line_buffer + rl_point, string, l);
 
   /* Remember how to undo this if we aren't undoing something. */
@@ -703,7 +705,11 @@ static mbstate_t ps = {0};
 
 /* Insert the character C at the current location, moving point forward.
    If C introduces a multibyte sequence, we read the whole sequence and
-   then insert the multibyte char into the line buffer. */
+   then insert the multibyte char into the line buffer.
+   If C == 0, we immediately insert any pending partial multibyte character,
+   assuming that we have read a character that doesn't map to self-insert.
+   This doesn't completely handle characters that are part of a multibyte
+   character but map to editing functions. */
 int
 _rl_insert_char (int count, int c)
 {
@@ -717,11 +723,28 @@ _rl_insert_char (int count, int c)
   static int stored_count = 0;
 #endif
 
+#if !defined (HANDLE_MULTIBYTE)
   if (count <= 0)
     return 0;
+#else
+  if (count < 0)
+    return 0;
+  if (count == 0)
+    {
+      if (pending_bytes_length == 0)
+	return 0;
+      if (stored_count <= 0)
+	stored_count = count;
+      else
+	count = stored_count;
 
-#if defined (HANDLE_MULTIBYTE)
-  if (MB_CUR_MAX == 1 || rl_byte_oriented)
+      memcpy (incoming, pending_bytes, pending_bytes_length);
+      incoming[pending_bytes_length] = '\0';
+      incoming_length = pending_bytes_length;
+      pending_bytes_length = 0;
+      memset (&ps, 0, sizeof (mbstate_t));
+    }
+  else if (MB_CUR_MAX == 1 || rl_byte_oriented)
     {
       incoming[0] = c;
       incoming[1] = '\0';
@@ -729,13 +752,16 @@ _rl_insert_char (int count, int c)
     }
   else if (_rl_utf8locale && (c & 0x80) == 0)
     {
+      if (pending_bytes_length)
+	_rl_insert_char (0, 0);
+
       incoming[0] = c;
       incoming[1] = '\0';
       incoming_length = 1;
     }
   else
     {
-      wchar_t wc;
+      WCHAR_T wc;
       size_t ret;
 
       if (stored_count <= 0)
@@ -745,7 +771,7 @@ _rl_insert_char (int count, int c)
 
       ps_back = ps;
       pending_bytes[pending_bytes_length++] = c;
-      ret = mbrtowc (&wc, pending_bytes, pending_bytes_length, &ps);
+      ret = MBRTOWC (&wc, pending_bytes, pending_bytes_length, &ps);
 
       if (ret == (size_t)-2)
 	{
@@ -763,7 +789,8 @@ _rl_insert_char (int count, int c)
 	  incoming[1] = '\0';
 	  incoming_length = 1;
 	  pending_bytes_length--;
-	  memmove (pending_bytes, pending_bytes + 1, pending_bytes_length);
+	  if (pending_bytes_length)
+	    memmove (pending_bytes, pending_bytes + 1, pending_bytes_length);
 	  /* Clear the state of the byte sequence, because in this case the
 	     effect of mbstate is undefined. */
 	  memset (&ps, 0, sizeof (mbstate_t));
@@ -826,7 +853,11 @@ _rl_insert_char (int count, int c)
       rl_insert_text (string);
       xfree (string);
 
+#if defined (HANDLE_MULTIBYTE)
+      return (pending_bytes_length != 0);
+#else
       return 0;
+#endif
     }
 
   if (count > TEXT_COUNT_MAX)
@@ -859,6 +890,8 @@ _rl_insert_char (int count, int c)
       xfree (string);
       incoming_length = 0;
       stored_count = 0;
+
+      return (pending_bytes_length != 0);
 #else /* !HANDLE_MULTIBYTE */
       char str[TEXT_COUNT_MAX+1];
 
@@ -872,9 +905,9 @@ _rl_insert_char (int count, int c)
 	  rl_insert_text (str);
 	  count -= decreaser;
 	}
-#endif /* !HANDLE_MULTIBYTE */
 
       return 0;
+#endif /* !HANDLE_MULTIBYTE */
     }
 
   if (MB_CUR_MAX == 1 || rl_byte_oriented)
@@ -902,9 +935,11 @@ _rl_insert_char (int count, int c)
       rl_insert_text (incoming);
       stored_count = 0;
     }
-#endif
-
+  
+  return (pending_bytes_length != 0);
+#else
   return 0;
+#endif
 }
 
 /* Overwrite the character at point (or next COUNT characters) with C.
@@ -919,8 +954,11 @@ _rl_overwrite_char (int count, int c)
   int k;
 
   /* Read an entire multibyte character sequence to insert COUNT times. */
+  k = 1;
   if (count > 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)
     k = _rl_read_mbstring (c, mbkey, MB_LEN_MAX);
+  if (k < 0)
+    return 1;
 #endif
 
   rl_begin_undo_group ();
@@ -979,6 +1017,11 @@ rl_insert (int count, int c)
 	break;
     }
 
+  /* If we didn't insert n and there are pending bytes, we need to insert
+     them if _rl_insert_char didn't do that on its own. */
+  if (r == 1 && rl_insert_mode == RL_IM_INSERT)
+    r = _rl_insert_char (0, 0);		/* flush partial multibyte char */
+
   if (n != (unsigned short)-2)		/* -2 = sentinel value for having inserted N */
     {
       /* setting rl_pending_input inhibits setting rl_last_func so we do it
@@ -1050,6 +1093,8 @@ _rl_insert_next_callback (_rl_callback_generic_arg *data)
 int
 rl_quoted_insert (int count, int key)
 {
+  int r;
+
   /* Let's see...should the callback interface futz with signal handling? */
 #if defined (HANDLE_SIGNALS)
   if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
@@ -1068,15 +1113,17 @@ rl_quoted_insert (int count, int key)
   /* A negative count means to quote the next -COUNT characters. */
   if (count < 0)
     {
-      int r;
-
       do
 	r = _rl_insert_next (1);
       while (r == 0 && ++count < 0);
-      return r;
     }
+  else
+    r = _rl_insert_next (count);
 
-  return _rl_insert_next (count);
+  if (r == 1)
+    _rl_insert_char (0, 0);	/* insert partial multibyte character */
+
+  return r;
 }
 
 /* Insert a tab character. */
@@ -1132,7 +1179,7 @@ rl_newline (int count, int key)
 int
 rl_do_lowercase_version (int ignore1, int ignore2)
 {
-  return 0;
+  return 99999;		/* prevent from being combined with _rl_null_function */
 }
 
 /* This is different from what vi does, so the code's not shared.  Emacs
@@ -1401,9 +1448,9 @@ rl_change_case (int count, int op)
 {
   int start, next, end;
   int inword, nc, nop;
-  wchar_t c;
+  WCHAR_T c;
 #if defined (HANDLE_MULTIBYTE)
-  wchar_t wc, nwc;
+  WCHAR_T wc, nwc;
   char mb[MB_LEN_MAX+1];
   int mlen;
   size_t m;
@@ -1462,9 +1509,9 @@ rl_change_case (int count, int op)
 #if defined (HANDLE_MULTIBYTE)
       else
 	{
-	  m = mbrtowc (&wc, rl_line_buffer + start, end - start, &mps);
+	  m = MBRTOWC (&wc, rl_line_buffer + start, end - start, &mps);
 	  if (MB_INVALIDCH (m))
-	    wc = (wchar_t)rl_line_buffer[start];
+	    wc = (WCHAR_T)rl_line_buffer[start];
 	  else if (MB_NULLWCH (m))
 	    wc = L'\0';
 	  nwc = (nop == UpCase) ? _rl_to_wupper (wc) : _rl_to_wlower (wc);
@@ -1474,12 +1521,12 @@ rl_change_case (int count, int op)
 	      mbstate_t ts;
 
 	      memset (&ts, 0, sizeof (mbstate_t));
-	      mlen = wcrtomb (mb, nwc, &ts);
+	      mlen = WCRTOMB (mb, nwc, &ts);
 	      if (mlen < 0)
 		{
 		  nwc = wc;
 		  memset (&ts, 0, sizeof (mbstate_t));
-		  mlen = wcrtomb (mb, nwc, &ts);
+		  mlen = WCRTOMB (mb, nwc, &ts);
 		  if (mlen < 0)		/* should not happen */
 		    strncpy (mb, rl_line_buffer + start, mlen = m);
 		}
@@ -1536,7 +1583,10 @@ rl_transpose_words (int count, int key)
 {
   char *word1, *word2;
   int w1_beg, w1_end, w2_beg, w2_end;
-  int orig_point = rl_point;
+  int orig_point, orig_end;
+
+  orig_point = rl_point;
+  orig_end = rl_end;
 
   if (!count)
     return 0;
@@ -1580,6 +1630,7 @@ rl_transpose_words (int count, int key)
   /* This is exactly correct since the text before this point has not
      changed in length. */
   rl_point = w2_end;
+  rl_end = orig_end;		/* just make sure */
 
   /* I think that does it. */
   rl_end_undo_group ();
@@ -1756,8 +1807,7 @@ _rl_char_search (int count, int fdir, int bdir)
 
 #if defined (READLINE_CALLBACKS)
 static int
-_rl_char_search_callback (data)
-     _rl_callback_generic_arg *data;
+_rl_char_search_callback (_rl_callback_generic_arg *data)
 {
   _rl_callback_func = 0;
   _rl_want_redisplay = 1;
diff --git a/readline/readline/tilde.h b/readline/readline/tilde.h
index e26dd0476f7b3369ff842c26716640b7a4b99b89..bc8022afc329f3997a7f43548a73f212d09a0952 100644
--- a/readline/readline/tilde.h
+++ b/readline/readline/tilde.h
@@ -1,6 +1,6 @@
 /* tilde.h: Externally available variables and function in libtilde.a. */
 
-/* Copyright (C) 1992-2009 Free Software Foundation, Inc.
+/* Copyright (C) 1992-2009,2021 Free Software Foundation, Inc.
 
    This file contains the Readline Library (Readline), a set of
    routines for providing Emacs style line input to programs that ask
@@ -27,19 +27,7 @@
 extern "C" {
 #endif
 
-/* A function can be defined using prototypes and compile on both ANSI C
-   and traditional C compilers with something like this:
-	extern char *func PARAMS((char *, char *, int)); */
-
-#if !defined (PARAMS)
-#  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
-#    define PARAMS(protos) protos
-#  else
-#    define PARAMS(protos) ()
-#  endif
-#endif
-
-typedef char *tilde_hook_func_t PARAMS((char *));
+typedef char *tilde_hook_func_t (char *);
 
 /* If non-null, this contains the address of a function that the application
    wants called before trying the standard tilde expansions.  The function
@@ -64,14 +52,14 @@ extern char **tilde_additional_prefixes;
 extern char **tilde_additional_suffixes;
 
 /* Return a new string which is the result of tilde expanding STRING. */
-extern char *tilde_expand PARAMS((const char *));
+extern char *tilde_expand (const char *);
 
 /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
    tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
-extern char *tilde_expand_word PARAMS((const char *));
+extern char *tilde_expand_word (const char *);
 
 /* Find the portion of the string beginning with ~ that should be expanded. */
-extern char *tilde_find_word PARAMS((const char *, int, int *));
+extern char *tilde_find_word (const char *, int, int *);
 
 #ifdef __cplusplus
 }
diff --git a/readline/readline/undo.c b/readline/readline/undo.c
index 147999119a6123532e8d932f2ccb1783e4c1a7a7..e4c457dce328a210c0a77e94903421f3f3251b74 100644
--- a/readline/readline/undo.c
+++ b/readline/readline/undo.c
@@ -1,6 +1,6 @@
 /* undo.c - manage list of changes to lines, offering opportunity to undo them */
 
-/* Copyright (C) 1987-2017 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -49,9 +49,7 @@
 #include "rlprivate.h"
 #include "xmalloc.h"
 
-extern void _hs_replace_history_data PARAMS((int, histdata_t *, histdata_t *));
-
-extern HIST_ENTRY *_rl_saved_line_for_history;
+#include "histlib.h"
 
 /* Non-zero tells rl_delete_text and rl_insert_text to not add to
    the undo list. */
diff --git a/readline/readline/util.c b/readline/readline/util.c
index 1576b55d50d53cf2a61b32a879697b9a338f5647..2e986db0a5ed34350ce5155ec66468adfc7e8de2 100644
--- a/readline/readline/util.c
+++ b/readline/readline/util.c
@@ -72,7 +72,7 @@ static const char * const pathname_alphabetic_chars = "/-_=~.#$";
 int
 rl_alphabetic (int c)
 {
-  if (ALPHABETIC (c))
+  if (_rl_alphabetic_p (c))
     return (1);
 
   return (_rl_allow_pathname_alphabetic_chars &&
@@ -81,7 +81,7 @@ rl_alphabetic (int c)
 
 #if defined (HANDLE_MULTIBYTE)
 int
-_rl_walphabetic (wchar_t wc)
+_rl_walphabetic (WCHAR_T wc)
 {
   int c;
 
@@ -98,7 +98,8 @@ _rl_walphabetic (wchar_t wc)
 int
 _rl_abort_internal (void)
 {
-  rl_ding ();
+  if (RL_ISSTATE (RL_STATE_TIMEOUT) == 0)
+    rl_ding ();			/* Don't ring the bell on a timeout */
   rl_clear_message ();
   _rl_reset_argument ();
   rl_clear_pending_input ();
diff --git a/readline/readline/vi_mode.c b/readline/readline/vi_mode.c
index 742341e362836fb72f361465856992e586a0fb6a..3a033bab46f8eb9c3eca32145adc0fe325bdf0be 100644
--- a/readline/readline/vi_mode.c
+++ b/readline/readline/vi_mode.c
@@ -1,7 +1,7 @@
 /* vi_mode.c -- A vi emulation mode for Bash.
    Derived from code written by Jeff Sparkes (jsparkes@bnr.ca).  */
 
-/* Copyright (C) 1987-2020 Free Software Foundation, Inc.
+/* Copyright (C) 1987-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -124,44 +124,44 @@ static const char * const vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
 /* Arrays for the saved marks. */
 static int vi_mark_chars['z' - 'a' + 1];
 
-static void _rl_vi_replace_insert PARAMS((int));
-static void _rl_vi_save_replace PARAMS((void));
-static void _rl_vi_stuff_insert PARAMS((int));
-static void _rl_vi_save_insert PARAMS((UNDO_LIST *));
+static void _rl_vi_replace_insert (int);
+static void _rl_vi_save_replace (void);
+static void _rl_vi_stuff_insert (int);
+static void _rl_vi_save_insert (UNDO_LIST *);
 
-static void vi_save_insert_buffer PARAMS ((int, int));
+static void vi_save_insert_buffer (int, int);
 
-static inline void _rl_vi_backup PARAMS((void));
+static inline void _rl_vi_backup (void);
 
-static int _rl_vi_arg_dispatch PARAMS((int));
-static int rl_digit_loop1 PARAMS((void));
+static int _rl_vi_arg_dispatch (int);
+static int rl_digit_loop1 (void);
 
-static int _rl_vi_set_mark PARAMS((void));
-static int _rl_vi_goto_mark PARAMS((void));
+static int _rl_vi_set_mark (void);
+static int _rl_vi_goto_mark (void);
 
-static inline int _rl_vi_advance_point PARAMS((void));
-static inline int _rl_vi_backup_point PARAMS((void));
+static inline int _rl_vi_advance_point (void);
+static inline int _rl_vi_backup_point (void);
 
-static void _rl_vi_append_forward PARAMS((int));
+static void _rl_vi_append_forward (int);
 
-static int _rl_vi_callback_getchar PARAMS((char *, int));
+static int _rl_vi_callback_getchar (char *, int);
 
 #if defined (READLINE_CALLBACKS)
-static int _rl_vi_callback_set_mark PARAMS((_rl_callback_generic_arg *));
-static int _rl_vi_callback_goto_mark PARAMS((_rl_callback_generic_arg *));
-static int _rl_vi_callback_change_char PARAMS((_rl_callback_generic_arg *));
-static int _rl_vi_callback_char_search PARAMS((_rl_callback_generic_arg *));
+static int _rl_vi_callback_set_mark (_rl_callback_generic_arg *);
+static int _rl_vi_callback_goto_mark (_rl_callback_generic_arg *);
+static int _rl_vi_callback_change_char (_rl_callback_generic_arg *);
+static int _rl_vi_callback_char_search (_rl_callback_generic_arg *);
 #endif
 
-static int rl_domove_read_callback PARAMS((_rl_vimotion_cxt *));
-static int rl_domove_motion_callback PARAMS((_rl_vimotion_cxt *));
-static int rl_vi_domove_getchar PARAMS((_rl_vimotion_cxt *));
+static int rl_domove_read_callback (_rl_vimotion_cxt *);
+static int rl_domove_motion_callback (_rl_vimotion_cxt *);
+static int rl_vi_domove_getchar (_rl_vimotion_cxt *);
 
-static int vi_change_dispatch PARAMS((_rl_vimotion_cxt *));
-static int vi_delete_dispatch PARAMS((_rl_vimotion_cxt *));
-static int vi_yank_dispatch PARAMS((_rl_vimotion_cxt *));
+static int vi_change_dispatch (_rl_vimotion_cxt *);
+static int vi_delete_dispatch (_rl_vimotion_cxt *);
+static int vi_yank_dispatch (_rl_vimotion_cxt *);
 
-static int vidomove_dispatch PARAMS((_rl_vimotion_cxt *));
+static int vidomove_dispatch (_rl_vimotion_cxt *);
 
 void
 _rl_vi_initialize_line (void)
@@ -337,24 +337,7 @@ rl_vi_yank_arg (int count, int key)
 int
 rl_vi_fetch_history (int count, int c)
 {
-  int wanted;
-
-  /* Giving an argument of n means we want the nth command in the history
-     file.  The command number is interpreted the same way that the bash
-     `history' command does it -- that is, giving an argument count of 450
-     to this command would get the command listed as number 450 in the
-     output of `history'. */
-  if (rl_explicit_arg)
-    {
-      wanted = history_base + where_history () - count;
-      if (wanted <= 0)
-        rl_beginning_of_history (0, 0);
-      else
-        rl_get_previous_history (wanted, c);
-    }
-  else
-    rl_beginning_of_history (count, 0);
-  return (0);
+  return (rl_fetch_history (count, c));
 }
 
 /* Search again for the last thing searched for. */
@@ -944,7 +927,7 @@ rl_vi_arg_digit (int count, int c)
 static int
 _rl_vi_change_mbchar_case (int count)
 {
-  wchar_t wc;
+  WCHAR_T wc;
   char mb[MB_LEN_MAX+1];
   int mlen, p;
   size_t m;
@@ -955,9 +938,9 @@ _rl_vi_change_mbchar_case (int count)
     count--;
   while (count-- && rl_point < rl_end)
     {
-      m = mbrtowc (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);
+      m = MBRTOWC (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);
       if (MB_INVALIDCH (m))
-	wc = (wchar_t)rl_line_buffer[rl_point];
+	wc = (WCHAR_T)rl_line_buffer[rl_point];
       else if (MB_NULLWCH (m))
 	wc = L'\0';
       if (iswupper (wc))
@@ -975,7 +958,7 @@ _rl_vi_change_mbchar_case (int count)
       if (wc)
 	{
 	  p = rl_point;
-	  mlen = wcrtomb (mb, wc, &ps);
+	  mlen = WCRTOMB (mb, wc, &ps);
 	  if (mlen >= 0)
 	    mb[mlen] = '\0';
 	  rl_begin_undo_group ();
@@ -1389,8 +1372,15 @@ int
 rl_vi_delete_to (int count, int key)
 {
   int c, r;
+  _rl_vimotion_cxt *savecxt;
 
-  if (_rl_vimvcxt)
+  savecxt = 0;
+  if (_rl_vi_redoing)
+    {
+      savecxt = _rl_vimvcxt;
+      _rl_vimvcxt = _rl_mvcxt_alloc (VIM_DELETE, key);
+    }
+  else if (_rl_vimvcxt)
     _rl_mvcxt_init (_rl_vimvcxt, VIM_DELETE, key);
   else
     _rl_vimvcxt = _rl_mvcxt_alloc (VIM_DELETE, key);
@@ -1433,7 +1423,7 @@ rl_vi_delete_to (int count, int key)
     }
 
   _rl_mvcxt_dispose (_rl_vimvcxt);
-  _rl_vimvcxt = 0;
+  _rl_vimvcxt = savecxt;
 
   return r;
 }
@@ -1481,8 +1471,15 @@ int
 rl_vi_change_to (int count, int key)
 {
   int c, r;
+  _rl_vimotion_cxt *savecxt;
 
-  if (_rl_vimvcxt)
+  savecxt = 0;
+  if (_rl_vi_redoing)
+    {
+      savecxt = _rl_vimvcxt;
+      _rl_vimvcxt = _rl_mvcxt_alloc (VIM_CHANGE, key);
+    }
+  else if (_rl_vimvcxt)
     _rl_mvcxt_init (_rl_vimvcxt, VIM_CHANGE, key);
   else
     _rl_vimvcxt = _rl_mvcxt_alloc (VIM_CHANGE, key);
@@ -1524,7 +1521,7 @@ rl_vi_change_to (int count, int key)
     }
 
   _rl_mvcxt_dispose (_rl_vimvcxt);
-  _rl_vimvcxt = 0;
+  _rl_vimvcxt = savecxt;
 
   return r;
 }
@@ -1553,8 +1550,15 @@ int
 rl_vi_yank_to (int count, int key)
 {
   int c, r;
+  _rl_vimotion_cxt *savecxt;
 
-  if (_rl_vimvcxt)
+  savecxt = 0;
+  if (_rl_vi_redoing)
+    {
+      savecxt = _rl_vimvcxt;
+      _rl_vimvcxt = _rl_mvcxt_alloc (VIM_YANK, key);
+    }
+  else if (_rl_vimvcxt)
     _rl_mvcxt_init (_rl_vimvcxt, VIM_YANK, key);
   else
     _rl_vimvcxt = _rl_mvcxt_alloc (VIM_YANK, key);
@@ -1596,7 +1600,7 @@ rl_vi_yank_to (int count, int key)
     }
 
   _rl_mvcxt_dispose (_rl_vimvcxt);
-  _rl_vimvcxt = 0;
+  _rl_vimvcxt = savecxt;
 
   return r;
 }
@@ -2036,6 +2040,9 @@ _rl_vi_callback_change_char (_rl_callback_generic_arg *data)
   char mb[MB_LEN_MAX+1];
 
   c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);
+  if (c < 0)
+    return -1;
+
 #if defined (HANDLE_MULTIBYTE)
   if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
     strncpy (_rl_vi_last_replacement, mb, MB_LEN_MAX);
@@ -2044,9 +2051,6 @@ _rl_vi_callback_change_char (_rl_callback_generic_arg *data)
     _rl_vi_last_replacement[0] = c;
   _rl_vi_last_replacement[MB_LEN_MAX] = '\0';	/* XXX */
 
-  if (c < 0)
-    return -1;
-
   _rl_callback_func = 0;
   _rl_want_redisplay = 1;
 
@@ -2077,6 +2081,8 @@ rl_vi_change_char (int count, int key)
   else
     {
       c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);
+      if (c < 0)
+	return -1;
 #ifdef HANDLE_MULTIBYTE
       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
 	strncpy (_rl_vi_last_replacement, mb, MB_LEN_MAX);
@@ -2113,7 +2119,8 @@ rl_vi_overstrike (int count, int key)
 
   if (count > 0)
     {
-      _rl_overwrite_char (count, key);
+      if (_rl_overwrite_char (count, key) != 0)
+	return (1);
       vi_replace_count += count;
     }
 
diff --git a/readline/readline/xmalloc.h b/readline/readline/xmalloc.h
index f40d7a596a287c3024598f47f769b0694eaf44a5..0fb9df9c00b4973c61da6f53a5519505e4dc6ae5 100644
--- a/readline/readline/xmalloc.h
+++ b/readline/readline/xmalloc.h
@@ -1,6 +1,6 @@
 /* xmalloc.h -- memory allocation that aborts on errors. */
 
-/* Copyright (C) 1999-2009 Free Software Foundation, Inc.
+/* Copyright (C) 1999-2009,2010-2021 Free Software Foundation, Inc.
 
    This file is part of the GNU Readline Library (Readline), a library
    for reading lines of text with interactive input and history editing.      
@@ -38,8 +38,8 @@
 
 #endif /* !PTR_T */
 
-extern PTR_T xmalloc PARAMS((size_t));
-extern PTR_T xrealloc PARAMS((void *, size_t));
-extern void xfree PARAMS((void *));
+extern PTR_T xmalloc (size_t);
+extern PTR_T xrealloc (void *, size_t);
+extern void xfree (void *);
 
 #endif /* _XMALLOC_H_ */

-- 
2.46.1
